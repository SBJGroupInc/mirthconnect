/*
 * NextGen Connect Client API
 *
 * Swagger documentation for the NextGen Connect Client API.
 *
 * The version of the OpenAPI document: 3.11.0
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Net;
using System.Net.Mime;
using OpenapiGenerator.MirthConnect311.Client;
using OpenapiGenerator.MirthConnect311.Model;

namespace OpenapiGenerator.MirthConnect311.Api
{

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IMessagesApiSync : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// Exports a message attachment into a specific file path accessible by the server.
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="messageId">The ID of the message.</param>
        /// <param name="attachmentId">The ID of the attachment.</param>
        /// <param name="body">The file path to export the attachment to.</param>
        /// <param name="binary">Indicates that the attachment is binary and should be Base64 decoded before writing to file. (optional, default to false)</param>
        /// <returns></returns>
        void ExportAttachmentServer(string channelId, long messageId, string attachmentId, string body, bool? binary = default(bool?));

        /// <summary>
        /// Exports a message attachment into a specific file path accessible by the server.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="messageId">The ID of the message.</param>
        /// <param name="attachmentId">The ID of the attachment.</param>
        /// <param name="body">The file path to export the attachment to.</param>
        /// <param name="binary">Indicates that the attachment is binary and should be Base64 decoded before writing to file. (optional, default to false)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ExportAttachmentServerWithHttpInfo(string channelId, long messageId, string attachmentId, string body, bool? binary = default(bool?));
        /// <summary>
        /// Exports messages into a specific directory path accessible by the server. (\&quot;Try it out\&quot; doesn&#39;t work for this endpoint, but the descriptions are valid. Please use another tool for testing.)
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="filter"></param>
        /// <param name="pageSize">The maximum number of messages that will be queried at a time. (optional)</param>
        /// <param name="writerOptions"> (optional)</param>
        /// <returns>int</returns>
        int ExportMessagesServer(string channelId, MessageFilter filter, int? pageSize = default(int?), MessageWriterOptions writerOptions = default(MessageWriterOptions));

        /// <summary>
        /// Exports messages into a specific directory path accessible by the server. (\&quot;Try it out\&quot; doesn&#39;t work for this endpoint, but the descriptions are valid. Please use another tool for testing.)
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="filter"></param>
        /// <param name="pageSize">The maximum number of messages that will be queried at a time. (optional)</param>
        /// <param name="writerOptions"> (optional)</param>
        /// <returns>ApiResponse of int</returns>
        ApiResponse<int> ExportMessagesServerWithHttpInfo(string channelId, MessageFilter filter, int? pageSize = default(int?), MessageWriterOptions writerOptions = default(MessageWriterOptions));
        /// <summary>
        /// Exports messages into a specific directory path accessible by the server.
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="minMessageId">The minimum message ID to query. (optional)</param>
        /// <param name="maxMessageId">The maximum message ID to query. (optional)</param>
        /// <param name="minOriginalId">The minimum original message ID to query. Messages that have been reprocessed will retain their original message ID. (optional)</param>
        /// <param name="maxOriginalId">The maximum original message ID to query. Messages that have been reprocessed will retain their original message ID. (optional)</param>
        /// <param name="minImportId">The minimum import message ID to query. Messages that have been imported will retain their original message ID under this value. (optional)</param>
        /// <param name="maxImportId">The maximum import message ID to query. Messages that have been imported will retain their original message ID under this value. (optional)</param>
        /// <param name="startDate">The earliest original received date to query by. Example: 1985-10-26T09:00:00.000-0700 (optional)</param>
        /// <param name="endDate">The latest original received date to query by. Example: 2015-10-21T07:28:00.000-0700 (optional)</param>
        /// <param name="textSearch">Searches all message content for this string. This process could take a long time depending on the amount of message content currently stored. Any message content that was encrypted by this channel will not be searchable. (optional)</param>
        /// <param name="textSearchRegex">If true, text search input will be considered a regular expression pattern to be matched. Only supported by PostgreSQL, MySQL and Oracle databases. (optional)</param>
        /// <param name="status">Determines which message statuses to query by. (optional)</param>
        /// <param name="includedMetaDataId">If present, only connector metadata IDs in this list will be queried. (optional)</param>
        /// <param name="excludedMetaDataId">If present, connector metadata IDs in this list will not be queried. (optional)</param>
        /// <param name="serverId">The server ID associated with messages. (optional)</param>
        /// <param name="rawContentSearch">Searches the raw content of messages. (optional)</param>
        /// <param name="processedRawContentSearch">Searches the processed raw content of messages. (optional)</param>
        /// <param name="transformedContentSearch">Searches the transformed content of messages. (optional)</param>
        /// <param name="encodedContentSearch">Searches the encoded content of messages. (optional)</param>
        /// <param name="sentContentSearch">Searches the sent content of messages. (optional)</param>
        /// <param name="responseContentSearch">Searches the response content of messages. (optional)</param>
        /// <param name="responseTransformedContentSearch">Searches the response transformed content of messages. (optional)</param>
        /// <param name="processedResponseContentSearch">Searches the processed response content of messages. (optional)</param>
        /// <param name="connectorMapContentSearch">Searches the connector map content of messages. (optional)</param>
        /// <param name="channelMapContentSearch">Searches the channel map content of messages. (optional)</param>
        /// <param name="sourceMapContentSearch">Searches the source map content of messages. (optional)</param>
        /// <param name="responseMapContentSearch">Searches the response map content of messages. (optional)</param>
        /// <param name="processingErrorContentSearch">Searches the processing error content of messages. (optional)</param>
        /// <param name="postprocessorErrorContentSearch">Searches the postprocessor error content of messages. (optional)</param>
        /// <param name="responseErrorContentSearch">Searches the response error content of messages. (optional)</param>
        /// <param name="metaDataSearch">Searches a custom metadata column. Value should be in the form: COLUMN_NAME &amp;lt;operator&amp;gt; value, where operator is one of the following: &#x3D;, !&#x3D;, &lt;, &lt;&#x3D;, &gt;, &gt;&#x3D;, CONTAINS, DOES NOT CONTAIN, STARTS WITH, DOES NOT START WITH, ENDS WITH, DOES NOT END WITH (optional)</param>
        /// <param name="metaDataCaseInsensitiveSearch">Searches a custom metadata column, ignoring case. Value should be in the form: COLUMN_NAME &amp;lt;operator&amp;gt; value. (optional)</param>
        /// <param name="textSearchMetaDataColumn">When using a text search, these custom metadata columns will also be searched. (optional)</param>
        /// <param name="minSendAttempts">The minimum number of send attempts for connector messages. (optional)</param>
        /// <param name="maxSendAttempts">The maximum number of send attempts for connector messages. (optional)</param>
        /// <param name="attachment">If true, only messages with attachments are included in the results. (optional)</param>
        /// <param name="error">If true, only messages with errors are included in the results. (optional)</param>
        /// <param name="pageSize">The maximum number of messages that will be queried at a time. (optional)</param>
        /// <param name="contentType">The ContentType that will be extracted from the message for writing. If null or not provided, the entire message will be written in serialized format. (optional)</param>
        /// <param name="destinationContent">If true, the content to write will be extracted from the destination message(s), rather than the source message. (optional, default to false)</param>
        /// <param name="encrypt">If true, message content will be encrypted before writing. (optional, default to false)</param>
        /// <param name="includeAttachments">Determines whether attachments will be included with messages. (optional, default to false)</param>
        /// <param name="baseFolder">The base directory to use when resolving relative paths in the root folder. (optional)</param>
        /// <param name="rootFolder">The root folder to contain the written messages/sub-folders. (optional)</param>
        /// <param name="filePattern">A string defining the folder/filename(s) for writing messages. It may contain variables to be replaced. (optional)</param>
        /// <param name="archiveFileName">The file name to use for archive exports. (optional)</param>
        /// <param name="archiveFormat">The archiver format to use to archive messages/folders that are written to the root folder. Valid values: zip, tar (optional)</param>
        /// <param name="compressFormat">The compressor format to use to compress the archive file. Only valid when using the TAR archive format. Valid values: gz, bzip2 (optional)</param>
        /// <param name="password">The password used to protect the archive file. Only valid when using the ZIP archive format. (optional)</param>
        /// <param name="encryptionType">The algorithm used to encrypt the password-protected archive file. Only valid when using the ZIP archive format. Valid values: STANDARD, AES128, AES256 (optional)</param>
        /// <returns>int</returns>
        int ExportMessagesServer1(string channelId, long? minMessageId = default(long?), long? maxMessageId = default(long?), long? minOriginalId = default(long?), long? maxOriginalId = default(long?), long? minImportId = default(long?), long? maxImportId = default(long?), DateTime? startDate = default(DateTime?), DateTime? endDate = default(DateTime?), string textSearch = default(string), bool? textSearchRegex = default(bool?), List<string> status = default(List<string>), List<int> includedMetaDataId = default(List<int>), List<int> excludedMetaDataId = default(List<int>), string serverId = default(string), List<string> rawContentSearch = default(List<string>), List<string> processedRawContentSearch = default(List<string>), List<string> transformedContentSearch = default(List<string>), List<string> encodedContentSearch = default(List<string>), List<string> sentContentSearch = default(List<string>), List<string> responseContentSearch = default(List<string>), List<string> responseTransformedContentSearch = default(List<string>), List<string> processedResponseContentSearch = default(List<string>), List<string> connectorMapContentSearch = default(List<string>), List<string> channelMapContentSearch = default(List<string>), List<string> sourceMapContentSearch = default(List<string>), List<string> responseMapContentSearch = default(List<string>), List<string> processingErrorContentSearch = default(List<string>), List<string> postprocessorErrorContentSearch = default(List<string>), List<string> responseErrorContentSearch = default(List<string>), List<MetaDataSearch> metaDataSearch = default(List<MetaDataSearch>), List<MetaDataSearch> metaDataCaseInsensitiveSearch = default(List<MetaDataSearch>), List<string> textSearchMetaDataColumn = default(List<string>), int? minSendAttempts = default(int?), int? maxSendAttempts = default(int?), bool? attachment = default(bool?), bool? error = default(bool?), int? pageSize = default(int?), string contentType = default(string), bool? destinationContent = default(bool?), bool? encrypt = default(bool?), bool? includeAttachments = default(bool?), string baseFolder = default(string), string rootFolder = default(string), string filePattern = default(string), string archiveFileName = default(string), string archiveFormat = default(string), string compressFormat = default(string), string password = default(string), string encryptionType = default(string));

        /// <summary>
        /// Exports messages into a specific directory path accessible by the server.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="minMessageId">The minimum message ID to query. (optional)</param>
        /// <param name="maxMessageId">The maximum message ID to query. (optional)</param>
        /// <param name="minOriginalId">The minimum original message ID to query. Messages that have been reprocessed will retain their original message ID. (optional)</param>
        /// <param name="maxOriginalId">The maximum original message ID to query. Messages that have been reprocessed will retain their original message ID. (optional)</param>
        /// <param name="minImportId">The minimum import message ID to query. Messages that have been imported will retain their original message ID under this value. (optional)</param>
        /// <param name="maxImportId">The maximum import message ID to query. Messages that have been imported will retain their original message ID under this value. (optional)</param>
        /// <param name="startDate">The earliest original received date to query by. Example: 1985-10-26T09:00:00.000-0700 (optional)</param>
        /// <param name="endDate">The latest original received date to query by. Example: 2015-10-21T07:28:00.000-0700 (optional)</param>
        /// <param name="textSearch">Searches all message content for this string. This process could take a long time depending on the amount of message content currently stored. Any message content that was encrypted by this channel will not be searchable. (optional)</param>
        /// <param name="textSearchRegex">If true, text search input will be considered a regular expression pattern to be matched. Only supported by PostgreSQL, MySQL and Oracle databases. (optional)</param>
        /// <param name="status">Determines which message statuses to query by. (optional)</param>
        /// <param name="includedMetaDataId">If present, only connector metadata IDs in this list will be queried. (optional)</param>
        /// <param name="excludedMetaDataId">If present, connector metadata IDs in this list will not be queried. (optional)</param>
        /// <param name="serverId">The server ID associated with messages. (optional)</param>
        /// <param name="rawContentSearch">Searches the raw content of messages. (optional)</param>
        /// <param name="processedRawContentSearch">Searches the processed raw content of messages. (optional)</param>
        /// <param name="transformedContentSearch">Searches the transformed content of messages. (optional)</param>
        /// <param name="encodedContentSearch">Searches the encoded content of messages. (optional)</param>
        /// <param name="sentContentSearch">Searches the sent content of messages. (optional)</param>
        /// <param name="responseContentSearch">Searches the response content of messages. (optional)</param>
        /// <param name="responseTransformedContentSearch">Searches the response transformed content of messages. (optional)</param>
        /// <param name="processedResponseContentSearch">Searches the processed response content of messages. (optional)</param>
        /// <param name="connectorMapContentSearch">Searches the connector map content of messages. (optional)</param>
        /// <param name="channelMapContentSearch">Searches the channel map content of messages. (optional)</param>
        /// <param name="sourceMapContentSearch">Searches the source map content of messages. (optional)</param>
        /// <param name="responseMapContentSearch">Searches the response map content of messages. (optional)</param>
        /// <param name="processingErrorContentSearch">Searches the processing error content of messages. (optional)</param>
        /// <param name="postprocessorErrorContentSearch">Searches the postprocessor error content of messages. (optional)</param>
        /// <param name="responseErrorContentSearch">Searches the response error content of messages. (optional)</param>
        /// <param name="metaDataSearch">Searches a custom metadata column. Value should be in the form: COLUMN_NAME &amp;lt;operator&amp;gt; value, where operator is one of the following: &#x3D;, !&#x3D;, &lt;, &lt;&#x3D;, &gt;, &gt;&#x3D;, CONTAINS, DOES NOT CONTAIN, STARTS WITH, DOES NOT START WITH, ENDS WITH, DOES NOT END WITH (optional)</param>
        /// <param name="metaDataCaseInsensitiveSearch">Searches a custom metadata column, ignoring case. Value should be in the form: COLUMN_NAME &amp;lt;operator&amp;gt; value. (optional)</param>
        /// <param name="textSearchMetaDataColumn">When using a text search, these custom metadata columns will also be searched. (optional)</param>
        /// <param name="minSendAttempts">The minimum number of send attempts for connector messages. (optional)</param>
        /// <param name="maxSendAttempts">The maximum number of send attempts for connector messages. (optional)</param>
        /// <param name="attachment">If true, only messages with attachments are included in the results. (optional)</param>
        /// <param name="error">If true, only messages with errors are included in the results. (optional)</param>
        /// <param name="pageSize">The maximum number of messages that will be queried at a time. (optional)</param>
        /// <param name="contentType">The ContentType that will be extracted from the message for writing. If null or not provided, the entire message will be written in serialized format. (optional)</param>
        /// <param name="destinationContent">If true, the content to write will be extracted from the destination message(s), rather than the source message. (optional, default to false)</param>
        /// <param name="encrypt">If true, message content will be encrypted before writing. (optional, default to false)</param>
        /// <param name="includeAttachments">Determines whether attachments will be included with messages. (optional, default to false)</param>
        /// <param name="baseFolder">The base directory to use when resolving relative paths in the root folder. (optional)</param>
        /// <param name="rootFolder">The root folder to contain the written messages/sub-folders. (optional)</param>
        /// <param name="filePattern">A string defining the folder/filename(s) for writing messages. It may contain variables to be replaced. (optional)</param>
        /// <param name="archiveFileName">The file name to use for archive exports. (optional)</param>
        /// <param name="archiveFormat">The archiver format to use to archive messages/folders that are written to the root folder. Valid values: zip, tar (optional)</param>
        /// <param name="compressFormat">The compressor format to use to compress the archive file. Only valid when using the TAR archive format. Valid values: gz, bzip2 (optional)</param>
        /// <param name="password">The password used to protect the archive file. Only valid when using the ZIP archive format. (optional)</param>
        /// <param name="encryptionType">The algorithm used to encrypt the password-protected archive file. Only valid when using the ZIP archive format. Valid values: STANDARD, AES128, AES256 (optional)</param>
        /// <returns>ApiResponse of int</returns>
        ApiResponse<int> ExportMessagesServer1WithHttpInfo(string channelId, long? minMessageId = default(long?), long? maxMessageId = default(long?), long? minOriginalId = default(long?), long? maxOriginalId = default(long?), long? minImportId = default(long?), long? maxImportId = default(long?), DateTime? startDate = default(DateTime?), DateTime? endDate = default(DateTime?), string textSearch = default(string), bool? textSearchRegex = default(bool?), List<string> status = default(List<string>), List<int> includedMetaDataId = default(List<int>), List<int> excludedMetaDataId = default(List<int>), string serverId = default(string), List<string> rawContentSearch = default(List<string>), List<string> processedRawContentSearch = default(List<string>), List<string> transformedContentSearch = default(List<string>), List<string> encodedContentSearch = default(List<string>), List<string> sentContentSearch = default(List<string>), List<string> responseContentSearch = default(List<string>), List<string> responseTransformedContentSearch = default(List<string>), List<string> processedResponseContentSearch = default(List<string>), List<string> connectorMapContentSearch = default(List<string>), List<string> channelMapContentSearch = default(List<string>), List<string> sourceMapContentSearch = default(List<string>), List<string> responseMapContentSearch = default(List<string>), List<string> processingErrorContentSearch = default(List<string>), List<string> postprocessorErrorContentSearch = default(List<string>), List<string> responseErrorContentSearch = default(List<string>), List<MetaDataSearch> metaDataSearch = default(List<MetaDataSearch>), List<MetaDataSearch> metaDataCaseInsensitiveSearch = default(List<MetaDataSearch>), List<string> textSearchMetaDataColumn = default(List<string>), int? minSendAttempts = default(int?), int? maxSendAttempts = default(int?), bool? attachment = default(bool?), bool? error = default(bool?), int? pageSize = default(int?), string contentType = default(string), bool? destinationContent = default(bool?), bool? encrypt = default(bool?), bool? includeAttachments = default(bool?), string baseFolder = default(string), string rootFolder = default(string), string filePattern = default(string), string archiveFileName = default(string), string archiveFormat = default(string), string compressFormat = default(string), string password = default(string), string encryptionType = default(string));
        /// <summary>
        /// Retrieve a message attachment by ID.
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="messageId">The ID of the message.</param>
        /// <param name="attachmentId">The ID of the attachment.</param>
        /// <returns>Attachment</returns>
        Attachment GetAttachment(string channelId, long messageId, string attachmentId);

        /// <summary>
        /// Retrieve a message attachment by ID.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="messageId">The ID of the message.</param>
        /// <param name="attachmentId">The ID of the attachment.</param>
        /// <returns>ApiResponse of Attachment</returns>
        ApiResponse<Attachment> GetAttachmentWithHttpInfo(string channelId, long messageId, string attachmentId);
        /// <summary>
        /// Retrieve a list of attachments by message ID.
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="messageId">The ID of the message.</param>
        /// <param name="includeContent">If false, only the attachment ID and type will be returned. (optional, default to true)</param>
        /// <returns>List&lt;Attachment&gt;</returns>
        List<Attachment> GetAttachmentsByMessageId(string channelId, long messageId, bool? includeContent = default(bool?));

        /// <summary>
        /// Retrieve a list of attachments by message ID.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="messageId">The ID of the message.</param>
        /// <param name="includeContent">If false, only the attachment ID and type will be returned. (optional, default to true)</param>
        /// <returns>ApiResponse of List&lt;Attachment&gt;</returns>
        ApiResponse<List<Attachment>> GetAttachmentsByMessageIdWithHttpInfo(string channelId, long messageId, bool? includeContent = default(bool?));
        /// <summary>
        /// Given a ConnectorMessage object, reattaches any DICOM attachment data and returns the raw Base64 encoded message data.
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="messageId">The ID of the message.</param>
        /// <param name="connectorMessage">The ConnectorMessage to retrieve DICOM data for.</param>
        /// <returns>string</returns>
        string GetDICOMMessage(string channelId, long messageId, ConnectorMessage connectorMessage);

        /// <summary>
        /// Given a ConnectorMessage object, reattaches any DICOM attachment data and returns the raw Base64 encoded message data.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="messageId">The ID of the message.</param>
        /// <param name="connectorMessage">The ConnectorMessage to retrieve DICOM data for.</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> GetDICOMMessageWithHttpInfo(string channelId, long messageId, ConnectorMessage connectorMessage);
        /// <summary>
        /// Returns the maximum message ID for the given channel.
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <returns>long</returns>
        long GetMaxMessageId(string channelId);

        /// <summary>
        /// Returns the maximum message ID for the given channel.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <returns>ApiResponse of long</returns>
        ApiResponse<long> GetMaxMessageIdWithHttpInfo(string channelId);
        /// <summary>
        /// Retrieve a message by ID.
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="messageId">The ID of the message.</param>
        /// <param name="metaDataId">The metadata IDs of the connectors. (optional)</param>
        /// <returns>Message</returns>
        Message GetMessageContent(string channelId, long messageId, List<int> metaDataId = default(List<int>));

        /// <summary>
        /// Retrieve a message by ID.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="messageId">The ID of the message.</param>
        /// <param name="metaDataId">The metadata IDs of the connectors. (optional)</param>
        /// <returns>ApiResponse of Message</returns>
        ApiResponse<Message> GetMessageContentWithHttpInfo(string channelId, long messageId, List<int> metaDataId = default(List<int>));
        /// <summary>
        /// Count number for messages by specific filter criteria.
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="minMessageId">The minimum message ID to query. (optional)</param>
        /// <param name="maxMessageId">The maximum message ID to query. (optional)</param>
        /// <param name="minOriginalId">The minimum original message ID to query. Messages that have been reprocessed will retain their original message ID. (optional)</param>
        /// <param name="maxOriginalId">The maximum original message ID to query. Messages that have been reprocessed will retain their original message ID. (optional)</param>
        /// <param name="minImportId">The minimum import message ID to query. Messages that have been imported will retain their original message ID under this value. (optional)</param>
        /// <param name="maxImportId">The maximum import message ID to query. Messages that have been imported will retain their original message ID under this value. (optional)</param>
        /// <param name="startDate">The earliest original received date to query by. Example: 1985-10-26T09:00:00.000-0700 (optional)</param>
        /// <param name="endDate">The latest original received date to query by. Example: 2015-10-21T07:28:00.000-0700 (optional)</param>
        /// <param name="textSearch">Searches all message content for this string. This process could take a long time depending on the amount of message content currently stored. Any message content that was encrypted by this channel will not be searchable. (optional)</param>
        /// <param name="textSearchRegex">If true, text search input will be considered a regular expression pattern to be matched. Only supported by PostgreSQL, MySQL and Oracle databases. (optional)</param>
        /// <param name="status">Determines which message statuses to query by. (optional)</param>
        /// <param name="includedMetaDataId">If present, only connector metadata IDs in this list will be queried. (optional)</param>
        /// <param name="excludedMetaDataId">If present, connector metadata IDs in this list will not be queried. (optional)</param>
        /// <param name="serverId">The server ID associated with messages. (optional)</param>
        /// <param name="rawContentSearch">Searches the raw content of messages. (optional)</param>
        /// <param name="processedRawContentSearch">Searches the processed raw content of messages. (optional)</param>
        /// <param name="transformedContentSearch">Searches the transformed content of messages. (optional)</param>
        /// <param name="encodedContentSearch">Searches the encoded content of messages. (optional)</param>
        /// <param name="sentContentSearch">Searches the sent content of messages. (optional)</param>
        /// <param name="responseContentSearch">Searches the response content of messages. (optional)</param>
        /// <param name="responseTransformedContentSearch">Searches the response transformed content of messages. (optional)</param>
        /// <param name="processedResponseContentSearch">Searches the processed response content of messages. (optional)</param>
        /// <param name="connectorMapContentSearch">Searches the connector map content of messages. (optional)</param>
        /// <param name="channelMapContentSearch">Searches the channel map content of messages. (optional)</param>
        /// <param name="sourceMapContentSearch">Searches the source map content of messages. (optional)</param>
        /// <param name="responseMapContentSearch">Searches the response map content of messages. (optional)</param>
        /// <param name="processingErrorContentSearch">Searches the processing error content of messages. (optional)</param>
        /// <param name="postprocessorErrorContentSearch">Searches the postprocessor error content of messages. (optional)</param>
        /// <param name="responseErrorContentSearch">Searches the response error content of messages. (optional)</param>
        /// <param name="metaDataSearch">Searches a custom metadata column. Value should be in the form: COLUMN_NAME &amp;lt;operator&amp;gt; value, where operator is one of the following: &#x3D;, !&#x3D;, &lt;, &lt;&#x3D;, &gt;, &gt;&#x3D;, CONTAINS, DOES NOT CONTAIN, STARTS WITH, DOES NOT START WITH, ENDS WITH, DOES NOT END WITH (optional)</param>
        /// <param name="metaDataCaseInsensitiveSearch">Searches a custom metadata column, ignoring case. Value should be in the form: COLUMN_NAME &amp;lt;operator&amp;gt; value. (optional)</param>
        /// <param name="textSearchMetaDataColumn">When using a text search, these custom metadata columns will also be searched. (optional)</param>
        /// <param name="minSendAttempts">The minimum number of send attempts for connector messages. (optional)</param>
        /// <param name="maxSendAttempts">The maximum number of send attempts for connector messages. (optional)</param>
        /// <param name="attachment">If true, only messages with attachments are included in the results. (optional)</param>
        /// <param name="error">If true, only messages with errors are included in the results. (optional)</param>
        /// <returns>long</returns>
        long GetMessageCount(string channelId, long? minMessageId = default(long?), long? maxMessageId = default(long?), long? minOriginalId = default(long?), long? maxOriginalId = default(long?), long? minImportId = default(long?), long? maxImportId = default(long?), DateTime? startDate = default(DateTime?), DateTime? endDate = default(DateTime?), string textSearch = default(string), bool? textSearchRegex = default(bool?), List<string> status = default(List<string>), List<int> includedMetaDataId = default(List<int>), List<int> excludedMetaDataId = default(List<int>), string serverId = default(string), List<string> rawContentSearch = default(List<string>), List<string> processedRawContentSearch = default(List<string>), List<string> transformedContentSearch = default(List<string>), List<string> encodedContentSearch = default(List<string>), List<string> sentContentSearch = default(List<string>), List<string> responseContentSearch = default(List<string>), List<string> responseTransformedContentSearch = default(List<string>), List<string> processedResponseContentSearch = default(List<string>), List<string> connectorMapContentSearch = default(List<string>), List<string> channelMapContentSearch = default(List<string>), List<string> sourceMapContentSearch = default(List<string>), List<string> responseMapContentSearch = default(List<string>), List<string> processingErrorContentSearch = default(List<string>), List<string> postprocessorErrorContentSearch = default(List<string>), List<string> responseErrorContentSearch = default(List<string>), List<MetaDataSearch> metaDataSearch = default(List<MetaDataSearch>), List<MetaDataSearch> metaDataCaseInsensitiveSearch = default(List<MetaDataSearch>), List<string> textSearchMetaDataColumn = default(List<string>), int? minSendAttempts = default(int?), int? maxSendAttempts = default(int?), bool? attachment = default(bool?), bool? error = default(bool?));

        /// <summary>
        /// Count number for messages by specific filter criteria.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="minMessageId">The minimum message ID to query. (optional)</param>
        /// <param name="maxMessageId">The maximum message ID to query. (optional)</param>
        /// <param name="minOriginalId">The minimum original message ID to query. Messages that have been reprocessed will retain their original message ID. (optional)</param>
        /// <param name="maxOriginalId">The maximum original message ID to query. Messages that have been reprocessed will retain their original message ID. (optional)</param>
        /// <param name="minImportId">The minimum import message ID to query. Messages that have been imported will retain their original message ID under this value. (optional)</param>
        /// <param name="maxImportId">The maximum import message ID to query. Messages that have been imported will retain their original message ID under this value. (optional)</param>
        /// <param name="startDate">The earliest original received date to query by. Example: 1985-10-26T09:00:00.000-0700 (optional)</param>
        /// <param name="endDate">The latest original received date to query by. Example: 2015-10-21T07:28:00.000-0700 (optional)</param>
        /// <param name="textSearch">Searches all message content for this string. This process could take a long time depending on the amount of message content currently stored. Any message content that was encrypted by this channel will not be searchable. (optional)</param>
        /// <param name="textSearchRegex">If true, text search input will be considered a regular expression pattern to be matched. Only supported by PostgreSQL, MySQL and Oracle databases. (optional)</param>
        /// <param name="status">Determines which message statuses to query by. (optional)</param>
        /// <param name="includedMetaDataId">If present, only connector metadata IDs in this list will be queried. (optional)</param>
        /// <param name="excludedMetaDataId">If present, connector metadata IDs in this list will not be queried. (optional)</param>
        /// <param name="serverId">The server ID associated with messages. (optional)</param>
        /// <param name="rawContentSearch">Searches the raw content of messages. (optional)</param>
        /// <param name="processedRawContentSearch">Searches the processed raw content of messages. (optional)</param>
        /// <param name="transformedContentSearch">Searches the transformed content of messages. (optional)</param>
        /// <param name="encodedContentSearch">Searches the encoded content of messages. (optional)</param>
        /// <param name="sentContentSearch">Searches the sent content of messages. (optional)</param>
        /// <param name="responseContentSearch">Searches the response content of messages. (optional)</param>
        /// <param name="responseTransformedContentSearch">Searches the response transformed content of messages. (optional)</param>
        /// <param name="processedResponseContentSearch">Searches the processed response content of messages. (optional)</param>
        /// <param name="connectorMapContentSearch">Searches the connector map content of messages. (optional)</param>
        /// <param name="channelMapContentSearch">Searches the channel map content of messages. (optional)</param>
        /// <param name="sourceMapContentSearch">Searches the source map content of messages. (optional)</param>
        /// <param name="responseMapContentSearch">Searches the response map content of messages. (optional)</param>
        /// <param name="processingErrorContentSearch">Searches the processing error content of messages. (optional)</param>
        /// <param name="postprocessorErrorContentSearch">Searches the postprocessor error content of messages. (optional)</param>
        /// <param name="responseErrorContentSearch">Searches the response error content of messages. (optional)</param>
        /// <param name="metaDataSearch">Searches a custom metadata column. Value should be in the form: COLUMN_NAME &amp;lt;operator&amp;gt; value, where operator is one of the following: &#x3D;, !&#x3D;, &lt;, &lt;&#x3D;, &gt;, &gt;&#x3D;, CONTAINS, DOES NOT CONTAIN, STARTS WITH, DOES NOT START WITH, ENDS WITH, DOES NOT END WITH (optional)</param>
        /// <param name="metaDataCaseInsensitiveSearch">Searches a custom metadata column, ignoring case. Value should be in the form: COLUMN_NAME &amp;lt;operator&amp;gt; value. (optional)</param>
        /// <param name="textSearchMetaDataColumn">When using a text search, these custom metadata columns will also be searched. (optional)</param>
        /// <param name="minSendAttempts">The minimum number of send attempts for connector messages. (optional)</param>
        /// <param name="maxSendAttempts">The maximum number of send attempts for connector messages. (optional)</param>
        /// <param name="attachment">If true, only messages with attachments are included in the results. (optional)</param>
        /// <param name="error">If true, only messages with errors are included in the results. (optional)</param>
        /// <returns>ApiResponse of long</returns>
        ApiResponse<long> GetMessageCountWithHttpInfo(string channelId, long? minMessageId = default(long?), long? maxMessageId = default(long?), long? minOriginalId = default(long?), long? maxOriginalId = default(long?), long? minImportId = default(long?), long? maxImportId = default(long?), DateTime? startDate = default(DateTime?), DateTime? endDate = default(DateTime?), string textSearch = default(string), bool? textSearchRegex = default(bool?), List<string> status = default(List<string>), List<int> includedMetaDataId = default(List<int>), List<int> excludedMetaDataId = default(List<int>), string serverId = default(string), List<string> rawContentSearch = default(List<string>), List<string> processedRawContentSearch = default(List<string>), List<string> transformedContentSearch = default(List<string>), List<string> encodedContentSearch = default(List<string>), List<string> sentContentSearch = default(List<string>), List<string> responseContentSearch = default(List<string>), List<string> responseTransformedContentSearch = default(List<string>), List<string> processedResponseContentSearch = default(List<string>), List<string> connectorMapContentSearch = default(List<string>), List<string> channelMapContentSearch = default(List<string>), List<string> sourceMapContentSearch = default(List<string>), List<string> responseMapContentSearch = default(List<string>), List<string> processingErrorContentSearch = default(List<string>), List<string> postprocessorErrorContentSearch = default(List<string>), List<string> responseErrorContentSearch = default(List<string>), List<MetaDataSearch> metaDataSearch = default(List<MetaDataSearch>), List<MetaDataSearch> metaDataCaseInsensitiveSearch = default(List<MetaDataSearch>), List<string> textSearchMetaDataColumn = default(List<string>), int? minSendAttempts = default(int?), int? maxSendAttempts = default(int?), bool? attachment = default(bool?), bool? error = default(bool?));
        /// <summary>
        /// Count number for messages by specific filter criteria.
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="messageFilter">The MessageFilter object to use to query messages by.</param>
        /// <returns>long</returns>
        long GetMessageCount1(string channelId, MessageFilter messageFilter);

        /// <summary>
        /// Count number for messages by specific filter criteria.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="messageFilter">The MessageFilter object to use to query messages by.</param>
        /// <returns>ApiResponse of long</returns>
        ApiResponse<long> GetMessageCount1WithHttpInfo(string channelId, MessageFilter messageFilter);
        /// <summary>
        /// Search for messages by specific filter criteria.
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="minMessageId">The minimum message ID to query. (optional)</param>
        /// <param name="maxMessageId">The maximum message ID to query. (optional)</param>
        /// <param name="minOriginalId">The minimum original message ID to query. Messages that have been reprocessed will retain their original message ID. (optional)</param>
        /// <param name="maxOriginalId">The maximum original message ID to query. Messages that have been reprocessed will retain their original message ID. (optional)</param>
        /// <param name="minImportId">The minimum import message ID to query. Messages that have been imported will retain their original message ID under this value. (optional)</param>
        /// <param name="maxImportId">The maximum import message ID to query. Messages that have been imported will retain their original message ID under this value. (optional)</param>
        /// <param name="startDate">The earliest original received date to query by. Example: 1985-10-26T09:00:00.000-0700 (optional)</param>
        /// <param name="endDate">The latest original received date to query by. Example: 2015-10-21T07:28:00.000-0700 (optional)</param>
        /// <param name="textSearch">Searches all message content for this string. This process could take a long time depending on the amount of message content currently stored. Any message content that was encrypted by this channel will not be searchable. (optional)</param>
        /// <param name="textSearchRegex">If true, text search input will be considered a regular expression pattern to be matched. Only supported by PostgreSQL, MySQL and Oracle databases. (optional)</param>
        /// <param name="status">Determines which message statuses to query by. (optional)</param>
        /// <param name="includedMetaDataId">If present, only connector metadata IDs in this list will be queried. (optional)</param>
        /// <param name="excludedMetaDataId">If present, connector metadata IDs in this list will not be queried. (optional)</param>
        /// <param name="serverId">The server ID associated with messages. (optional)</param>
        /// <param name="rawContentSearch">Searches the raw content of messages. (optional)</param>
        /// <param name="processedRawContentSearch">Searches the processed raw content of messages. (optional)</param>
        /// <param name="transformedContentSearch">Searches the transformed content of messages. (optional)</param>
        /// <param name="encodedContentSearch">Searches the encoded content of messages. (optional)</param>
        /// <param name="sentContentSearch">Searches the sent content of messages. (optional)</param>
        /// <param name="responseContentSearch">Searches the response content of messages. (optional)</param>
        /// <param name="responseTransformedContentSearch">Searches the response transformed content of messages. (optional)</param>
        /// <param name="processedResponseContentSearch">Searches the processed response content of messages. (optional)</param>
        /// <param name="connectorMapContentSearch">Searches the connector map content of messages. (optional)</param>
        /// <param name="channelMapContentSearch">Searches the channel map content of messages. (optional)</param>
        /// <param name="sourceMapContentSearch">Searches the source map content of messages. (optional)</param>
        /// <param name="responseMapContentSearch">Searches the response map content of messages. (optional)</param>
        /// <param name="processingErrorContentSearch">Searches the processing error content of messages. (optional)</param>
        /// <param name="postprocessorErrorContentSearch">Searches the postprocessor error content of messages. (optional)</param>
        /// <param name="responseErrorContentSearch">Searches the response error content of messages. (optional)</param>
        /// <param name="metaDataSearch">Searches a custom metadata column. Value should be in the form: COLUMN_NAME &amp;lt;operator&amp;gt; value, where operator is one of the following: &#x3D;, !&#x3D;, &lt;, &lt;&#x3D;, &gt;, &gt;&#x3D;, CONTAINS, DOES NOT CONTAIN, STARTS WITH, DOES NOT START WITH, ENDS WITH, DOES NOT END WITH (optional)</param>
        /// <param name="metaDataCaseInsensitiveSearch">Searches a custom metadata column, ignoring case. Value should be in the form: COLUMN_NAME &amp;lt;operator&amp;gt; value. (optional)</param>
        /// <param name="textSearchMetaDataColumn">When using a text search, these custom metadata columns will also be searched. (optional)</param>
        /// <param name="minSendAttempts">The minimum number of send attempts for connector messages. (optional)</param>
        /// <param name="maxSendAttempts">The maximum number of send attempts for connector messages. (optional)</param>
        /// <param name="attachment">If true, only messages with attachments are included in the results. (optional)</param>
        /// <param name="error">If true, only messages with errors are included in the results. (optional)</param>
        /// <param name="includeContent">If true, message content will be returned with the results. (optional, default to false)</param>
        /// <param name="offset">Used for pagination, determines where to start in the search results. (optional, default to 0)</param>
        /// <param name="limit">Used for pagination, determines the maximum number of results to return. (optional, default to 20)</param>
        /// <returns>List&lt;Message&gt;</returns>
        List<Message> GetMessages(string channelId, long? minMessageId = default(long?), long? maxMessageId = default(long?), long? minOriginalId = default(long?), long? maxOriginalId = default(long?), long? minImportId = default(long?), long? maxImportId = default(long?), DateTime? startDate = default(DateTime?), DateTime? endDate = default(DateTime?), string textSearch = default(string), bool? textSearchRegex = default(bool?), List<string> status = default(List<string>), List<int> includedMetaDataId = default(List<int>), List<int> excludedMetaDataId = default(List<int>), string serverId = default(string), List<string> rawContentSearch = default(List<string>), List<string> processedRawContentSearch = default(List<string>), List<string> transformedContentSearch = default(List<string>), List<string> encodedContentSearch = default(List<string>), List<string> sentContentSearch = default(List<string>), List<string> responseContentSearch = default(List<string>), List<string> responseTransformedContentSearch = default(List<string>), List<string> processedResponseContentSearch = default(List<string>), List<string> connectorMapContentSearch = default(List<string>), List<string> channelMapContentSearch = default(List<string>), List<string> sourceMapContentSearch = default(List<string>), List<string> responseMapContentSearch = default(List<string>), List<string> processingErrorContentSearch = default(List<string>), List<string> postprocessorErrorContentSearch = default(List<string>), List<string> responseErrorContentSearch = default(List<string>), List<MetaDataSearch> metaDataSearch = default(List<MetaDataSearch>), List<MetaDataSearch> metaDataCaseInsensitiveSearch = default(List<MetaDataSearch>), List<string> textSearchMetaDataColumn = default(List<string>), int? minSendAttempts = default(int?), int? maxSendAttempts = default(int?), bool? attachment = default(bool?), bool? error = default(bool?), bool? includeContent = default(bool?), int? offset = default(int?), int? limit = default(int?));

        /// <summary>
        /// Search for messages by specific filter criteria.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="minMessageId">The minimum message ID to query. (optional)</param>
        /// <param name="maxMessageId">The maximum message ID to query. (optional)</param>
        /// <param name="minOriginalId">The minimum original message ID to query. Messages that have been reprocessed will retain their original message ID. (optional)</param>
        /// <param name="maxOriginalId">The maximum original message ID to query. Messages that have been reprocessed will retain their original message ID. (optional)</param>
        /// <param name="minImportId">The minimum import message ID to query. Messages that have been imported will retain their original message ID under this value. (optional)</param>
        /// <param name="maxImportId">The maximum import message ID to query. Messages that have been imported will retain their original message ID under this value. (optional)</param>
        /// <param name="startDate">The earliest original received date to query by. Example: 1985-10-26T09:00:00.000-0700 (optional)</param>
        /// <param name="endDate">The latest original received date to query by. Example: 2015-10-21T07:28:00.000-0700 (optional)</param>
        /// <param name="textSearch">Searches all message content for this string. This process could take a long time depending on the amount of message content currently stored. Any message content that was encrypted by this channel will not be searchable. (optional)</param>
        /// <param name="textSearchRegex">If true, text search input will be considered a regular expression pattern to be matched. Only supported by PostgreSQL, MySQL and Oracle databases. (optional)</param>
        /// <param name="status">Determines which message statuses to query by. (optional)</param>
        /// <param name="includedMetaDataId">If present, only connector metadata IDs in this list will be queried. (optional)</param>
        /// <param name="excludedMetaDataId">If present, connector metadata IDs in this list will not be queried. (optional)</param>
        /// <param name="serverId">The server ID associated with messages. (optional)</param>
        /// <param name="rawContentSearch">Searches the raw content of messages. (optional)</param>
        /// <param name="processedRawContentSearch">Searches the processed raw content of messages. (optional)</param>
        /// <param name="transformedContentSearch">Searches the transformed content of messages. (optional)</param>
        /// <param name="encodedContentSearch">Searches the encoded content of messages. (optional)</param>
        /// <param name="sentContentSearch">Searches the sent content of messages. (optional)</param>
        /// <param name="responseContentSearch">Searches the response content of messages. (optional)</param>
        /// <param name="responseTransformedContentSearch">Searches the response transformed content of messages. (optional)</param>
        /// <param name="processedResponseContentSearch">Searches the processed response content of messages. (optional)</param>
        /// <param name="connectorMapContentSearch">Searches the connector map content of messages. (optional)</param>
        /// <param name="channelMapContentSearch">Searches the channel map content of messages. (optional)</param>
        /// <param name="sourceMapContentSearch">Searches the source map content of messages. (optional)</param>
        /// <param name="responseMapContentSearch">Searches the response map content of messages. (optional)</param>
        /// <param name="processingErrorContentSearch">Searches the processing error content of messages. (optional)</param>
        /// <param name="postprocessorErrorContentSearch">Searches the postprocessor error content of messages. (optional)</param>
        /// <param name="responseErrorContentSearch">Searches the response error content of messages. (optional)</param>
        /// <param name="metaDataSearch">Searches a custom metadata column. Value should be in the form: COLUMN_NAME &amp;lt;operator&amp;gt; value, where operator is one of the following: &#x3D;, !&#x3D;, &lt;, &lt;&#x3D;, &gt;, &gt;&#x3D;, CONTAINS, DOES NOT CONTAIN, STARTS WITH, DOES NOT START WITH, ENDS WITH, DOES NOT END WITH (optional)</param>
        /// <param name="metaDataCaseInsensitiveSearch">Searches a custom metadata column, ignoring case. Value should be in the form: COLUMN_NAME &amp;lt;operator&amp;gt; value. (optional)</param>
        /// <param name="textSearchMetaDataColumn">When using a text search, these custom metadata columns will also be searched. (optional)</param>
        /// <param name="minSendAttempts">The minimum number of send attempts for connector messages. (optional)</param>
        /// <param name="maxSendAttempts">The maximum number of send attempts for connector messages. (optional)</param>
        /// <param name="attachment">If true, only messages with attachments are included in the results. (optional)</param>
        /// <param name="error">If true, only messages with errors are included in the results. (optional)</param>
        /// <param name="includeContent">If true, message content will be returned with the results. (optional, default to false)</param>
        /// <param name="offset">Used for pagination, determines where to start in the search results. (optional, default to 0)</param>
        /// <param name="limit">Used for pagination, determines the maximum number of results to return. (optional, default to 20)</param>
        /// <returns>ApiResponse of List&lt;Message&gt;</returns>
        ApiResponse<List<Message>> GetMessagesWithHttpInfo(string channelId, long? minMessageId = default(long?), long? maxMessageId = default(long?), long? minOriginalId = default(long?), long? maxOriginalId = default(long?), long? minImportId = default(long?), long? maxImportId = default(long?), DateTime? startDate = default(DateTime?), DateTime? endDate = default(DateTime?), string textSearch = default(string), bool? textSearchRegex = default(bool?), List<string> status = default(List<string>), List<int> includedMetaDataId = default(List<int>), List<int> excludedMetaDataId = default(List<int>), string serverId = default(string), List<string> rawContentSearch = default(List<string>), List<string> processedRawContentSearch = default(List<string>), List<string> transformedContentSearch = default(List<string>), List<string> encodedContentSearch = default(List<string>), List<string> sentContentSearch = default(List<string>), List<string> responseContentSearch = default(List<string>), List<string> responseTransformedContentSearch = default(List<string>), List<string> processedResponseContentSearch = default(List<string>), List<string> connectorMapContentSearch = default(List<string>), List<string> channelMapContentSearch = default(List<string>), List<string> sourceMapContentSearch = default(List<string>), List<string> responseMapContentSearch = default(List<string>), List<string> processingErrorContentSearch = default(List<string>), List<string> postprocessorErrorContentSearch = default(List<string>), List<string> responseErrorContentSearch = default(List<string>), List<MetaDataSearch> metaDataSearch = default(List<MetaDataSearch>), List<MetaDataSearch> metaDataCaseInsensitiveSearch = default(List<MetaDataSearch>), List<string> textSearchMetaDataColumn = default(List<string>), int? minSendAttempts = default(int?), int? maxSendAttempts = default(int?), bool? attachment = default(bool?), bool? error = default(bool?), bool? includeContent = default(bool?), int? offset = default(int?), int? limit = default(int?));
        /// <summary>
        /// Search for messages by specific filter criteria.
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="messageFilter">The MessageFilter object to use to query messages by.</param>
        /// <param name="includeContent">If true, message content will be returned with the results. (optional, default to false)</param>
        /// <param name="offset">Used for pagination, determines where to start in the search results. (optional, default to 0)</param>
        /// <param name="limit">Used for pagination, determines the maximum number of results to return. (optional, default to 20)</param>
        /// <returns>List&lt;Message&gt;</returns>
        List<Message> GetMessages1(string channelId, MessageFilter messageFilter, bool? includeContent = default(bool?), int? offset = default(int?), int? limit = default(int?));

        /// <summary>
        /// Search for messages by specific filter criteria.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="messageFilter">The MessageFilter object to use to query messages by.</param>
        /// <param name="includeContent">If true, message content will be returned with the results. (optional, default to false)</param>
        /// <param name="offset">Used for pagination, determines where to start in the search results. (optional, default to 0)</param>
        /// <param name="limit">Used for pagination, determines the maximum number of results to return. (optional, default to 20)</param>
        /// <returns>ApiResponse of List&lt;Message&gt;</returns>
        ApiResponse<List<Message>> GetMessages1WithHttpInfo(string channelId, MessageFilter messageFilter, bool? includeContent = default(bool?), int? offset = default(int?), int? limit = default(int?));
        /// <summary>
        /// Imports a Message object into a channel. The message will not actually be processed through the channel, only imported.
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="message">The Message object to import.</param>
        /// <returns></returns>
        void ImportMessage(string channelId, Message message);

        /// <summary>
        /// Imports a Message object into a channel. The message will not actually be processed through the channel, only imported.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="message">The Message object to import.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ImportMessageWithHttpInfo(string channelId, Message message);
        /// <summary>
        /// Imports messages into a channel from a path accessible by the server. The messages will not actually be processed through the channel, only imported.
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="body">The directory path on the server side to import messages from.</param>
        /// <param name="includeSubfolders">If true, sub-folders will also be scanned recursively for messages. (optional, default to false)</param>
        /// <returns>MessageImportResult</returns>
        MessageImportResult ImportMessagesServer(string channelId, string body, bool? includeSubfolders = default(bool?));

        /// <summary>
        /// Imports messages into a channel from a path accessible by the server. The messages will not actually be processed through the channel, only imported.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="body">The directory path on the server side to import messages from.</param>
        /// <param name="includeSubfolders">If true, sub-folders will also be scanned recursively for messages. (optional, default to false)</param>
        /// <returns>ApiResponse of MessageImportResult</returns>
        ApiResponse<MessageImportResult> ImportMessagesServerWithHttpInfo(string channelId, string body, bool? includeSubfolders = default(bool?));
        /// <summary>
        /// Processes a new message through a channel.
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="body">The raw message data to process.</param>
        /// <param name="destinationMetaDataId">Indicates which destinations to send the message to. (optional)</param>
        /// <param name="sourceMapEntry">These entries will be injected into the source map for the message. Value should be in the format: key&#x3D;value (optional)</param>
        /// <param name="overwrite">If true and a valid original message ID is given, this message will overwrite the existing one. (optional)</param>
        /// <param name="imported">If true, marks this message as being imported. If the message is overwriting an existing one, then statistics will not be decremented. (optional)</param>
        /// <param name="originalMessageId">The original message ID this message is associated with. (optional)</param>
        /// <returns>long</returns>
        long ProcessMessage(string channelId, string body, List<int> destinationMetaDataId = default(List<int>), List<string> sourceMapEntry = default(List<string>), bool? overwrite = default(bool?), bool? imported = default(bool?), long? originalMessageId = default(long?));

        /// <summary>
        /// Processes a new message through a channel.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="body">The raw message data to process.</param>
        /// <param name="destinationMetaDataId">Indicates which destinations to send the message to. (optional)</param>
        /// <param name="sourceMapEntry">These entries will be injected into the source map for the message. Value should be in the format: key&#x3D;value (optional)</param>
        /// <param name="overwrite">If true and a valid original message ID is given, this message will overwrite the existing one. (optional)</param>
        /// <param name="imported">If true, marks this message as being imported. If the message is overwriting an existing one, then statistics will not be decremented. (optional)</param>
        /// <param name="originalMessageId">The original message ID this message is associated with. (optional)</param>
        /// <returns>ApiResponse of long</returns>
        ApiResponse<long> ProcessMessageWithHttpInfo(string channelId, string body, List<int> destinationMetaDataId = default(List<int>), List<string> sourceMapEntry = default(List<string>), bool? overwrite = default(bool?), bool? imported = default(bool?), long? originalMessageId = default(long?));
        /// <summary>
        /// Processes a new message through a channel, using the RawMessage object.
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="rawMessage">The RawMessage object to process.</param>
        /// <returns>long</returns>
        long ProcessMessage1(string channelId, RawMessage rawMessage);

        /// <summary>
        /// Processes a new message through a channel, using the RawMessage object.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="rawMessage">The RawMessage object to process.</param>
        /// <returns>ApiResponse of long</returns>
        ApiResponse<long> ProcessMessage1WithHttpInfo(string channelId, RawMessage rawMessage);
        /// <summary>
        /// Removes all messages for the specified channel.
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="restartRunningChannels">If true, currently running channels will be stopped and restarted as part of the remove process. Otherwise, currently running channels will not be included. (optional, default to false)</param>
        /// <param name="clearStatistics">If true, message statistics will also be cleared. (optional, default to true)</param>
        /// <returns></returns>
        void RemoveAllMessages(string channelId, bool? restartRunningChannels = default(bool?), bool? clearStatistics = default(bool?));

        /// <summary>
        /// Removes all messages for the specified channel.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="restartRunningChannels">If true, currently running channels will be stopped and restarted as part of the remove process. Otherwise, currently running channels will not be included. (optional, default to false)</param>
        /// <param name="clearStatistics">If true, message statistics will also be cleared. (optional, default to true)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RemoveAllMessagesWithHttpInfo(string channelId, bool? restartRunningChannels = default(bool?), bool? clearStatistics = default(bool?));
        /// <summary>
        /// Removes all messages for multiple specified channels.
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The IDs of the channels.</param>
        /// <param name="restartRunningChannels">If true, currently running channels will be stopped and restarted as part of the remove process. Otherwise, currently running channels will not be included. (optional, default to false)</param>
        /// <param name="clearStatistics">If true, message statistics will also be cleared. (optional, default to true)</param>
        /// <returns></returns>
        void RemoveAllMessages1(List<string> channelId, bool? restartRunningChannels = default(bool?), bool? clearStatistics = default(bool?));

        /// <summary>
        /// Removes all messages for multiple specified channels.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The IDs of the channels.</param>
        /// <param name="restartRunningChannels">If true, currently running channels will be stopped and restarted as part of the remove process. Otherwise, currently running channels will not be included. (optional, default to false)</param>
        /// <param name="clearStatistics">If true, message statistics will also be cleared. (optional, default to true)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RemoveAllMessages1WithHttpInfo(List<string> channelId, bool? restartRunningChannels = default(bool?), bool? clearStatistics = default(bool?));
        /// <summary>
        /// Removes all messages for multiple specified channels. This is a POST request alternative to DELETE /_removeAllMessages that may be used when there are too many channel IDs to include in the query parameters.
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="requestBody">The IDs of the channels.</param>
        /// <param name="restartRunningChannels">If true, currently running channels will be stopped and restarted as part of the remove process. Otherwise, currently running channels will not be included. (optional, default to false)</param>
        /// <param name="clearStatistics">If true, message statistics will also be cleared. (optional, default to true)</param>
        /// <returns></returns>
        void RemoveAllMessagesPost(List<string> requestBody, bool? restartRunningChannels = default(bool?), bool? clearStatistics = default(bool?));

        /// <summary>
        /// Removes all messages for multiple specified channels. This is a POST request alternative to DELETE /_removeAllMessages that may be used when there are too many channel IDs to include in the query parameters.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="requestBody">The IDs of the channels.</param>
        /// <param name="restartRunningChannels">If true, currently running channels will be stopped and restarted as part of the remove process. Otherwise, currently running channels will not be included. (optional, default to false)</param>
        /// <param name="clearStatistics">If true, message statistics will also be cleared. (optional, default to true)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RemoveAllMessagesPostWithHttpInfo(List<string> requestBody, bool? restartRunningChannels = default(bool?), bool? clearStatistics = default(bool?));
        /// <summary>
        /// Remove a single message by ID.
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="messageId">The ID of the message.</param>
        /// <param name="metaDataId">If present, only the specific connector message will be removed. If the metadata ID is 0, the entire message will be removed. (optional)</param>
        /// <returns></returns>
        void RemoveMessage(string channelId, long messageId, int? metaDataId = default(int?));

        /// <summary>
        /// Remove a single message by ID.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="messageId">The ID of the message.</param>
        /// <param name="metaDataId">If present, only the specific connector message will be removed. If the metadata ID is 0, the entire message will be removed. (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RemoveMessageWithHttpInfo(string channelId, long messageId, int? metaDataId = default(int?));
        /// <summary>
        /// Remove messages by specific filter criteria.
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="messageFilter">The MessageFilter object to use to query messages by.</param>
        /// <returns></returns>
        void RemoveMessages(string channelId, MessageFilter messageFilter);

        /// <summary>
        /// Remove messages by specific filter criteria.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="messageFilter">The MessageFilter object to use to query messages by.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RemoveMessagesWithHttpInfo(string channelId, MessageFilter messageFilter);
        /// <summary>
        /// Remove messages by specific filter criteria.
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="minMessageId">The minimum message ID to query. (optional)</param>
        /// <param name="maxMessageId">The maximum message ID to query. (optional)</param>
        /// <param name="minOriginalId">The minimum original message ID to query. Messages that have been reprocessed will retain their original message ID. (optional)</param>
        /// <param name="maxOriginalId">The maximum original message ID to query. Messages that have been reprocessed will retain their original message ID. (optional)</param>
        /// <param name="minImportId">The minimum import message ID to query. Messages that have been imported will retain their original message ID under this value. (optional)</param>
        /// <param name="maxImportId">The maximum import message ID to query. Messages that have been imported will retain their original message ID under this value. (optional)</param>
        /// <param name="startDate">The earliest original received date to query by. Example: 1985-10-26T09:00:00.000-0700 (optional)</param>
        /// <param name="endDate">The latest original received date to query by. Example: 2015-10-21T07:28:00.000-0700 (optional)</param>
        /// <param name="textSearch">Searches all message content for this string. This process could take a long time depending on the amount of message content currently stored. Any message content that was encrypted by this channel will not be searchable. (optional)</param>
        /// <param name="textSearchRegex">If true, text search input will be considered a regular expression pattern to be matched. Only supported by PostgreSQL, MySQL and Oracle databases. (optional)</param>
        /// <param name="status">Determines which message statuses to query by. (optional)</param>
        /// <param name="includedMetaDataId">If present, only connector metadata IDs in this list will be queried. (optional)</param>
        /// <param name="excludedMetaDataId">If present, connector metadata IDs in this list will not be queried. (optional)</param>
        /// <param name="serverId">The server ID associated with messages. (optional)</param>
        /// <param name="rawContentSearch">Searches the raw content of messages. (optional)</param>
        /// <param name="processedRawContentSearch">Searches the processed raw content of messages. (optional)</param>
        /// <param name="transformedContentSearch">Searches the transformed content of messages. (optional)</param>
        /// <param name="encodedContentSearch">Searches the encoded content of messages. (optional)</param>
        /// <param name="sentContentSearch">Searches the sent content of messages. (optional)</param>
        /// <param name="responseContentSearch">Searches the response content of messages. (optional)</param>
        /// <param name="responseTransformedContentSearch">Searches the response transformed content of messages. (optional)</param>
        /// <param name="processedResponseContentSearch">Searches the processed response content of messages. (optional)</param>
        /// <param name="connectorMapContentSearch">Searches the connector map content of messages. (optional)</param>
        /// <param name="channelMapContentSearch">Searches the channel map content of messages. (optional)</param>
        /// <param name="sourceMapContentSearch">Searches the source map content of messages. (optional)</param>
        /// <param name="responseMapContentSearch">Searches the response map content of messages. (optional)</param>
        /// <param name="processingErrorContentSearch">Searches the processing error content of messages. (optional)</param>
        /// <param name="postprocessorErrorContentSearch">Searches the postprocessor error content of messages. (optional)</param>
        /// <param name="responseErrorContentSearch">Searches the response error content of messages. (optional)</param>
        /// <param name="metaDataSearch">Searches a custom metadata column. Value should be in the form: COLUMN_NAME &amp;lt;operator&amp;gt; value, where operator is one of the following: &#x3D;, !&#x3D;, &lt;, &lt;&#x3D;, &gt;, &gt;&#x3D;, CONTAINS, DOES NOT CONTAIN, STARTS WITH, DOES NOT START WITH, ENDS WITH, DOES NOT END WITH (optional)</param>
        /// <param name="metaDataCaseInsensitiveSearch">Searches a custom metadata column, ignoring case. Value should be in the form: COLUMN_NAME &amp;lt;operator&amp;gt; value. (optional)</param>
        /// <param name="textSearchMetaDataColumn">When using a text search, these custom metadata columns will also be searched. (optional)</param>
        /// <param name="minSendAttempts">The minimum number of send attempts for connector messages. (optional)</param>
        /// <param name="maxSendAttempts">The maximum number of send attempts for connector messages. (optional)</param>
        /// <param name="attachment">If true, only messages with attachments are included in the results. (optional)</param>
        /// <param name="error">If true, only messages with errors are included in the results. (optional)</param>
        /// <returns></returns>
        void RemoveMessages1(string channelId, long? minMessageId = default(long?), long? maxMessageId = default(long?), long? minOriginalId = default(long?), long? maxOriginalId = default(long?), long? minImportId = default(long?), long? maxImportId = default(long?), DateTime? startDate = default(DateTime?), DateTime? endDate = default(DateTime?), string textSearch = default(string), bool? textSearchRegex = default(bool?), List<string> status = default(List<string>), List<int> includedMetaDataId = default(List<int>), List<int> excludedMetaDataId = default(List<int>), string serverId = default(string), List<string> rawContentSearch = default(List<string>), List<string> processedRawContentSearch = default(List<string>), List<string> transformedContentSearch = default(List<string>), List<string> encodedContentSearch = default(List<string>), List<string> sentContentSearch = default(List<string>), List<string> responseContentSearch = default(List<string>), List<string> responseTransformedContentSearch = default(List<string>), List<string> processedResponseContentSearch = default(List<string>), List<string> connectorMapContentSearch = default(List<string>), List<string> channelMapContentSearch = default(List<string>), List<string> sourceMapContentSearch = default(List<string>), List<string> responseMapContentSearch = default(List<string>), List<string> processingErrorContentSearch = default(List<string>), List<string> postprocessorErrorContentSearch = default(List<string>), List<string> responseErrorContentSearch = default(List<string>), List<MetaDataSearch> metaDataSearch = default(List<MetaDataSearch>), List<MetaDataSearch> metaDataCaseInsensitiveSearch = default(List<MetaDataSearch>), List<string> textSearchMetaDataColumn = default(List<string>), int? minSendAttempts = default(int?), int? maxSendAttempts = default(int?), bool? attachment = default(bool?), bool? error = default(bool?));

        /// <summary>
        /// Remove messages by specific filter criteria.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="minMessageId">The minimum message ID to query. (optional)</param>
        /// <param name="maxMessageId">The maximum message ID to query. (optional)</param>
        /// <param name="minOriginalId">The minimum original message ID to query. Messages that have been reprocessed will retain their original message ID. (optional)</param>
        /// <param name="maxOriginalId">The maximum original message ID to query. Messages that have been reprocessed will retain their original message ID. (optional)</param>
        /// <param name="minImportId">The minimum import message ID to query. Messages that have been imported will retain their original message ID under this value. (optional)</param>
        /// <param name="maxImportId">The maximum import message ID to query. Messages that have been imported will retain their original message ID under this value. (optional)</param>
        /// <param name="startDate">The earliest original received date to query by. Example: 1985-10-26T09:00:00.000-0700 (optional)</param>
        /// <param name="endDate">The latest original received date to query by. Example: 2015-10-21T07:28:00.000-0700 (optional)</param>
        /// <param name="textSearch">Searches all message content for this string. This process could take a long time depending on the amount of message content currently stored. Any message content that was encrypted by this channel will not be searchable. (optional)</param>
        /// <param name="textSearchRegex">If true, text search input will be considered a regular expression pattern to be matched. Only supported by PostgreSQL, MySQL and Oracle databases. (optional)</param>
        /// <param name="status">Determines which message statuses to query by. (optional)</param>
        /// <param name="includedMetaDataId">If present, only connector metadata IDs in this list will be queried. (optional)</param>
        /// <param name="excludedMetaDataId">If present, connector metadata IDs in this list will not be queried. (optional)</param>
        /// <param name="serverId">The server ID associated with messages. (optional)</param>
        /// <param name="rawContentSearch">Searches the raw content of messages. (optional)</param>
        /// <param name="processedRawContentSearch">Searches the processed raw content of messages. (optional)</param>
        /// <param name="transformedContentSearch">Searches the transformed content of messages. (optional)</param>
        /// <param name="encodedContentSearch">Searches the encoded content of messages. (optional)</param>
        /// <param name="sentContentSearch">Searches the sent content of messages. (optional)</param>
        /// <param name="responseContentSearch">Searches the response content of messages. (optional)</param>
        /// <param name="responseTransformedContentSearch">Searches the response transformed content of messages. (optional)</param>
        /// <param name="processedResponseContentSearch">Searches the processed response content of messages. (optional)</param>
        /// <param name="connectorMapContentSearch">Searches the connector map content of messages. (optional)</param>
        /// <param name="channelMapContentSearch">Searches the channel map content of messages. (optional)</param>
        /// <param name="sourceMapContentSearch">Searches the source map content of messages. (optional)</param>
        /// <param name="responseMapContentSearch">Searches the response map content of messages. (optional)</param>
        /// <param name="processingErrorContentSearch">Searches the processing error content of messages. (optional)</param>
        /// <param name="postprocessorErrorContentSearch">Searches the postprocessor error content of messages. (optional)</param>
        /// <param name="responseErrorContentSearch">Searches the response error content of messages. (optional)</param>
        /// <param name="metaDataSearch">Searches a custom metadata column. Value should be in the form: COLUMN_NAME &amp;lt;operator&amp;gt; value, where operator is one of the following: &#x3D;, !&#x3D;, &lt;, &lt;&#x3D;, &gt;, &gt;&#x3D;, CONTAINS, DOES NOT CONTAIN, STARTS WITH, DOES NOT START WITH, ENDS WITH, DOES NOT END WITH (optional)</param>
        /// <param name="metaDataCaseInsensitiveSearch">Searches a custom metadata column, ignoring case. Value should be in the form: COLUMN_NAME &amp;lt;operator&amp;gt; value. (optional)</param>
        /// <param name="textSearchMetaDataColumn">When using a text search, these custom metadata columns will also be searched. (optional)</param>
        /// <param name="minSendAttempts">The minimum number of send attempts for connector messages. (optional)</param>
        /// <param name="maxSendAttempts">The maximum number of send attempts for connector messages. (optional)</param>
        /// <param name="attachment">If true, only messages with attachments are included in the results. (optional)</param>
        /// <param name="error">If true, only messages with errors are included in the results. (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RemoveMessages1WithHttpInfo(string channelId, long? minMessageId = default(long?), long? maxMessageId = default(long?), long? minOriginalId = default(long?), long? maxOriginalId = default(long?), long? minImportId = default(long?), long? maxImportId = default(long?), DateTime? startDate = default(DateTime?), DateTime? endDate = default(DateTime?), string textSearch = default(string), bool? textSearchRegex = default(bool?), List<string> status = default(List<string>), List<int> includedMetaDataId = default(List<int>), List<int> excludedMetaDataId = default(List<int>), string serverId = default(string), List<string> rawContentSearch = default(List<string>), List<string> processedRawContentSearch = default(List<string>), List<string> transformedContentSearch = default(List<string>), List<string> encodedContentSearch = default(List<string>), List<string> sentContentSearch = default(List<string>), List<string> responseContentSearch = default(List<string>), List<string> responseTransformedContentSearch = default(List<string>), List<string> processedResponseContentSearch = default(List<string>), List<string> connectorMapContentSearch = default(List<string>), List<string> channelMapContentSearch = default(List<string>), List<string> sourceMapContentSearch = default(List<string>), List<string> responseMapContentSearch = default(List<string>), List<string> processingErrorContentSearch = default(List<string>), List<string> postprocessorErrorContentSearch = default(List<string>), List<string> responseErrorContentSearch = default(List<string>), List<MetaDataSearch> metaDataSearch = default(List<MetaDataSearch>), List<MetaDataSearch> metaDataCaseInsensitiveSearch = default(List<MetaDataSearch>), List<string> textSearchMetaDataColumn = default(List<string>), int? minSendAttempts = default(int?), int? maxSendAttempts = default(int?), bool? attachment = default(bool?), bool? error = default(bool?));
        /// <summary>
        /// Reprocesses and overwrites a single message.
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="messageId">The ID of the message.</param>
        /// <param name="replace">If true, the message will overwrite the current one (optional, default to false)</param>
        /// <param name="filterDestinations">If true, the metaDataId parameter will be used to determine which destinations to reprocess the message through. (optional, default to false)</param>
        /// <param name="metaDataId">Indicates which destinations to send the message to. (optional)</param>
        /// <returns></returns>
        void ReprocessMessage(string channelId, long messageId, bool? replace = default(bool?), bool? filterDestinations = default(bool?), List<int> metaDataId = default(List<int>));

        /// <summary>
        /// Reprocesses and overwrites a single message.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="messageId">The ID of the message.</param>
        /// <param name="replace">If true, the message will overwrite the current one (optional, default to false)</param>
        /// <param name="filterDestinations">If true, the metaDataId parameter will be used to determine which destinations to reprocess the message through. (optional, default to false)</param>
        /// <param name="metaDataId">Indicates which destinations to send the message to. (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReprocessMessageWithHttpInfo(string channelId, long messageId, bool? replace = default(bool?), bool? filterDestinations = default(bool?), List<int> metaDataId = default(List<int>));
        /// <summary>
        /// Reprocesses messages through a channel filtering with a MessageFilter.
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="messageFilter">The MessageFilter object to use to query messages by.</param>
        /// <param name="replace">If true, the message will overwrite the current one (optional, default to false)</param>
        /// <param name="filterDestinations">If true, the metaDataId parameter will be used to determine which destinations to reprocess the message through. (optional, default to false)</param>
        /// <param name="metaDataId">Indicates which destinations to send the message to. (optional)</param>
        /// <returns></returns>
        void ReprocessMessages(string channelId, MessageFilter messageFilter, bool? replace = default(bool?), bool? filterDestinations = default(bool?), List<int> metaDataId = default(List<int>));

        /// <summary>
        /// Reprocesses messages through a channel filtering with a MessageFilter.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="messageFilter">The MessageFilter object to use to query messages by.</param>
        /// <param name="replace">If true, the message will overwrite the current one (optional, default to false)</param>
        /// <param name="filterDestinations">If true, the metaDataId parameter will be used to determine which destinations to reprocess the message through. (optional, default to false)</param>
        /// <param name="metaDataId">Indicates which destinations to send the message to. (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReprocessMessagesWithHttpInfo(string channelId, MessageFilter messageFilter, bool? replace = default(bool?), bool? filterDestinations = default(bool?), List<int> metaDataId = default(List<int>));
        /// <summary>
        /// Reprocesses messages through a channel by specific filter criteria.
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="minMessageId">The minimum message ID to query. (optional)</param>
        /// <param name="maxMessageId">The maximum message ID to query. (optional)</param>
        /// <param name="minOriginalId">The minimum original message ID to query. Messages that have been reprocessed will retain their original message ID. (optional)</param>
        /// <param name="maxOriginalId">The maximum original message ID to query. Messages that have been reprocessed will retain their original message ID. (optional)</param>
        /// <param name="minImportId">The minimum import message ID to query. Messages that have been imported will retain their original message ID under this value. (optional)</param>
        /// <param name="maxImportId">The maximum import message ID to query. Messages that have been imported will retain their original message ID under this value. (optional)</param>
        /// <param name="startDate">The earliest original received date to query by. Example: 1985-10-26T09:00:00.000-0700 (optional)</param>
        /// <param name="endDate">The latest original received date to query by. Example: 2015-10-21T07:28:00.000-0700 (optional)</param>
        /// <param name="textSearch">Searches all message content for this string. This process could take a long time depending on the amount of message content currently stored. Any message content that was encrypted by this channel will not be searchable. (optional)</param>
        /// <param name="textSearchRegex">If true, text search input will be considered a regular expression pattern to be matched. Only supported by PostgreSQL, MySQL and Oracle databases. (optional)</param>
        /// <param name="status">Determines which message statuses to query by. (optional)</param>
        /// <param name="includedMetaDataId">If present, only connector metadata IDs in this list will be queried. (optional)</param>
        /// <param name="excludedMetaDataId">If present, connector metadata IDs in this list will not be queried. (optional)</param>
        /// <param name="serverId">The server ID associated with messages. (optional)</param>
        /// <param name="rawContentSearch">Searches the raw content of messages. (optional)</param>
        /// <param name="processedRawContentSearch">Searches the processed raw content of messages. (optional)</param>
        /// <param name="transformedContentSearch">Searches the transformed content of messages. (optional)</param>
        /// <param name="encodedContentSearch">Searches the encoded content of messages. (optional)</param>
        /// <param name="sentContentSearch">Searches the sent content of messages. (optional)</param>
        /// <param name="responseContentSearch">Searches the response content of messages. (optional)</param>
        /// <param name="responseTransformedContentSearch">Searches the response transformed content of messages. (optional)</param>
        /// <param name="processedResponseContentSearch">Searches the processed response content of messages. (optional)</param>
        /// <param name="connectorMapContentSearch">Searches the connector map content of messages. (optional)</param>
        /// <param name="channelMapContentSearch">Searches the channel map content of messages. (optional)</param>
        /// <param name="sourceMapContentSearch">Searches the source map content of messages. (optional)</param>
        /// <param name="responseMapContentSearch">Searches the response map content of messages. (optional)</param>
        /// <param name="processingErrorContentSearch">Searches the processing error content of messages. (optional)</param>
        /// <param name="postprocessorErrorContentSearch">Searches the postprocessor error content of messages. (optional)</param>
        /// <param name="responseErrorContentSearch">Searches the response error content of messages. (optional)</param>
        /// <param name="metaDataSearch">Searches a custom metadata column. Value should be in the form: COLUMN_NAME &amp;lt;operator&amp;gt; value, where operator is one of the following: &#x3D;, !&#x3D;, &lt;, &lt;&#x3D;, &gt;, &gt;&#x3D;, CONTAINS, DOES NOT CONTAIN, STARTS WITH, DOES NOT START WITH, ENDS WITH, DOES NOT END WITH (optional)</param>
        /// <param name="metaDataCaseInsensitiveSearch">Searches a custom metadata column, ignoring case. Value should be in the form: COLUMN_NAME &amp;lt;operator&amp;gt; value. (optional)</param>
        /// <param name="textSearchMetaDataColumn">When using a text search, these custom metadata columns will also be searched. (optional)</param>
        /// <param name="minSendAttempts">The minimum number of send attempts for connector messages. (optional)</param>
        /// <param name="maxSendAttempts">The maximum number of send attempts for connector messages. (optional)</param>
        /// <param name="attachment">If true, only messages with attachments are included in the results. (optional)</param>
        /// <param name="error">If true, only messages with errors are included in the results. (optional)</param>
        /// <param name="replace">If true, the message will overwrite the current one (optional, default to false)</param>
        /// <param name="filterDestinations">If true, the metaDataId parameter will be used to determine which destinations to reprocess the message through. (optional, default to false)</param>
        /// <param name="metaDataId">Indicates which destinations to send the message to. (optional)</param>
        /// <returns></returns>
        void ReprocessMessages1(string channelId, long? minMessageId = default(long?), long? maxMessageId = default(long?), long? minOriginalId = default(long?), long? maxOriginalId = default(long?), long? minImportId = default(long?), long? maxImportId = default(long?), DateTime? startDate = default(DateTime?), DateTime? endDate = default(DateTime?), string textSearch = default(string), bool? textSearchRegex = default(bool?), List<string> status = default(List<string>), List<int> includedMetaDataId = default(List<int>), List<int> excludedMetaDataId = default(List<int>), string serverId = default(string), List<string> rawContentSearch = default(List<string>), List<string> processedRawContentSearch = default(List<string>), List<string> transformedContentSearch = default(List<string>), List<string> encodedContentSearch = default(List<string>), List<string> sentContentSearch = default(List<string>), List<string> responseContentSearch = default(List<string>), List<string> responseTransformedContentSearch = default(List<string>), List<string> processedResponseContentSearch = default(List<string>), List<string> connectorMapContentSearch = default(List<string>), List<string> channelMapContentSearch = default(List<string>), List<string> sourceMapContentSearch = default(List<string>), List<string> responseMapContentSearch = default(List<string>), List<string> processingErrorContentSearch = default(List<string>), List<string> postprocessorErrorContentSearch = default(List<string>), List<string> responseErrorContentSearch = default(List<string>), List<MetaDataSearch> metaDataSearch = default(List<MetaDataSearch>), List<MetaDataSearch> metaDataCaseInsensitiveSearch = default(List<MetaDataSearch>), List<string> textSearchMetaDataColumn = default(List<string>), int? minSendAttempts = default(int?), int? maxSendAttempts = default(int?), bool? attachment = default(bool?), bool? error = default(bool?), bool? replace = default(bool?), bool? filterDestinations = default(bool?), List<int> metaDataId = default(List<int>));

        /// <summary>
        /// Reprocesses messages through a channel by specific filter criteria.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="minMessageId">The minimum message ID to query. (optional)</param>
        /// <param name="maxMessageId">The maximum message ID to query. (optional)</param>
        /// <param name="minOriginalId">The minimum original message ID to query. Messages that have been reprocessed will retain their original message ID. (optional)</param>
        /// <param name="maxOriginalId">The maximum original message ID to query. Messages that have been reprocessed will retain their original message ID. (optional)</param>
        /// <param name="minImportId">The minimum import message ID to query. Messages that have been imported will retain their original message ID under this value. (optional)</param>
        /// <param name="maxImportId">The maximum import message ID to query. Messages that have been imported will retain their original message ID under this value. (optional)</param>
        /// <param name="startDate">The earliest original received date to query by. Example: 1985-10-26T09:00:00.000-0700 (optional)</param>
        /// <param name="endDate">The latest original received date to query by. Example: 2015-10-21T07:28:00.000-0700 (optional)</param>
        /// <param name="textSearch">Searches all message content for this string. This process could take a long time depending on the amount of message content currently stored. Any message content that was encrypted by this channel will not be searchable. (optional)</param>
        /// <param name="textSearchRegex">If true, text search input will be considered a regular expression pattern to be matched. Only supported by PostgreSQL, MySQL and Oracle databases. (optional)</param>
        /// <param name="status">Determines which message statuses to query by. (optional)</param>
        /// <param name="includedMetaDataId">If present, only connector metadata IDs in this list will be queried. (optional)</param>
        /// <param name="excludedMetaDataId">If present, connector metadata IDs in this list will not be queried. (optional)</param>
        /// <param name="serverId">The server ID associated with messages. (optional)</param>
        /// <param name="rawContentSearch">Searches the raw content of messages. (optional)</param>
        /// <param name="processedRawContentSearch">Searches the processed raw content of messages. (optional)</param>
        /// <param name="transformedContentSearch">Searches the transformed content of messages. (optional)</param>
        /// <param name="encodedContentSearch">Searches the encoded content of messages. (optional)</param>
        /// <param name="sentContentSearch">Searches the sent content of messages. (optional)</param>
        /// <param name="responseContentSearch">Searches the response content of messages. (optional)</param>
        /// <param name="responseTransformedContentSearch">Searches the response transformed content of messages. (optional)</param>
        /// <param name="processedResponseContentSearch">Searches the processed response content of messages. (optional)</param>
        /// <param name="connectorMapContentSearch">Searches the connector map content of messages. (optional)</param>
        /// <param name="channelMapContentSearch">Searches the channel map content of messages. (optional)</param>
        /// <param name="sourceMapContentSearch">Searches the source map content of messages. (optional)</param>
        /// <param name="responseMapContentSearch">Searches the response map content of messages. (optional)</param>
        /// <param name="processingErrorContentSearch">Searches the processing error content of messages. (optional)</param>
        /// <param name="postprocessorErrorContentSearch">Searches the postprocessor error content of messages. (optional)</param>
        /// <param name="responseErrorContentSearch">Searches the response error content of messages. (optional)</param>
        /// <param name="metaDataSearch">Searches a custom metadata column. Value should be in the form: COLUMN_NAME &amp;lt;operator&amp;gt; value, where operator is one of the following: &#x3D;, !&#x3D;, &lt;, &lt;&#x3D;, &gt;, &gt;&#x3D;, CONTAINS, DOES NOT CONTAIN, STARTS WITH, DOES NOT START WITH, ENDS WITH, DOES NOT END WITH (optional)</param>
        /// <param name="metaDataCaseInsensitiveSearch">Searches a custom metadata column, ignoring case. Value should be in the form: COLUMN_NAME &amp;lt;operator&amp;gt; value. (optional)</param>
        /// <param name="textSearchMetaDataColumn">When using a text search, these custom metadata columns will also be searched. (optional)</param>
        /// <param name="minSendAttempts">The minimum number of send attempts for connector messages. (optional)</param>
        /// <param name="maxSendAttempts">The maximum number of send attempts for connector messages. (optional)</param>
        /// <param name="attachment">If true, only messages with attachments are included in the results. (optional)</param>
        /// <param name="error">If true, only messages with errors are included in the results. (optional)</param>
        /// <param name="replace">If true, the message will overwrite the current one (optional, default to false)</param>
        /// <param name="filterDestinations">If true, the metaDataId parameter will be used to determine which destinations to reprocess the message through. (optional, default to false)</param>
        /// <param name="metaDataId">Indicates which destinations to send the message to. (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReprocessMessages1WithHttpInfo(string channelId, long? minMessageId = default(long?), long? maxMessageId = default(long?), long? minOriginalId = default(long?), long? maxOriginalId = default(long?), long? minImportId = default(long?), long? maxImportId = default(long?), DateTime? startDate = default(DateTime?), DateTime? endDate = default(DateTime?), string textSearch = default(string), bool? textSearchRegex = default(bool?), List<string> status = default(List<string>), List<int> includedMetaDataId = default(List<int>), List<int> excludedMetaDataId = default(List<int>), string serverId = default(string), List<string> rawContentSearch = default(List<string>), List<string> processedRawContentSearch = default(List<string>), List<string> transformedContentSearch = default(List<string>), List<string> encodedContentSearch = default(List<string>), List<string> sentContentSearch = default(List<string>), List<string> responseContentSearch = default(List<string>), List<string> responseTransformedContentSearch = default(List<string>), List<string> processedResponseContentSearch = default(List<string>), List<string> connectorMapContentSearch = default(List<string>), List<string> channelMapContentSearch = default(List<string>), List<string> sourceMapContentSearch = default(List<string>), List<string> responseMapContentSearch = default(List<string>), List<string> processingErrorContentSearch = default(List<string>), List<string> postprocessorErrorContentSearch = default(List<string>), List<string> responseErrorContentSearch = default(List<string>), List<MetaDataSearch> metaDataSearch = default(List<MetaDataSearch>), List<MetaDataSearch> metaDataCaseInsensitiveSearch = default(List<MetaDataSearch>), List<string> textSearchMetaDataColumn = default(List<string>), int? minSendAttempts = default(int?), int? maxSendAttempts = default(int?), bool? attachment = default(bool?), bool? error = default(bool?), bool? replace = default(bool?), bool? filterDestinations = default(bool?), List<int> metaDataId = default(List<int>));
        #endregion Synchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IMessagesApiAsync : IApiAccessor
    {
        #region Asynchronous Operations
        /// <summary>
        /// Exports a message attachment into a specific file path accessible by the server.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="messageId">The ID of the message.</param>
        /// <param name="attachmentId">The ID of the attachment.</param>
        /// <param name="body">The file path to export the attachment to.</param>
        /// <param name="binary">Indicates that the attachment is binary and should be Base64 decoded before writing to file. (optional, default to false)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task ExportAttachmentServerAsync(string channelId, long messageId, string attachmentId, string body, bool? binary = default(bool?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Exports a message attachment into a specific file path accessible by the server.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="messageId">The ID of the message.</param>
        /// <param name="attachmentId">The ID of the attachment.</param>
        /// <param name="body">The file path to export the attachment to.</param>
        /// <param name="binary">Indicates that the attachment is binary and should be Base64 decoded before writing to file. (optional, default to false)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> ExportAttachmentServerWithHttpInfoAsync(string channelId, long messageId, string attachmentId, string body, bool? binary = default(bool?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Exports messages into a specific directory path accessible by the server. (\&quot;Try it out\&quot; doesn&#39;t work for this endpoint, but the descriptions are valid. Please use another tool for testing.)
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="filter"></param>
        /// <param name="pageSize">The maximum number of messages that will be queried at a time. (optional)</param>
        /// <param name="writerOptions"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of int</returns>
        System.Threading.Tasks.Task<int> ExportMessagesServerAsync(string channelId, MessageFilter filter, int? pageSize = default(int?), MessageWriterOptions writerOptions = default(MessageWriterOptions), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Exports messages into a specific directory path accessible by the server. (\&quot;Try it out\&quot; doesn&#39;t work for this endpoint, but the descriptions are valid. Please use another tool for testing.)
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="filter"></param>
        /// <param name="pageSize">The maximum number of messages that will be queried at a time. (optional)</param>
        /// <param name="writerOptions"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (int)</returns>
        System.Threading.Tasks.Task<ApiResponse<int>> ExportMessagesServerWithHttpInfoAsync(string channelId, MessageFilter filter, int? pageSize = default(int?), MessageWriterOptions writerOptions = default(MessageWriterOptions), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Exports messages into a specific directory path accessible by the server.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="minMessageId">The minimum message ID to query. (optional)</param>
        /// <param name="maxMessageId">The maximum message ID to query. (optional)</param>
        /// <param name="minOriginalId">The minimum original message ID to query. Messages that have been reprocessed will retain their original message ID. (optional)</param>
        /// <param name="maxOriginalId">The maximum original message ID to query. Messages that have been reprocessed will retain their original message ID. (optional)</param>
        /// <param name="minImportId">The minimum import message ID to query. Messages that have been imported will retain their original message ID under this value. (optional)</param>
        /// <param name="maxImportId">The maximum import message ID to query. Messages that have been imported will retain their original message ID under this value. (optional)</param>
        /// <param name="startDate">The earliest original received date to query by. Example: 1985-10-26T09:00:00.000-0700 (optional)</param>
        /// <param name="endDate">The latest original received date to query by. Example: 2015-10-21T07:28:00.000-0700 (optional)</param>
        /// <param name="textSearch">Searches all message content for this string. This process could take a long time depending on the amount of message content currently stored. Any message content that was encrypted by this channel will not be searchable. (optional)</param>
        /// <param name="textSearchRegex">If true, text search input will be considered a regular expression pattern to be matched. Only supported by PostgreSQL, MySQL and Oracle databases. (optional)</param>
        /// <param name="status">Determines which message statuses to query by. (optional)</param>
        /// <param name="includedMetaDataId">If present, only connector metadata IDs in this list will be queried. (optional)</param>
        /// <param name="excludedMetaDataId">If present, connector metadata IDs in this list will not be queried. (optional)</param>
        /// <param name="serverId">The server ID associated with messages. (optional)</param>
        /// <param name="rawContentSearch">Searches the raw content of messages. (optional)</param>
        /// <param name="processedRawContentSearch">Searches the processed raw content of messages. (optional)</param>
        /// <param name="transformedContentSearch">Searches the transformed content of messages. (optional)</param>
        /// <param name="encodedContentSearch">Searches the encoded content of messages. (optional)</param>
        /// <param name="sentContentSearch">Searches the sent content of messages. (optional)</param>
        /// <param name="responseContentSearch">Searches the response content of messages. (optional)</param>
        /// <param name="responseTransformedContentSearch">Searches the response transformed content of messages. (optional)</param>
        /// <param name="processedResponseContentSearch">Searches the processed response content of messages. (optional)</param>
        /// <param name="connectorMapContentSearch">Searches the connector map content of messages. (optional)</param>
        /// <param name="channelMapContentSearch">Searches the channel map content of messages. (optional)</param>
        /// <param name="sourceMapContentSearch">Searches the source map content of messages. (optional)</param>
        /// <param name="responseMapContentSearch">Searches the response map content of messages. (optional)</param>
        /// <param name="processingErrorContentSearch">Searches the processing error content of messages. (optional)</param>
        /// <param name="postprocessorErrorContentSearch">Searches the postprocessor error content of messages. (optional)</param>
        /// <param name="responseErrorContentSearch">Searches the response error content of messages. (optional)</param>
        /// <param name="metaDataSearch">Searches a custom metadata column. Value should be in the form: COLUMN_NAME &amp;lt;operator&amp;gt; value, where operator is one of the following: &#x3D;, !&#x3D;, &lt;, &lt;&#x3D;, &gt;, &gt;&#x3D;, CONTAINS, DOES NOT CONTAIN, STARTS WITH, DOES NOT START WITH, ENDS WITH, DOES NOT END WITH (optional)</param>
        /// <param name="metaDataCaseInsensitiveSearch">Searches a custom metadata column, ignoring case. Value should be in the form: COLUMN_NAME &amp;lt;operator&amp;gt; value. (optional)</param>
        /// <param name="textSearchMetaDataColumn">When using a text search, these custom metadata columns will also be searched. (optional)</param>
        /// <param name="minSendAttempts">The minimum number of send attempts for connector messages. (optional)</param>
        /// <param name="maxSendAttempts">The maximum number of send attempts for connector messages. (optional)</param>
        /// <param name="attachment">If true, only messages with attachments are included in the results. (optional)</param>
        /// <param name="error">If true, only messages with errors are included in the results. (optional)</param>
        /// <param name="pageSize">The maximum number of messages that will be queried at a time. (optional)</param>
        /// <param name="contentType">The ContentType that will be extracted from the message for writing. If null or not provided, the entire message will be written in serialized format. (optional)</param>
        /// <param name="destinationContent">If true, the content to write will be extracted from the destination message(s), rather than the source message. (optional, default to false)</param>
        /// <param name="encrypt">If true, message content will be encrypted before writing. (optional, default to false)</param>
        /// <param name="includeAttachments">Determines whether attachments will be included with messages. (optional, default to false)</param>
        /// <param name="baseFolder">The base directory to use when resolving relative paths in the root folder. (optional)</param>
        /// <param name="rootFolder">The root folder to contain the written messages/sub-folders. (optional)</param>
        /// <param name="filePattern">A string defining the folder/filename(s) for writing messages. It may contain variables to be replaced. (optional)</param>
        /// <param name="archiveFileName">The file name to use for archive exports. (optional)</param>
        /// <param name="archiveFormat">The archiver format to use to archive messages/folders that are written to the root folder. Valid values: zip, tar (optional)</param>
        /// <param name="compressFormat">The compressor format to use to compress the archive file. Only valid when using the TAR archive format. Valid values: gz, bzip2 (optional)</param>
        /// <param name="password">The password used to protect the archive file. Only valid when using the ZIP archive format. (optional)</param>
        /// <param name="encryptionType">The algorithm used to encrypt the password-protected archive file. Only valid when using the ZIP archive format. Valid values: STANDARD, AES128, AES256 (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of int</returns>
        System.Threading.Tasks.Task<int> ExportMessagesServer1Async(string channelId, long? minMessageId = default(long?), long? maxMessageId = default(long?), long? minOriginalId = default(long?), long? maxOriginalId = default(long?), long? minImportId = default(long?), long? maxImportId = default(long?), DateTime? startDate = default(DateTime?), DateTime? endDate = default(DateTime?), string textSearch = default(string), bool? textSearchRegex = default(bool?), List<string> status = default(List<string>), List<int> includedMetaDataId = default(List<int>), List<int> excludedMetaDataId = default(List<int>), string serverId = default(string), List<string> rawContentSearch = default(List<string>), List<string> processedRawContentSearch = default(List<string>), List<string> transformedContentSearch = default(List<string>), List<string> encodedContentSearch = default(List<string>), List<string> sentContentSearch = default(List<string>), List<string> responseContentSearch = default(List<string>), List<string> responseTransformedContentSearch = default(List<string>), List<string> processedResponseContentSearch = default(List<string>), List<string> connectorMapContentSearch = default(List<string>), List<string> channelMapContentSearch = default(List<string>), List<string> sourceMapContentSearch = default(List<string>), List<string> responseMapContentSearch = default(List<string>), List<string> processingErrorContentSearch = default(List<string>), List<string> postprocessorErrorContentSearch = default(List<string>), List<string> responseErrorContentSearch = default(List<string>), List<MetaDataSearch> metaDataSearch = default(List<MetaDataSearch>), List<MetaDataSearch> metaDataCaseInsensitiveSearch = default(List<MetaDataSearch>), List<string> textSearchMetaDataColumn = default(List<string>), int? minSendAttempts = default(int?), int? maxSendAttempts = default(int?), bool? attachment = default(bool?), bool? error = default(bool?), int? pageSize = default(int?), string contentType = default(string), bool? destinationContent = default(bool?), bool? encrypt = default(bool?), bool? includeAttachments = default(bool?), string baseFolder = default(string), string rootFolder = default(string), string filePattern = default(string), string archiveFileName = default(string), string archiveFormat = default(string), string compressFormat = default(string), string password = default(string), string encryptionType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Exports messages into a specific directory path accessible by the server.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="minMessageId">The minimum message ID to query. (optional)</param>
        /// <param name="maxMessageId">The maximum message ID to query. (optional)</param>
        /// <param name="minOriginalId">The minimum original message ID to query. Messages that have been reprocessed will retain their original message ID. (optional)</param>
        /// <param name="maxOriginalId">The maximum original message ID to query. Messages that have been reprocessed will retain their original message ID. (optional)</param>
        /// <param name="minImportId">The minimum import message ID to query. Messages that have been imported will retain their original message ID under this value. (optional)</param>
        /// <param name="maxImportId">The maximum import message ID to query. Messages that have been imported will retain their original message ID under this value. (optional)</param>
        /// <param name="startDate">The earliest original received date to query by. Example: 1985-10-26T09:00:00.000-0700 (optional)</param>
        /// <param name="endDate">The latest original received date to query by. Example: 2015-10-21T07:28:00.000-0700 (optional)</param>
        /// <param name="textSearch">Searches all message content for this string. This process could take a long time depending on the amount of message content currently stored. Any message content that was encrypted by this channel will not be searchable. (optional)</param>
        /// <param name="textSearchRegex">If true, text search input will be considered a regular expression pattern to be matched. Only supported by PostgreSQL, MySQL and Oracle databases. (optional)</param>
        /// <param name="status">Determines which message statuses to query by. (optional)</param>
        /// <param name="includedMetaDataId">If present, only connector metadata IDs in this list will be queried. (optional)</param>
        /// <param name="excludedMetaDataId">If present, connector metadata IDs in this list will not be queried. (optional)</param>
        /// <param name="serverId">The server ID associated with messages. (optional)</param>
        /// <param name="rawContentSearch">Searches the raw content of messages. (optional)</param>
        /// <param name="processedRawContentSearch">Searches the processed raw content of messages. (optional)</param>
        /// <param name="transformedContentSearch">Searches the transformed content of messages. (optional)</param>
        /// <param name="encodedContentSearch">Searches the encoded content of messages. (optional)</param>
        /// <param name="sentContentSearch">Searches the sent content of messages. (optional)</param>
        /// <param name="responseContentSearch">Searches the response content of messages. (optional)</param>
        /// <param name="responseTransformedContentSearch">Searches the response transformed content of messages. (optional)</param>
        /// <param name="processedResponseContentSearch">Searches the processed response content of messages. (optional)</param>
        /// <param name="connectorMapContentSearch">Searches the connector map content of messages. (optional)</param>
        /// <param name="channelMapContentSearch">Searches the channel map content of messages. (optional)</param>
        /// <param name="sourceMapContentSearch">Searches the source map content of messages. (optional)</param>
        /// <param name="responseMapContentSearch">Searches the response map content of messages. (optional)</param>
        /// <param name="processingErrorContentSearch">Searches the processing error content of messages. (optional)</param>
        /// <param name="postprocessorErrorContentSearch">Searches the postprocessor error content of messages. (optional)</param>
        /// <param name="responseErrorContentSearch">Searches the response error content of messages. (optional)</param>
        /// <param name="metaDataSearch">Searches a custom metadata column. Value should be in the form: COLUMN_NAME &amp;lt;operator&amp;gt; value, where operator is one of the following: &#x3D;, !&#x3D;, &lt;, &lt;&#x3D;, &gt;, &gt;&#x3D;, CONTAINS, DOES NOT CONTAIN, STARTS WITH, DOES NOT START WITH, ENDS WITH, DOES NOT END WITH (optional)</param>
        /// <param name="metaDataCaseInsensitiveSearch">Searches a custom metadata column, ignoring case. Value should be in the form: COLUMN_NAME &amp;lt;operator&amp;gt; value. (optional)</param>
        /// <param name="textSearchMetaDataColumn">When using a text search, these custom metadata columns will also be searched. (optional)</param>
        /// <param name="minSendAttempts">The minimum number of send attempts for connector messages. (optional)</param>
        /// <param name="maxSendAttempts">The maximum number of send attempts for connector messages. (optional)</param>
        /// <param name="attachment">If true, only messages with attachments are included in the results. (optional)</param>
        /// <param name="error">If true, only messages with errors are included in the results. (optional)</param>
        /// <param name="pageSize">The maximum number of messages that will be queried at a time. (optional)</param>
        /// <param name="contentType">The ContentType that will be extracted from the message for writing. If null or not provided, the entire message will be written in serialized format. (optional)</param>
        /// <param name="destinationContent">If true, the content to write will be extracted from the destination message(s), rather than the source message. (optional, default to false)</param>
        /// <param name="encrypt">If true, message content will be encrypted before writing. (optional, default to false)</param>
        /// <param name="includeAttachments">Determines whether attachments will be included with messages. (optional, default to false)</param>
        /// <param name="baseFolder">The base directory to use when resolving relative paths in the root folder. (optional)</param>
        /// <param name="rootFolder">The root folder to contain the written messages/sub-folders. (optional)</param>
        /// <param name="filePattern">A string defining the folder/filename(s) for writing messages. It may contain variables to be replaced. (optional)</param>
        /// <param name="archiveFileName">The file name to use for archive exports. (optional)</param>
        /// <param name="archiveFormat">The archiver format to use to archive messages/folders that are written to the root folder. Valid values: zip, tar (optional)</param>
        /// <param name="compressFormat">The compressor format to use to compress the archive file. Only valid when using the TAR archive format. Valid values: gz, bzip2 (optional)</param>
        /// <param name="password">The password used to protect the archive file. Only valid when using the ZIP archive format. (optional)</param>
        /// <param name="encryptionType">The algorithm used to encrypt the password-protected archive file. Only valid when using the ZIP archive format. Valid values: STANDARD, AES128, AES256 (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (int)</returns>
        System.Threading.Tasks.Task<ApiResponse<int>> ExportMessagesServer1WithHttpInfoAsync(string channelId, long? minMessageId = default(long?), long? maxMessageId = default(long?), long? minOriginalId = default(long?), long? maxOriginalId = default(long?), long? minImportId = default(long?), long? maxImportId = default(long?), DateTime? startDate = default(DateTime?), DateTime? endDate = default(DateTime?), string textSearch = default(string), bool? textSearchRegex = default(bool?), List<string> status = default(List<string>), List<int> includedMetaDataId = default(List<int>), List<int> excludedMetaDataId = default(List<int>), string serverId = default(string), List<string> rawContentSearch = default(List<string>), List<string> processedRawContentSearch = default(List<string>), List<string> transformedContentSearch = default(List<string>), List<string> encodedContentSearch = default(List<string>), List<string> sentContentSearch = default(List<string>), List<string> responseContentSearch = default(List<string>), List<string> responseTransformedContentSearch = default(List<string>), List<string> processedResponseContentSearch = default(List<string>), List<string> connectorMapContentSearch = default(List<string>), List<string> channelMapContentSearch = default(List<string>), List<string> sourceMapContentSearch = default(List<string>), List<string> responseMapContentSearch = default(List<string>), List<string> processingErrorContentSearch = default(List<string>), List<string> postprocessorErrorContentSearch = default(List<string>), List<string> responseErrorContentSearch = default(List<string>), List<MetaDataSearch> metaDataSearch = default(List<MetaDataSearch>), List<MetaDataSearch> metaDataCaseInsensitiveSearch = default(List<MetaDataSearch>), List<string> textSearchMetaDataColumn = default(List<string>), int? minSendAttempts = default(int?), int? maxSendAttempts = default(int?), bool? attachment = default(bool?), bool? error = default(bool?), int? pageSize = default(int?), string contentType = default(string), bool? destinationContent = default(bool?), bool? encrypt = default(bool?), bool? includeAttachments = default(bool?), string baseFolder = default(string), string rootFolder = default(string), string filePattern = default(string), string archiveFileName = default(string), string archiveFormat = default(string), string compressFormat = default(string), string password = default(string), string encryptionType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Retrieve a message attachment by ID.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="messageId">The ID of the message.</param>
        /// <param name="attachmentId">The ID of the attachment.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Attachment</returns>
        System.Threading.Tasks.Task<Attachment> GetAttachmentAsync(string channelId, long messageId, string attachmentId, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Retrieve a message attachment by ID.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="messageId">The ID of the message.</param>
        /// <param name="attachmentId">The ID of the attachment.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Attachment)</returns>
        System.Threading.Tasks.Task<ApiResponse<Attachment>> GetAttachmentWithHttpInfoAsync(string channelId, long messageId, string attachmentId, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Retrieve a list of attachments by message ID.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="messageId">The ID of the message.</param>
        /// <param name="includeContent">If false, only the attachment ID and type will be returned. (optional, default to true)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;Attachment&gt;</returns>
        System.Threading.Tasks.Task<List<Attachment>> GetAttachmentsByMessageIdAsync(string channelId, long messageId, bool? includeContent = default(bool?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Retrieve a list of attachments by message ID.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="messageId">The ID of the message.</param>
        /// <param name="includeContent">If false, only the attachment ID and type will be returned. (optional, default to true)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;Attachment&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<Attachment>>> GetAttachmentsByMessageIdWithHttpInfoAsync(string channelId, long messageId, bool? includeContent = default(bool?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Given a ConnectorMessage object, reattaches any DICOM attachment data and returns the raw Base64 encoded message data.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="messageId">The ID of the message.</param>
        /// <param name="connectorMessage">The ConnectorMessage to retrieve DICOM data for.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> GetDICOMMessageAsync(string channelId, long messageId, ConnectorMessage connectorMessage, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Given a ConnectorMessage object, reattaches any DICOM attachment data and returns the raw Base64 encoded message data.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="messageId">The ID of the message.</param>
        /// <param name="connectorMessage">The ConnectorMessage to retrieve DICOM data for.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> GetDICOMMessageWithHttpInfoAsync(string channelId, long messageId, ConnectorMessage connectorMessage, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Returns the maximum message ID for the given channel.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of long</returns>
        System.Threading.Tasks.Task<long> GetMaxMessageIdAsync(string channelId, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Returns the maximum message ID for the given channel.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (long)</returns>
        System.Threading.Tasks.Task<ApiResponse<long>> GetMaxMessageIdWithHttpInfoAsync(string channelId, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Retrieve a message by ID.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="messageId">The ID of the message.</param>
        /// <param name="metaDataId">The metadata IDs of the connectors. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Message</returns>
        System.Threading.Tasks.Task<Message> GetMessageContentAsync(string channelId, long messageId, List<int> metaDataId = default(List<int>), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Retrieve a message by ID.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="messageId">The ID of the message.</param>
        /// <param name="metaDataId">The metadata IDs of the connectors. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Message)</returns>
        System.Threading.Tasks.Task<ApiResponse<Message>> GetMessageContentWithHttpInfoAsync(string channelId, long messageId, List<int> metaDataId = default(List<int>), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Count number for messages by specific filter criteria.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="minMessageId">The minimum message ID to query. (optional)</param>
        /// <param name="maxMessageId">The maximum message ID to query. (optional)</param>
        /// <param name="minOriginalId">The minimum original message ID to query. Messages that have been reprocessed will retain their original message ID. (optional)</param>
        /// <param name="maxOriginalId">The maximum original message ID to query. Messages that have been reprocessed will retain their original message ID. (optional)</param>
        /// <param name="minImportId">The minimum import message ID to query. Messages that have been imported will retain their original message ID under this value. (optional)</param>
        /// <param name="maxImportId">The maximum import message ID to query. Messages that have been imported will retain their original message ID under this value. (optional)</param>
        /// <param name="startDate">The earliest original received date to query by. Example: 1985-10-26T09:00:00.000-0700 (optional)</param>
        /// <param name="endDate">The latest original received date to query by. Example: 2015-10-21T07:28:00.000-0700 (optional)</param>
        /// <param name="textSearch">Searches all message content for this string. This process could take a long time depending on the amount of message content currently stored. Any message content that was encrypted by this channel will not be searchable. (optional)</param>
        /// <param name="textSearchRegex">If true, text search input will be considered a regular expression pattern to be matched. Only supported by PostgreSQL, MySQL and Oracle databases. (optional)</param>
        /// <param name="status">Determines which message statuses to query by. (optional)</param>
        /// <param name="includedMetaDataId">If present, only connector metadata IDs in this list will be queried. (optional)</param>
        /// <param name="excludedMetaDataId">If present, connector metadata IDs in this list will not be queried. (optional)</param>
        /// <param name="serverId">The server ID associated with messages. (optional)</param>
        /// <param name="rawContentSearch">Searches the raw content of messages. (optional)</param>
        /// <param name="processedRawContentSearch">Searches the processed raw content of messages. (optional)</param>
        /// <param name="transformedContentSearch">Searches the transformed content of messages. (optional)</param>
        /// <param name="encodedContentSearch">Searches the encoded content of messages. (optional)</param>
        /// <param name="sentContentSearch">Searches the sent content of messages. (optional)</param>
        /// <param name="responseContentSearch">Searches the response content of messages. (optional)</param>
        /// <param name="responseTransformedContentSearch">Searches the response transformed content of messages. (optional)</param>
        /// <param name="processedResponseContentSearch">Searches the processed response content of messages. (optional)</param>
        /// <param name="connectorMapContentSearch">Searches the connector map content of messages. (optional)</param>
        /// <param name="channelMapContentSearch">Searches the channel map content of messages. (optional)</param>
        /// <param name="sourceMapContentSearch">Searches the source map content of messages. (optional)</param>
        /// <param name="responseMapContentSearch">Searches the response map content of messages. (optional)</param>
        /// <param name="processingErrorContentSearch">Searches the processing error content of messages. (optional)</param>
        /// <param name="postprocessorErrorContentSearch">Searches the postprocessor error content of messages. (optional)</param>
        /// <param name="responseErrorContentSearch">Searches the response error content of messages. (optional)</param>
        /// <param name="metaDataSearch">Searches a custom metadata column. Value should be in the form: COLUMN_NAME &amp;lt;operator&amp;gt; value, where operator is one of the following: &#x3D;, !&#x3D;, &lt;, &lt;&#x3D;, &gt;, &gt;&#x3D;, CONTAINS, DOES NOT CONTAIN, STARTS WITH, DOES NOT START WITH, ENDS WITH, DOES NOT END WITH (optional)</param>
        /// <param name="metaDataCaseInsensitiveSearch">Searches a custom metadata column, ignoring case. Value should be in the form: COLUMN_NAME &amp;lt;operator&amp;gt; value. (optional)</param>
        /// <param name="textSearchMetaDataColumn">When using a text search, these custom metadata columns will also be searched. (optional)</param>
        /// <param name="minSendAttempts">The minimum number of send attempts for connector messages. (optional)</param>
        /// <param name="maxSendAttempts">The maximum number of send attempts for connector messages. (optional)</param>
        /// <param name="attachment">If true, only messages with attachments are included in the results. (optional)</param>
        /// <param name="error">If true, only messages with errors are included in the results. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of long</returns>
        System.Threading.Tasks.Task<long> GetMessageCountAsync(string channelId, long? minMessageId = default(long?), long? maxMessageId = default(long?), long? minOriginalId = default(long?), long? maxOriginalId = default(long?), long? minImportId = default(long?), long? maxImportId = default(long?), DateTime? startDate = default(DateTime?), DateTime? endDate = default(DateTime?), string textSearch = default(string), bool? textSearchRegex = default(bool?), List<string> status = default(List<string>), List<int> includedMetaDataId = default(List<int>), List<int> excludedMetaDataId = default(List<int>), string serverId = default(string), List<string> rawContentSearch = default(List<string>), List<string> processedRawContentSearch = default(List<string>), List<string> transformedContentSearch = default(List<string>), List<string> encodedContentSearch = default(List<string>), List<string> sentContentSearch = default(List<string>), List<string> responseContentSearch = default(List<string>), List<string> responseTransformedContentSearch = default(List<string>), List<string> processedResponseContentSearch = default(List<string>), List<string> connectorMapContentSearch = default(List<string>), List<string> channelMapContentSearch = default(List<string>), List<string> sourceMapContentSearch = default(List<string>), List<string> responseMapContentSearch = default(List<string>), List<string> processingErrorContentSearch = default(List<string>), List<string> postprocessorErrorContentSearch = default(List<string>), List<string> responseErrorContentSearch = default(List<string>), List<MetaDataSearch> metaDataSearch = default(List<MetaDataSearch>), List<MetaDataSearch> metaDataCaseInsensitiveSearch = default(List<MetaDataSearch>), List<string> textSearchMetaDataColumn = default(List<string>), int? minSendAttempts = default(int?), int? maxSendAttempts = default(int?), bool? attachment = default(bool?), bool? error = default(bool?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Count number for messages by specific filter criteria.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="minMessageId">The minimum message ID to query. (optional)</param>
        /// <param name="maxMessageId">The maximum message ID to query. (optional)</param>
        /// <param name="minOriginalId">The minimum original message ID to query. Messages that have been reprocessed will retain their original message ID. (optional)</param>
        /// <param name="maxOriginalId">The maximum original message ID to query. Messages that have been reprocessed will retain their original message ID. (optional)</param>
        /// <param name="minImportId">The minimum import message ID to query. Messages that have been imported will retain their original message ID under this value. (optional)</param>
        /// <param name="maxImportId">The maximum import message ID to query. Messages that have been imported will retain their original message ID under this value. (optional)</param>
        /// <param name="startDate">The earliest original received date to query by. Example: 1985-10-26T09:00:00.000-0700 (optional)</param>
        /// <param name="endDate">The latest original received date to query by. Example: 2015-10-21T07:28:00.000-0700 (optional)</param>
        /// <param name="textSearch">Searches all message content for this string. This process could take a long time depending on the amount of message content currently stored. Any message content that was encrypted by this channel will not be searchable. (optional)</param>
        /// <param name="textSearchRegex">If true, text search input will be considered a regular expression pattern to be matched. Only supported by PostgreSQL, MySQL and Oracle databases. (optional)</param>
        /// <param name="status">Determines which message statuses to query by. (optional)</param>
        /// <param name="includedMetaDataId">If present, only connector metadata IDs in this list will be queried. (optional)</param>
        /// <param name="excludedMetaDataId">If present, connector metadata IDs in this list will not be queried. (optional)</param>
        /// <param name="serverId">The server ID associated with messages. (optional)</param>
        /// <param name="rawContentSearch">Searches the raw content of messages. (optional)</param>
        /// <param name="processedRawContentSearch">Searches the processed raw content of messages. (optional)</param>
        /// <param name="transformedContentSearch">Searches the transformed content of messages. (optional)</param>
        /// <param name="encodedContentSearch">Searches the encoded content of messages. (optional)</param>
        /// <param name="sentContentSearch">Searches the sent content of messages. (optional)</param>
        /// <param name="responseContentSearch">Searches the response content of messages. (optional)</param>
        /// <param name="responseTransformedContentSearch">Searches the response transformed content of messages. (optional)</param>
        /// <param name="processedResponseContentSearch">Searches the processed response content of messages. (optional)</param>
        /// <param name="connectorMapContentSearch">Searches the connector map content of messages. (optional)</param>
        /// <param name="channelMapContentSearch">Searches the channel map content of messages. (optional)</param>
        /// <param name="sourceMapContentSearch">Searches the source map content of messages. (optional)</param>
        /// <param name="responseMapContentSearch">Searches the response map content of messages. (optional)</param>
        /// <param name="processingErrorContentSearch">Searches the processing error content of messages. (optional)</param>
        /// <param name="postprocessorErrorContentSearch">Searches the postprocessor error content of messages. (optional)</param>
        /// <param name="responseErrorContentSearch">Searches the response error content of messages. (optional)</param>
        /// <param name="metaDataSearch">Searches a custom metadata column. Value should be in the form: COLUMN_NAME &amp;lt;operator&amp;gt; value, where operator is one of the following: &#x3D;, !&#x3D;, &lt;, &lt;&#x3D;, &gt;, &gt;&#x3D;, CONTAINS, DOES NOT CONTAIN, STARTS WITH, DOES NOT START WITH, ENDS WITH, DOES NOT END WITH (optional)</param>
        /// <param name="metaDataCaseInsensitiveSearch">Searches a custom metadata column, ignoring case. Value should be in the form: COLUMN_NAME &amp;lt;operator&amp;gt; value. (optional)</param>
        /// <param name="textSearchMetaDataColumn">When using a text search, these custom metadata columns will also be searched. (optional)</param>
        /// <param name="minSendAttempts">The minimum number of send attempts for connector messages. (optional)</param>
        /// <param name="maxSendAttempts">The maximum number of send attempts for connector messages. (optional)</param>
        /// <param name="attachment">If true, only messages with attachments are included in the results. (optional)</param>
        /// <param name="error">If true, only messages with errors are included in the results. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (long)</returns>
        System.Threading.Tasks.Task<ApiResponse<long>> GetMessageCountWithHttpInfoAsync(string channelId, long? minMessageId = default(long?), long? maxMessageId = default(long?), long? minOriginalId = default(long?), long? maxOriginalId = default(long?), long? minImportId = default(long?), long? maxImportId = default(long?), DateTime? startDate = default(DateTime?), DateTime? endDate = default(DateTime?), string textSearch = default(string), bool? textSearchRegex = default(bool?), List<string> status = default(List<string>), List<int> includedMetaDataId = default(List<int>), List<int> excludedMetaDataId = default(List<int>), string serverId = default(string), List<string> rawContentSearch = default(List<string>), List<string> processedRawContentSearch = default(List<string>), List<string> transformedContentSearch = default(List<string>), List<string> encodedContentSearch = default(List<string>), List<string> sentContentSearch = default(List<string>), List<string> responseContentSearch = default(List<string>), List<string> responseTransformedContentSearch = default(List<string>), List<string> processedResponseContentSearch = default(List<string>), List<string> connectorMapContentSearch = default(List<string>), List<string> channelMapContentSearch = default(List<string>), List<string> sourceMapContentSearch = default(List<string>), List<string> responseMapContentSearch = default(List<string>), List<string> processingErrorContentSearch = default(List<string>), List<string> postprocessorErrorContentSearch = default(List<string>), List<string> responseErrorContentSearch = default(List<string>), List<MetaDataSearch> metaDataSearch = default(List<MetaDataSearch>), List<MetaDataSearch> metaDataCaseInsensitiveSearch = default(List<MetaDataSearch>), List<string> textSearchMetaDataColumn = default(List<string>), int? minSendAttempts = default(int?), int? maxSendAttempts = default(int?), bool? attachment = default(bool?), bool? error = default(bool?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Count number for messages by specific filter criteria.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="messageFilter">The MessageFilter object to use to query messages by.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of long</returns>
        System.Threading.Tasks.Task<long> GetMessageCount1Async(string channelId, MessageFilter messageFilter, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Count number for messages by specific filter criteria.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="messageFilter">The MessageFilter object to use to query messages by.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (long)</returns>
        System.Threading.Tasks.Task<ApiResponse<long>> GetMessageCount1WithHttpInfoAsync(string channelId, MessageFilter messageFilter, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Search for messages by specific filter criteria.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="minMessageId">The minimum message ID to query. (optional)</param>
        /// <param name="maxMessageId">The maximum message ID to query. (optional)</param>
        /// <param name="minOriginalId">The minimum original message ID to query. Messages that have been reprocessed will retain their original message ID. (optional)</param>
        /// <param name="maxOriginalId">The maximum original message ID to query. Messages that have been reprocessed will retain their original message ID. (optional)</param>
        /// <param name="minImportId">The minimum import message ID to query. Messages that have been imported will retain their original message ID under this value. (optional)</param>
        /// <param name="maxImportId">The maximum import message ID to query. Messages that have been imported will retain their original message ID under this value. (optional)</param>
        /// <param name="startDate">The earliest original received date to query by. Example: 1985-10-26T09:00:00.000-0700 (optional)</param>
        /// <param name="endDate">The latest original received date to query by. Example: 2015-10-21T07:28:00.000-0700 (optional)</param>
        /// <param name="textSearch">Searches all message content for this string. This process could take a long time depending on the amount of message content currently stored. Any message content that was encrypted by this channel will not be searchable. (optional)</param>
        /// <param name="textSearchRegex">If true, text search input will be considered a regular expression pattern to be matched. Only supported by PostgreSQL, MySQL and Oracle databases. (optional)</param>
        /// <param name="status">Determines which message statuses to query by. (optional)</param>
        /// <param name="includedMetaDataId">If present, only connector metadata IDs in this list will be queried. (optional)</param>
        /// <param name="excludedMetaDataId">If present, connector metadata IDs in this list will not be queried. (optional)</param>
        /// <param name="serverId">The server ID associated with messages. (optional)</param>
        /// <param name="rawContentSearch">Searches the raw content of messages. (optional)</param>
        /// <param name="processedRawContentSearch">Searches the processed raw content of messages. (optional)</param>
        /// <param name="transformedContentSearch">Searches the transformed content of messages. (optional)</param>
        /// <param name="encodedContentSearch">Searches the encoded content of messages. (optional)</param>
        /// <param name="sentContentSearch">Searches the sent content of messages. (optional)</param>
        /// <param name="responseContentSearch">Searches the response content of messages. (optional)</param>
        /// <param name="responseTransformedContentSearch">Searches the response transformed content of messages. (optional)</param>
        /// <param name="processedResponseContentSearch">Searches the processed response content of messages. (optional)</param>
        /// <param name="connectorMapContentSearch">Searches the connector map content of messages. (optional)</param>
        /// <param name="channelMapContentSearch">Searches the channel map content of messages. (optional)</param>
        /// <param name="sourceMapContentSearch">Searches the source map content of messages. (optional)</param>
        /// <param name="responseMapContentSearch">Searches the response map content of messages. (optional)</param>
        /// <param name="processingErrorContentSearch">Searches the processing error content of messages. (optional)</param>
        /// <param name="postprocessorErrorContentSearch">Searches the postprocessor error content of messages. (optional)</param>
        /// <param name="responseErrorContentSearch">Searches the response error content of messages. (optional)</param>
        /// <param name="metaDataSearch">Searches a custom metadata column. Value should be in the form: COLUMN_NAME &amp;lt;operator&amp;gt; value, where operator is one of the following: &#x3D;, !&#x3D;, &lt;, &lt;&#x3D;, &gt;, &gt;&#x3D;, CONTAINS, DOES NOT CONTAIN, STARTS WITH, DOES NOT START WITH, ENDS WITH, DOES NOT END WITH (optional)</param>
        /// <param name="metaDataCaseInsensitiveSearch">Searches a custom metadata column, ignoring case. Value should be in the form: COLUMN_NAME &amp;lt;operator&amp;gt; value. (optional)</param>
        /// <param name="textSearchMetaDataColumn">When using a text search, these custom metadata columns will also be searched. (optional)</param>
        /// <param name="minSendAttempts">The minimum number of send attempts for connector messages. (optional)</param>
        /// <param name="maxSendAttempts">The maximum number of send attempts for connector messages. (optional)</param>
        /// <param name="attachment">If true, only messages with attachments are included in the results. (optional)</param>
        /// <param name="error">If true, only messages with errors are included in the results. (optional)</param>
        /// <param name="includeContent">If true, message content will be returned with the results. (optional, default to false)</param>
        /// <param name="offset">Used for pagination, determines where to start in the search results. (optional, default to 0)</param>
        /// <param name="limit">Used for pagination, determines the maximum number of results to return. (optional, default to 20)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;Message&gt;</returns>
        System.Threading.Tasks.Task<List<Message>> GetMessagesAsync(string channelId, long? minMessageId = default(long?), long? maxMessageId = default(long?), long? minOriginalId = default(long?), long? maxOriginalId = default(long?), long? minImportId = default(long?), long? maxImportId = default(long?), DateTime? startDate = default(DateTime?), DateTime? endDate = default(DateTime?), string textSearch = default(string), bool? textSearchRegex = default(bool?), List<string> status = default(List<string>), List<int> includedMetaDataId = default(List<int>), List<int> excludedMetaDataId = default(List<int>), string serverId = default(string), List<string> rawContentSearch = default(List<string>), List<string> processedRawContentSearch = default(List<string>), List<string> transformedContentSearch = default(List<string>), List<string> encodedContentSearch = default(List<string>), List<string> sentContentSearch = default(List<string>), List<string> responseContentSearch = default(List<string>), List<string> responseTransformedContentSearch = default(List<string>), List<string> processedResponseContentSearch = default(List<string>), List<string> connectorMapContentSearch = default(List<string>), List<string> channelMapContentSearch = default(List<string>), List<string> sourceMapContentSearch = default(List<string>), List<string> responseMapContentSearch = default(List<string>), List<string> processingErrorContentSearch = default(List<string>), List<string> postprocessorErrorContentSearch = default(List<string>), List<string> responseErrorContentSearch = default(List<string>), List<MetaDataSearch> metaDataSearch = default(List<MetaDataSearch>), List<MetaDataSearch> metaDataCaseInsensitiveSearch = default(List<MetaDataSearch>), List<string> textSearchMetaDataColumn = default(List<string>), int? minSendAttempts = default(int?), int? maxSendAttempts = default(int?), bool? attachment = default(bool?), bool? error = default(bool?), bool? includeContent = default(bool?), int? offset = default(int?), int? limit = default(int?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Search for messages by specific filter criteria.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="minMessageId">The minimum message ID to query. (optional)</param>
        /// <param name="maxMessageId">The maximum message ID to query. (optional)</param>
        /// <param name="minOriginalId">The minimum original message ID to query. Messages that have been reprocessed will retain their original message ID. (optional)</param>
        /// <param name="maxOriginalId">The maximum original message ID to query. Messages that have been reprocessed will retain their original message ID. (optional)</param>
        /// <param name="minImportId">The minimum import message ID to query. Messages that have been imported will retain their original message ID under this value. (optional)</param>
        /// <param name="maxImportId">The maximum import message ID to query. Messages that have been imported will retain their original message ID under this value. (optional)</param>
        /// <param name="startDate">The earliest original received date to query by. Example: 1985-10-26T09:00:00.000-0700 (optional)</param>
        /// <param name="endDate">The latest original received date to query by. Example: 2015-10-21T07:28:00.000-0700 (optional)</param>
        /// <param name="textSearch">Searches all message content for this string. This process could take a long time depending on the amount of message content currently stored. Any message content that was encrypted by this channel will not be searchable. (optional)</param>
        /// <param name="textSearchRegex">If true, text search input will be considered a regular expression pattern to be matched. Only supported by PostgreSQL, MySQL and Oracle databases. (optional)</param>
        /// <param name="status">Determines which message statuses to query by. (optional)</param>
        /// <param name="includedMetaDataId">If present, only connector metadata IDs in this list will be queried. (optional)</param>
        /// <param name="excludedMetaDataId">If present, connector metadata IDs in this list will not be queried. (optional)</param>
        /// <param name="serverId">The server ID associated with messages. (optional)</param>
        /// <param name="rawContentSearch">Searches the raw content of messages. (optional)</param>
        /// <param name="processedRawContentSearch">Searches the processed raw content of messages. (optional)</param>
        /// <param name="transformedContentSearch">Searches the transformed content of messages. (optional)</param>
        /// <param name="encodedContentSearch">Searches the encoded content of messages. (optional)</param>
        /// <param name="sentContentSearch">Searches the sent content of messages. (optional)</param>
        /// <param name="responseContentSearch">Searches the response content of messages. (optional)</param>
        /// <param name="responseTransformedContentSearch">Searches the response transformed content of messages. (optional)</param>
        /// <param name="processedResponseContentSearch">Searches the processed response content of messages. (optional)</param>
        /// <param name="connectorMapContentSearch">Searches the connector map content of messages. (optional)</param>
        /// <param name="channelMapContentSearch">Searches the channel map content of messages. (optional)</param>
        /// <param name="sourceMapContentSearch">Searches the source map content of messages. (optional)</param>
        /// <param name="responseMapContentSearch">Searches the response map content of messages. (optional)</param>
        /// <param name="processingErrorContentSearch">Searches the processing error content of messages. (optional)</param>
        /// <param name="postprocessorErrorContentSearch">Searches the postprocessor error content of messages. (optional)</param>
        /// <param name="responseErrorContentSearch">Searches the response error content of messages. (optional)</param>
        /// <param name="metaDataSearch">Searches a custom metadata column. Value should be in the form: COLUMN_NAME &amp;lt;operator&amp;gt; value, where operator is one of the following: &#x3D;, !&#x3D;, &lt;, &lt;&#x3D;, &gt;, &gt;&#x3D;, CONTAINS, DOES NOT CONTAIN, STARTS WITH, DOES NOT START WITH, ENDS WITH, DOES NOT END WITH (optional)</param>
        /// <param name="metaDataCaseInsensitiveSearch">Searches a custom metadata column, ignoring case. Value should be in the form: COLUMN_NAME &amp;lt;operator&amp;gt; value. (optional)</param>
        /// <param name="textSearchMetaDataColumn">When using a text search, these custom metadata columns will also be searched. (optional)</param>
        /// <param name="minSendAttempts">The minimum number of send attempts for connector messages. (optional)</param>
        /// <param name="maxSendAttempts">The maximum number of send attempts for connector messages. (optional)</param>
        /// <param name="attachment">If true, only messages with attachments are included in the results. (optional)</param>
        /// <param name="error">If true, only messages with errors are included in the results. (optional)</param>
        /// <param name="includeContent">If true, message content will be returned with the results. (optional, default to false)</param>
        /// <param name="offset">Used for pagination, determines where to start in the search results. (optional, default to 0)</param>
        /// <param name="limit">Used for pagination, determines the maximum number of results to return. (optional, default to 20)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;Message&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<Message>>> GetMessagesWithHttpInfoAsync(string channelId, long? minMessageId = default(long?), long? maxMessageId = default(long?), long? minOriginalId = default(long?), long? maxOriginalId = default(long?), long? minImportId = default(long?), long? maxImportId = default(long?), DateTime? startDate = default(DateTime?), DateTime? endDate = default(DateTime?), string textSearch = default(string), bool? textSearchRegex = default(bool?), List<string> status = default(List<string>), List<int> includedMetaDataId = default(List<int>), List<int> excludedMetaDataId = default(List<int>), string serverId = default(string), List<string> rawContentSearch = default(List<string>), List<string> processedRawContentSearch = default(List<string>), List<string> transformedContentSearch = default(List<string>), List<string> encodedContentSearch = default(List<string>), List<string> sentContentSearch = default(List<string>), List<string> responseContentSearch = default(List<string>), List<string> responseTransformedContentSearch = default(List<string>), List<string> processedResponseContentSearch = default(List<string>), List<string> connectorMapContentSearch = default(List<string>), List<string> channelMapContentSearch = default(List<string>), List<string> sourceMapContentSearch = default(List<string>), List<string> responseMapContentSearch = default(List<string>), List<string> processingErrorContentSearch = default(List<string>), List<string> postprocessorErrorContentSearch = default(List<string>), List<string> responseErrorContentSearch = default(List<string>), List<MetaDataSearch> metaDataSearch = default(List<MetaDataSearch>), List<MetaDataSearch> metaDataCaseInsensitiveSearch = default(List<MetaDataSearch>), List<string> textSearchMetaDataColumn = default(List<string>), int? minSendAttempts = default(int?), int? maxSendAttempts = default(int?), bool? attachment = default(bool?), bool? error = default(bool?), bool? includeContent = default(bool?), int? offset = default(int?), int? limit = default(int?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Search for messages by specific filter criteria.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="messageFilter">The MessageFilter object to use to query messages by.</param>
        /// <param name="includeContent">If true, message content will be returned with the results. (optional, default to false)</param>
        /// <param name="offset">Used for pagination, determines where to start in the search results. (optional, default to 0)</param>
        /// <param name="limit">Used for pagination, determines the maximum number of results to return. (optional, default to 20)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;Message&gt;</returns>
        System.Threading.Tasks.Task<List<Message>> GetMessages1Async(string channelId, MessageFilter messageFilter, bool? includeContent = default(bool?), int? offset = default(int?), int? limit = default(int?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Search for messages by specific filter criteria.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="messageFilter">The MessageFilter object to use to query messages by.</param>
        /// <param name="includeContent">If true, message content will be returned with the results. (optional, default to false)</param>
        /// <param name="offset">Used for pagination, determines where to start in the search results. (optional, default to 0)</param>
        /// <param name="limit">Used for pagination, determines the maximum number of results to return. (optional, default to 20)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;Message&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<Message>>> GetMessages1WithHttpInfoAsync(string channelId, MessageFilter messageFilter, bool? includeContent = default(bool?), int? offset = default(int?), int? limit = default(int?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Imports a Message object into a channel. The message will not actually be processed through the channel, only imported.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="message">The Message object to import.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task ImportMessageAsync(string channelId, Message message, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Imports a Message object into a channel. The message will not actually be processed through the channel, only imported.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="message">The Message object to import.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> ImportMessageWithHttpInfoAsync(string channelId, Message message, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Imports messages into a channel from a path accessible by the server. The messages will not actually be processed through the channel, only imported.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="body">The directory path on the server side to import messages from.</param>
        /// <param name="includeSubfolders">If true, sub-folders will also be scanned recursively for messages. (optional, default to false)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of MessageImportResult</returns>
        System.Threading.Tasks.Task<MessageImportResult> ImportMessagesServerAsync(string channelId, string body, bool? includeSubfolders = default(bool?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Imports messages into a channel from a path accessible by the server. The messages will not actually be processed through the channel, only imported.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="body">The directory path on the server side to import messages from.</param>
        /// <param name="includeSubfolders">If true, sub-folders will also be scanned recursively for messages. (optional, default to false)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (MessageImportResult)</returns>
        System.Threading.Tasks.Task<ApiResponse<MessageImportResult>> ImportMessagesServerWithHttpInfoAsync(string channelId, string body, bool? includeSubfolders = default(bool?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Processes a new message through a channel.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="body">The raw message data to process.</param>
        /// <param name="destinationMetaDataId">Indicates which destinations to send the message to. (optional)</param>
        /// <param name="sourceMapEntry">These entries will be injected into the source map for the message. Value should be in the format: key&#x3D;value (optional)</param>
        /// <param name="overwrite">If true and a valid original message ID is given, this message will overwrite the existing one. (optional)</param>
        /// <param name="imported">If true, marks this message as being imported. If the message is overwriting an existing one, then statistics will not be decremented. (optional)</param>
        /// <param name="originalMessageId">The original message ID this message is associated with. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of long</returns>
        System.Threading.Tasks.Task<long> ProcessMessageAsync(string channelId, string body, List<int> destinationMetaDataId = default(List<int>), List<string> sourceMapEntry = default(List<string>), bool? overwrite = default(bool?), bool? imported = default(bool?), long? originalMessageId = default(long?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Processes a new message through a channel.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="body">The raw message data to process.</param>
        /// <param name="destinationMetaDataId">Indicates which destinations to send the message to. (optional)</param>
        /// <param name="sourceMapEntry">These entries will be injected into the source map for the message. Value should be in the format: key&#x3D;value (optional)</param>
        /// <param name="overwrite">If true and a valid original message ID is given, this message will overwrite the existing one. (optional)</param>
        /// <param name="imported">If true, marks this message as being imported. If the message is overwriting an existing one, then statistics will not be decremented. (optional)</param>
        /// <param name="originalMessageId">The original message ID this message is associated with. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (long)</returns>
        System.Threading.Tasks.Task<ApiResponse<long>> ProcessMessageWithHttpInfoAsync(string channelId, string body, List<int> destinationMetaDataId = default(List<int>), List<string> sourceMapEntry = default(List<string>), bool? overwrite = default(bool?), bool? imported = default(bool?), long? originalMessageId = default(long?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Processes a new message through a channel, using the RawMessage object.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="rawMessage">The RawMessage object to process.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of long</returns>
        System.Threading.Tasks.Task<long> ProcessMessage1Async(string channelId, RawMessage rawMessage, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Processes a new message through a channel, using the RawMessage object.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="rawMessage">The RawMessage object to process.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (long)</returns>
        System.Threading.Tasks.Task<ApiResponse<long>> ProcessMessage1WithHttpInfoAsync(string channelId, RawMessage rawMessage, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Removes all messages for the specified channel.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="restartRunningChannels">If true, currently running channels will be stopped and restarted as part of the remove process. Otherwise, currently running channels will not be included. (optional, default to false)</param>
        /// <param name="clearStatistics">If true, message statistics will also be cleared. (optional, default to true)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RemoveAllMessagesAsync(string channelId, bool? restartRunningChannels = default(bool?), bool? clearStatistics = default(bool?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Removes all messages for the specified channel.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="restartRunningChannels">If true, currently running channels will be stopped and restarted as part of the remove process. Otherwise, currently running channels will not be included. (optional, default to false)</param>
        /// <param name="clearStatistics">If true, message statistics will also be cleared. (optional, default to true)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RemoveAllMessagesWithHttpInfoAsync(string channelId, bool? restartRunningChannels = default(bool?), bool? clearStatistics = default(bool?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Removes all messages for multiple specified channels.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The IDs of the channels.</param>
        /// <param name="restartRunningChannels">If true, currently running channels will be stopped and restarted as part of the remove process. Otherwise, currently running channels will not be included. (optional, default to false)</param>
        /// <param name="clearStatistics">If true, message statistics will also be cleared. (optional, default to true)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RemoveAllMessages1Async(List<string> channelId, bool? restartRunningChannels = default(bool?), bool? clearStatistics = default(bool?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Removes all messages for multiple specified channels.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The IDs of the channels.</param>
        /// <param name="restartRunningChannels">If true, currently running channels will be stopped and restarted as part of the remove process. Otherwise, currently running channels will not be included. (optional, default to false)</param>
        /// <param name="clearStatistics">If true, message statistics will also be cleared. (optional, default to true)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RemoveAllMessages1WithHttpInfoAsync(List<string> channelId, bool? restartRunningChannels = default(bool?), bool? clearStatistics = default(bool?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Removes all messages for multiple specified channels. This is a POST request alternative to DELETE /_removeAllMessages that may be used when there are too many channel IDs to include in the query parameters.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="requestBody">The IDs of the channels.</param>
        /// <param name="restartRunningChannels">If true, currently running channels will be stopped and restarted as part of the remove process. Otherwise, currently running channels will not be included. (optional, default to false)</param>
        /// <param name="clearStatistics">If true, message statistics will also be cleared. (optional, default to true)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RemoveAllMessagesPostAsync(List<string> requestBody, bool? restartRunningChannels = default(bool?), bool? clearStatistics = default(bool?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Removes all messages for multiple specified channels. This is a POST request alternative to DELETE /_removeAllMessages that may be used when there are too many channel IDs to include in the query parameters.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="requestBody">The IDs of the channels.</param>
        /// <param name="restartRunningChannels">If true, currently running channels will be stopped and restarted as part of the remove process. Otherwise, currently running channels will not be included. (optional, default to false)</param>
        /// <param name="clearStatistics">If true, message statistics will also be cleared. (optional, default to true)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RemoveAllMessagesPostWithHttpInfoAsync(List<string> requestBody, bool? restartRunningChannels = default(bool?), bool? clearStatistics = default(bool?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Remove a single message by ID.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="messageId">The ID of the message.</param>
        /// <param name="metaDataId">If present, only the specific connector message will be removed. If the metadata ID is 0, the entire message will be removed. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RemoveMessageAsync(string channelId, long messageId, int? metaDataId = default(int?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Remove a single message by ID.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="messageId">The ID of the message.</param>
        /// <param name="metaDataId">If present, only the specific connector message will be removed. If the metadata ID is 0, the entire message will be removed. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RemoveMessageWithHttpInfoAsync(string channelId, long messageId, int? metaDataId = default(int?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Remove messages by specific filter criteria.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="messageFilter">The MessageFilter object to use to query messages by.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RemoveMessagesAsync(string channelId, MessageFilter messageFilter, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Remove messages by specific filter criteria.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="messageFilter">The MessageFilter object to use to query messages by.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RemoveMessagesWithHttpInfoAsync(string channelId, MessageFilter messageFilter, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Remove messages by specific filter criteria.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="minMessageId">The minimum message ID to query. (optional)</param>
        /// <param name="maxMessageId">The maximum message ID to query. (optional)</param>
        /// <param name="minOriginalId">The minimum original message ID to query. Messages that have been reprocessed will retain their original message ID. (optional)</param>
        /// <param name="maxOriginalId">The maximum original message ID to query. Messages that have been reprocessed will retain their original message ID. (optional)</param>
        /// <param name="minImportId">The minimum import message ID to query. Messages that have been imported will retain their original message ID under this value. (optional)</param>
        /// <param name="maxImportId">The maximum import message ID to query. Messages that have been imported will retain their original message ID under this value. (optional)</param>
        /// <param name="startDate">The earliest original received date to query by. Example: 1985-10-26T09:00:00.000-0700 (optional)</param>
        /// <param name="endDate">The latest original received date to query by. Example: 2015-10-21T07:28:00.000-0700 (optional)</param>
        /// <param name="textSearch">Searches all message content for this string. This process could take a long time depending on the amount of message content currently stored. Any message content that was encrypted by this channel will not be searchable. (optional)</param>
        /// <param name="textSearchRegex">If true, text search input will be considered a regular expression pattern to be matched. Only supported by PostgreSQL, MySQL and Oracle databases. (optional)</param>
        /// <param name="status">Determines which message statuses to query by. (optional)</param>
        /// <param name="includedMetaDataId">If present, only connector metadata IDs in this list will be queried. (optional)</param>
        /// <param name="excludedMetaDataId">If present, connector metadata IDs in this list will not be queried. (optional)</param>
        /// <param name="serverId">The server ID associated with messages. (optional)</param>
        /// <param name="rawContentSearch">Searches the raw content of messages. (optional)</param>
        /// <param name="processedRawContentSearch">Searches the processed raw content of messages. (optional)</param>
        /// <param name="transformedContentSearch">Searches the transformed content of messages. (optional)</param>
        /// <param name="encodedContentSearch">Searches the encoded content of messages. (optional)</param>
        /// <param name="sentContentSearch">Searches the sent content of messages. (optional)</param>
        /// <param name="responseContentSearch">Searches the response content of messages. (optional)</param>
        /// <param name="responseTransformedContentSearch">Searches the response transformed content of messages. (optional)</param>
        /// <param name="processedResponseContentSearch">Searches the processed response content of messages. (optional)</param>
        /// <param name="connectorMapContentSearch">Searches the connector map content of messages. (optional)</param>
        /// <param name="channelMapContentSearch">Searches the channel map content of messages. (optional)</param>
        /// <param name="sourceMapContentSearch">Searches the source map content of messages. (optional)</param>
        /// <param name="responseMapContentSearch">Searches the response map content of messages. (optional)</param>
        /// <param name="processingErrorContentSearch">Searches the processing error content of messages. (optional)</param>
        /// <param name="postprocessorErrorContentSearch">Searches the postprocessor error content of messages. (optional)</param>
        /// <param name="responseErrorContentSearch">Searches the response error content of messages. (optional)</param>
        /// <param name="metaDataSearch">Searches a custom metadata column. Value should be in the form: COLUMN_NAME &amp;lt;operator&amp;gt; value, where operator is one of the following: &#x3D;, !&#x3D;, &lt;, &lt;&#x3D;, &gt;, &gt;&#x3D;, CONTAINS, DOES NOT CONTAIN, STARTS WITH, DOES NOT START WITH, ENDS WITH, DOES NOT END WITH (optional)</param>
        /// <param name="metaDataCaseInsensitiveSearch">Searches a custom metadata column, ignoring case. Value should be in the form: COLUMN_NAME &amp;lt;operator&amp;gt; value. (optional)</param>
        /// <param name="textSearchMetaDataColumn">When using a text search, these custom metadata columns will also be searched. (optional)</param>
        /// <param name="minSendAttempts">The minimum number of send attempts for connector messages. (optional)</param>
        /// <param name="maxSendAttempts">The maximum number of send attempts for connector messages. (optional)</param>
        /// <param name="attachment">If true, only messages with attachments are included in the results. (optional)</param>
        /// <param name="error">If true, only messages with errors are included in the results. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RemoveMessages1Async(string channelId, long? minMessageId = default(long?), long? maxMessageId = default(long?), long? minOriginalId = default(long?), long? maxOriginalId = default(long?), long? minImportId = default(long?), long? maxImportId = default(long?), DateTime? startDate = default(DateTime?), DateTime? endDate = default(DateTime?), string textSearch = default(string), bool? textSearchRegex = default(bool?), List<string> status = default(List<string>), List<int> includedMetaDataId = default(List<int>), List<int> excludedMetaDataId = default(List<int>), string serverId = default(string), List<string> rawContentSearch = default(List<string>), List<string> processedRawContentSearch = default(List<string>), List<string> transformedContentSearch = default(List<string>), List<string> encodedContentSearch = default(List<string>), List<string> sentContentSearch = default(List<string>), List<string> responseContentSearch = default(List<string>), List<string> responseTransformedContentSearch = default(List<string>), List<string> processedResponseContentSearch = default(List<string>), List<string> connectorMapContentSearch = default(List<string>), List<string> channelMapContentSearch = default(List<string>), List<string> sourceMapContentSearch = default(List<string>), List<string> responseMapContentSearch = default(List<string>), List<string> processingErrorContentSearch = default(List<string>), List<string> postprocessorErrorContentSearch = default(List<string>), List<string> responseErrorContentSearch = default(List<string>), List<MetaDataSearch> metaDataSearch = default(List<MetaDataSearch>), List<MetaDataSearch> metaDataCaseInsensitiveSearch = default(List<MetaDataSearch>), List<string> textSearchMetaDataColumn = default(List<string>), int? minSendAttempts = default(int?), int? maxSendAttempts = default(int?), bool? attachment = default(bool?), bool? error = default(bool?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Remove messages by specific filter criteria.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="minMessageId">The minimum message ID to query. (optional)</param>
        /// <param name="maxMessageId">The maximum message ID to query. (optional)</param>
        /// <param name="minOriginalId">The minimum original message ID to query. Messages that have been reprocessed will retain their original message ID. (optional)</param>
        /// <param name="maxOriginalId">The maximum original message ID to query. Messages that have been reprocessed will retain their original message ID. (optional)</param>
        /// <param name="minImportId">The minimum import message ID to query. Messages that have been imported will retain their original message ID under this value. (optional)</param>
        /// <param name="maxImportId">The maximum import message ID to query. Messages that have been imported will retain their original message ID under this value. (optional)</param>
        /// <param name="startDate">The earliest original received date to query by. Example: 1985-10-26T09:00:00.000-0700 (optional)</param>
        /// <param name="endDate">The latest original received date to query by. Example: 2015-10-21T07:28:00.000-0700 (optional)</param>
        /// <param name="textSearch">Searches all message content for this string. This process could take a long time depending on the amount of message content currently stored. Any message content that was encrypted by this channel will not be searchable. (optional)</param>
        /// <param name="textSearchRegex">If true, text search input will be considered a regular expression pattern to be matched. Only supported by PostgreSQL, MySQL and Oracle databases. (optional)</param>
        /// <param name="status">Determines which message statuses to query by. (optional)</param>
        /// <param name="includedMetaDataId">If present, only connector metadata IDs in this list will be queried. (optional)</param>
        /// <param name="excludedMetaDataId">If present, connector metadata IDs in this list will not be queried. (optional)</param>
        /// <param name="serverId">The server ID associated with messages. (optional)</param>
        /// <param name="rawContentSearch">Searches the raw content of messages. (optional)</param>
        /// <param name="processedRawContentSearch">Searches the processed raw content of messages. (optional)</param>
        /// <param name="transformedContentSearch">Searches the transformed content of messages. (optional)</param>
        /// <param name="encodedContentSearch">Searches the encoded content of messages. (optional)</param>
        /// <param name="sentContentSearch">Searches the sent content of messages. (optional)</param>
        /// <param name="responseContentSearch">Searches the response content of messages. (optional)</param>
        /// <param name="responseTransformedContentSearch">Searches the response transformed content of messages. (optional)</param>
        /// <param name="processedResponseContentSearch">Searches the processed response content of messages. (optional)</param>
        /// <param name="connectorMapContentSearch">Searches the connector map content of messages. (optional)</param>
        /// <param name="channelMapContentSearch">Searches the channel map content of messages. (optional)</param>
        /// <param name="sourceMapContentSearch">Searches the source map content of messages. (optional)</param>
        /// <param name="responseMapContentSearch">Searches the response map content of messages. (optional)</param>
        /// <param name="processingErrorContentSearch">Searches the processing error content of messages. (optional)</param>
        /// <param name="postprocessorErrorContentSearch">Searches the postprocessor error content of messages. (optional)</param>
        /// <param name="responseErrorContentSearch">Searches the response error content of messages. (optional)</param>
        /// <param name="metaDataSearch">Searches a custom metadata column. Value should be in the form: COLUMN_NAME &amp;lt;operator&amp;gt; value, where operator is one of the following: &#x3D;, !&#x3D;, &lt;, &lt;&#x3D;, &gt;, &gt;&#x3D;, CONTAINS, DOES NOT CONTAIN, STARTS WITH, DOES NOT START WITH, ENDS WITH, DOES NOT END WITH (optional)</param>
        /// <param name="metaDataCaseInsensitiveSearch">Searches a custom metadata column, ignoring case. Value should be in the form: COLUMN_NAME &amp;lt;operator&amp;gt; value. (optional)</param>
        /// <param name="textSearchMetaDataColumn">When using a text search, these custom metadata columns will also be searched. (optional)</param>
        /// <param name="minSendAttempts">The minimum number of send attempts for connector messages. (optional)</param>
        /// <param name="maxSendAttempts">The maximum number of send attempts for connector messages. (optional)</param>
        /// <param name="attachment">If true, only messages with attachments are included in the results. (optional)</param>
        /// <param name="error">If true, only messages with errors are included in the results. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RemoveMessages1WithHttpInfoAsync(string channelId, long? minMessageId = default(long?), long? maxMessageId = default(long?), long? minOriginalId = default(long?), long? maxOriginalId = default(long?), long? minImportId = default(long?), long? maxImportId = default(long?), DateTime? startDate = default(DateTime?), DateTime? endDate = default(DateTime?), string textSearch = default(string), bool? textSearchRegex = default(bool?), List<string> status = default(List<string>), List<int> includedMetaDataId = default(List<int>), List<int> excludedMetaDataId = default(List<int>), string serverId = default(string), List<string> rawContentSearch = default(List<string>), List<string> processedRawContentSearch = default(List<string>), List<string> transformedContentSearch = default(List<string>), List<string> encodedContentSearch = default(List<string>), List<string> sentContentSearch = default(List<string>), List<string> responseContentSearch = default(List<string>), List<string> responseTransformedContentSearch = default(List<string>), List<string> processedResponseContentSearch = default(List<string>), List<string> connectorMapContentSearch = default(List<string>), List<string> channelMapContentSearch = default(List<string>), List<string> sourceMapContentSearch = default(List<string>), List<string> responseMapContentSearch = default(List<string>), List<string> processingErrorContentSearch = default(List<string>), List<string> postprocessorErrorContentSearch = default(List<string>), List<string> responseErrorContentSearch = default(List<string>), List<MetaDataSearch> metaDataSearch = default(List<MetaDataSearch>), List<MetaDataSearch> metaDataCaseInsensitiveSearch = default(List<MetaDataSearch>), List<string> textSearchMetaDataColumn = default(List<string>), int? minSendAttempts = default(int?), int? maxSendAttempts = default(int?), bool? attachment = default(bool?), bool? error = default(bool?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Reprocesses and overwrites a single message.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="messageId">The ID of the message.</param>
        /// <param name="replace">If true, the message will overwrite the current one (optional, default to false)</param>
        /// <param name="filterDestinations">If true, the metaDataId parameter will be used to determine which destinations to reprocess the message through. (optional, default to false)</param>
        /// <param name="metaDataId">Indicates which destinations to send the message to. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task ReprocessMessageAsync(string channelId, long messageId, bool? replace = default(bool?), bool? filterDestinations = default(bool?), List<int> metaDataId = default(List<int>), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Reprocesses and overwrites a single message.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="messageId">The ID of the message.</param>
        /// <param name="replace">If true, the message will overwrite the current one (optional, default to false)</param>
        /// <param name="filterDestinations">If true, the metaDataId parameter will be used to determine which destinations to reprocess the message through. (optional, default to false)</param>
        /// <param name="metaDataId">Indicates which destinations to send the message to. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> ReprocessMessageWithHttpInfoAsync(string channelId, long messageId, bool? replace = default(bool?), bool? filterDestinations = default(bool?), List<int> metaDataId = default(List<int>), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Reprocesses messages through a channel filtering with a MessageFilter.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="messageFilter">The MessageFilter object to use to query messages by.</param>
        /// <param name="replace">If true, the message will overwrite the current one (optional, default to false)</param>
        /// <param name="filterDestinations">If true, the metaDataId parameter will be used to determine which destinations to reprocess the message through. (optional, default to false)</param>
        /// <param name="metaDataId">Indicates which destinations to send the message to. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task ReprocessMessagesAsync(string channelId, MessageFilter messageFilter, bool? replace = default(bool?), bool? filterDestinations = default(bool?), List<int> metaDataId = default(List<int>), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Reprocesses messages through a channel filtering with a MessageFilter.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="messageFilter">The MessageFilter object to use to query messages by.</param>
        /// <param name="replace">If true, the message will overwrite the current one (optional, default to false)</param>
        /// <param name="filterDestinations">If true, the metaDataId parameter will be used to determine which destinations to reprocess the message through. (optional, default to false)</param>
        /// <param name="metaDataId">Indicates which destinations to send the message to. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> ReprocessMessagesWithHttpInfoAsync(string channelId, MessageFilter messageFilter, bool? replace = default(bool?), bool? filterDestinations = default(bool?), List<int> metaDataId = default(List<int>), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Reprocesses messages through a channel by specific filter criteria.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="minMessageId">The minimum message ID to query. (optional)</param>
        /// <param name="maxMessageId">The maximum message ID to query. (optional)</param>
        /// <param name="minOriginalId">The minimum original message ID to query. Messages that have been reprocessed will retain their original message ID. (optional)</param>
        /// <param name="maxOriginalId">The maximum original message ID to query. Messages that have been reprocessed will retain their original message ID. (optional)</param>
        /// <param name="minImportId">The minimum import message ID to query. Messages that have been imported will retain their original message ID under this value. (optional)</param>
        /// <param name="maxImportId">The maximum import message ID to query. Messages that have been imported will retain their original message ID under this value. (optional)</param>
        /// <param name="startDate">The earliest original received date to query by. Example: 1985-10-26T09:00:00.000-0700 (optional)</param>
        /// <param name="endDate">The latest original received date to query by. Example: 2015-10-21T07:28:00.000-0700 (optional)</param>
        /// <param name="textSearch">Searches all message content for this string. This process could take a long time depending on the amount of message content currently stored. Any message content that was encrypted by this channel will not be searchable. (optional)</param>
        /// <param name="textSearchRegex">If true, text search input will be considered a regular expression pattern to be matched. Only supported by PostgreSQL, MySQL and Oracle databases. (optional)</param>
        /// <param name="status">Determines which message statuses to query by. (optional)</param>
        /// <param name="includedMetaDataId">If present, only connector metadata IDs in this list will be queried. (optional)</param>
        /// <param name="excludedMetaDataId">If present, connector metadata IDs in this list will not be queried. (optional)</param>
        /// <param name="serverId">The server ID associated with messages. (optional)</param>
        /// <param name="rawContentSearch">Searches the raw content of messages. (optional)</param>
        /// <param name="processedRawContentSearch">Searches the processed raw content of messages. (optional)</param>
        /// <param name="transformedContentSearch">Searches the transformed content of messages. (optional)</param>
        /// <param name="encodedContentSearch">Searches the encoded content of messages. (optional)</param>
        /// <param name="sentContentSearch">Searches the sent content of messages. (optional)</param>
        /// <param name="responseContentSearch">Searches the response content of messages. (optional)</param>
        /// <param name="responseTransformedContentSearch">Searches the response transformed content of messages. (optional)</param>
        /// <param name="processedResponseContentSearch">Searches the processed response content of messages. (optional)</param>
        /// <param name="connectorMapContentSearch">Searches the connector map content of messages. (optional)</param>
        /// <param name="channelMapContentSearch">Searches the channel map content of messages. (optional)</param>
        /// <param name="sourceMapContentSearch">Searches the source map content of messages. (optional)</param>
        /// <param name="responseMapContentSearch">Searches the response map content of messages. (optional)</param>
        /// <param name="processingErrorContentSearch">Searches the processing error content of messages. (optional)</param>
        /// <param name="postprocessorErrorContentSearch">Searches the postprocessor error content of messages. (optional)</param>
        /// <param name="responseErrorContentSearch">Searches the response error content of messages. (optional)</param>
        /// <param name="metaDataSearch">Searches a custom metadata column. Value should be in the form: COLUMN_NAME &amp;lt;operator&amp;gt; value, where operator is one of the following: &#x3D;, !&#x3D;, &lt;, &lt;&#x3D;, &gt;, &gt;&#x3D;, CONTAINS, DOES NOT CONTAIN, STARTS WITH, DOES NOT START WITH, ENDS WITH, DOES NOT END WITH (optional)</param>
        /// <param name="metaDataCaseInsensitiveSearch">Searches a custom metadata column, ignoring case. Value should be in the form: COLUMN_NAME &amp;lt;operator&amp;gt; value. (optional)</param>
        /// <param name="textSearchMetaDataColumn">When using a text search, these custom metadata columns will also be searched. (optional)</param>
        /// <param name="minSendAttempts">The minimum number of send attempts for connector messages. (optional)</param>
        /// <param name="maxSendAttempts">The maximum number of send attempts for connector messages. (optional)</param>
        /// <param name="attachment">If true, only messages with attachments are included in the results. (optional)</param>
        /// <param name="error">If true, only messages with errors are included in the results. (optional)</param>
        /// <param name="replace">If true, the message will overwrite the current one (optional, default to false)</param>
        /// <param name="filterDestinations">If true, the metaDataId parameter will be used to determine which destinations to reprocess the message through. (optional, default to false)</param>
        /// <param name="metaDataId">Indicates which destinations to send the message to. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task ReprocessMessages1Async(string channelId, long? minMessageId = default(long?), long? maxMessageId = default(long?), long? minOriginalId = default(long?), long? maxOriginalId = default(long?), long? minImportId = default(long?), long? maxImportId = default(long?), DateTime? startDate = default(DateTime?), DateTime? endDate = default(DateTime?), string textSearch = default(string), bool? textSearchRegex = default(bool?), List<string> status = default(List<string>), List<int> includedMetaDataId = default(List<int>), List<int> excludedMetaDataId = default(List<int>), string serverId = default(string), List<string> rawContentSearch = default(List<string>), List<string> processedRawContentSearch = default(List<string>), List<string> transformedContentSearch = default(List<string>), List<string> encodedContentSearch = default(List<string>), List<string> sentContentSearch = default(List<string>), List<string> responseContentSearch = default(List<string>), List<string> responseTransformedContentSearch = default(List<string>), List<string> processedResponseContentSearch = default(List<string>), List<string> connectorMapContentSearch = default(List<string>), List<string> channelMapContentSearch = default(List<string>), List<string> sourceMapContentSearch = default(List<string>), List<string> responseMapContentSearch = default(List<string>), List<string> processingErrorContentSearch = default(List<string>), List<string> postprocessorErrorContentSearch = default(List<string>), List<string> responseErrorContentSearch = default(List<string>), List<MetaDataSearch> metaDataSearch = default(List<MetaDataSearch>), List<MetaDataSearch> metaDataCaseInsensitiveSearch = default(List<MetaDataSearch>), List<string> textSearchMetaDataColumn = default(List<string>), int? minSendAttempts = default(int?), int? maxSendAttempts = default(int?), bool? attachment = default(bool?), bool? error = default(bool?), bool? replace = default(bool?), bool? filterDestinations = default(bool?), List<int> metaDataId = default(List<int>), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Reprocesses messages through a channel by specific filter criteria.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="minMessageId">The minimum message ID to query. (optional)</param>
        /// <param name="maxMessageId">The maximum message ID to query. (optional)</param>
        /// <param name="minOriginalId">The minimum original message ID to query. Messages that have been reprocessed will retain their original message ID. (optional)</param>
        /// <param name="maxOriginalId">The maximum original message ID to query. Messages that have been reprocessed will retain their original message ID. (optional)</param>
        /// <param name="minImportId">The minimum import message ID to query. Messages that have been imported will retain their original message ID under this value. (optional)</param>
        /// <param name="maxImportId">The maximum import message ID to query. Messages that have been imported will retain their original message ID under this value. (optional)</param>
        /// <param name="startDate">The earliest original received date to query by. Example: 1985-10-26T09:00:00.000-0700 (optional)</param>
        /// <param name="endDate">The latest original received date to query by. Example: 2015-10-21T07:28:00.000-0700 (optional)</param>
        /// <param name="textSearch">Searches all message content for this string. This process could take a long time depending on the amount of message content currently stored. Any message content that was encrypted by this channel will not be searchable. (optional)</param>
        /// <param name="textSearchRegex">If true, text search input will be considered a regular expression pattern to be matched. Only supported by PostgreSQL, MySQL and Oracle databases. (optional)</param>
        /// <param name="status">Determines which message statuses to query by. (optional)</param>
        /// <param name="includedMetaDataId">If present, only connector metadata IDs in this list will be queried. (optional)</param>
        /// <param name="excludedMetaDataId">If present, connector metadata IDs in this list will not be queried. (optional)</param>
        /// <param name="serverId">The server ID associated with messages. (optional)</param>
        /// <param name="rawContentSearch">Searches the raw content of messages. (optional)</param>
        /// <param name="processedRawContentSearch">Searches the processed raw content of messages. (optional)</param>
        /// <param name="transformedContentSearch">Searches the transformed content of messages. (optional)</param>
        /// <param name="encodedContentSearch">Searches the encoded content of messages. (optional)</param>
        /// <param name="sentContentSearch">Searches the sent content of messages. (optional)</param>
        /// <param name="responseContentSearch">Searches the response content of messages. (optional)</param>
        /// <param name="responseTransformedContentSearch">Searches the response transformed content of messages. (optional)</param>
        /// <param name="processedResponseContentSearch">Searches the processed response content of messages. (optional)</param>
        /// <param name="connectorMapContentSearch">Searches the connector map content of messages. (optional)</param>
        /// <param name="channelMapContentSearch">Searches the channel map content of messages. (optional)</param>
        /// <param name="sourceMapContentSearch">Searches the source map content of messages. (optional)</param>
        /// <param name="responseMapContentSearch">Searches the response map content of messages. (optional)</param>
        /// <param name="processingErrorContentSearch">Searches the processing error content of messages. (optional)</param>
        /// <param name="postprocessorErrorContentSearch">Searches the postprocessor error content of messages. (optional)</param>
        /// <param name="responseErrorContentSearch">Searches the response error content of messages. (optional)</param>
        /// <param name="metaDataSearch">Searches a custom metadata column. Value should be in the form: COLUMN_NAME &amp;lt;operator&amp;gt; value, where operator is one of the following: &#x3D;, !&#x3D;, &lt;, &lt;&#x3D;, &gt;, &gt;&#x3D;, CONTAINS, DOES NOT CONTAIN, STARTS WITH, DOES NOT START WITH, ENDS WITH, DOES NOT END WITH (optional)</param>
        /// <param name="metaDataCaseInsensitiveSearch">Searches a custom metadata column, ignoring case. Value should be in the form: COLUMN_NAME &amp;lt;operator&amp;gt; value. (optional)</param>
        /// <param name="textSearchMetaDataColumn">When using a text search, these custom metadata columns will also be searched. (optional)</param>
        /// <param name="minSendAttempts">The minimum number of send attempts for connector messages. (optional)</param>
        /// <param name="maxSendAttempts">The maximum number of send attempts for connector messages. (optional)</param>
        /// <param name="attachment">If true, only messages with attachments are included in the results. (optional)</param>
        /// <param name="error">If true, only messages with errors are included in the results. (optional)</param>
        /// <param name="replace">If true, the message will overwrite the current one (optional, default to false)</param>
        /// <param name="filterDestinations">If true, the metaDataId parameter will be used to determine which destinations to reprocess the message through. (optional, default to false)</param>
        /// <param name="metaDataId">Indicates which destinations to send the message to. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> ReprocessMessages1WithHttpInfoAsync(string channelId, long? minMessageId = default(long?), long? maxMessageId = default(long?), long? minOriginalId = default(long?), long? maxOriginalId = default(long?), long? minImportId = default(long?), long? maxImportId = default(long?), DateTime? startDate = default(DateTime?), DateTime? endDate = default(DateTime?), string textSearch = default(string), bool? textSearchRegex = default(bool?), List<string> status = default(List<string>), List<int> includedMetaDataId = default(List<int>), List<int> excludedMetaDataId = default(List<int>), string serverId = default(string), List<string> rawContentSearch = default(List<string>), List<string> processedRawContentSearch = default(List<string>), List<string> transformedContentSearch = default(List<string>), List<string> encodedContentSearch = default(List<string>), List<string> sentContentSearch = default(List<string>), List<string> responseContentSearch = default(List<string>), List<string> responseTransformedContentSearch = default(List<string>), List<string> processedResponseContentSearch = default(List<string>), List<string> connectorMapContentSearch = default(List<string>), List<string> channelMapContentSearch = default(List<string>), List<string> sourceMapContentSearch = default(List<string>), List<string> responseMapContentSearch = default(List<string>), List<string> processingErrorContentSearch = default(List<string>), List<string> postprocessorErrorContentSearch = default(List<string>), List<string> responseErrorContentSearch = default(List<string>), List<MetaDataSearch> metaDataSearch = default(List<MetaDataSearch>), List<MetaDataSearch> metaDataCaseInsensitiveSearch = default(List<MetaDataSearch>), List<string> textSearchMetaDataColumn = default(List<string>), int? minSendAttempts = default(int?), int? maxSendAttempts = default(int?), bool? attachment = default(bool?), bool? error = default(bool?), bool? replace = default(bool?), bool? filterDestinations = default(bool?), List<int> metaDataId = default(List<int>), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IMessagesApi : IMessagesApiSync, IMessagesApiAsync
    {

    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class MessagesApi : IMessagesApi
    {
        private OpenapiGenerator.MirthConnect311.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="MessagesApi"/> class.
        /// </summary>
        /// <returns></returns>
        public MessagesApi() : this((string)null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MessagesApi"/> class.
        /// </summary>
        /// <returns></returns>
        public MessagesApi(string basePath)
        {
            this.Configuration = OpenapiGenerator.MirthConnect311.Client.Configuration.MergeConfigurations(
                OpenapiGenerator.MirthConnect311.Client.GlobalConfiguration.Instance,
                new OpenapiGenerator.MirthConnect311.Client.Configuration { BasePath = basePath }
            );
            this.Client = new OpenapiGenerator.MirthConnect311.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new OpenapiGenerator.MirthConnect311.Client.ApiClient(this.Configuration.BasePath);
            this.ExceptionFactory = OpenapiGenerator.MirthConnect311.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MessagesApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public MessagesApi(OpenapiGenerator.MirthConnect311.Client.Configuration configuration)
        {
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Configuration = OpenapiGenerator.MirthConnect311.Client.Configuration.MergeConfigurations(
                OpenapiGenerator.MirthConnect311.Client.GlobalConfiguration.Instance,
                configuration
            );
            this.Client = new OpenapiGenerator.MirthConnect311.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new OpenapiGenerator.MirthConnect311.Client.ApiClient(this.Configuration.BasePath);
            ExceptionFactory = OpenapiGenerator.MirthConnect311.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MessagesApi"/> class
        /// using a Configuration object and client instance.
        /// </summary>
        /// <param name="client">The client interface for synchronous API access.</param>
        /// <param name="asyncClient">The client interface for asynchronous API access.</param>
        /// <param name="configuration">The configuration object.</param>
        public MessagesApi(OpenapiGenerator.MirthConnect311.Client.ISynchronousClient client, OpenapiGenerator.MirthConnect311.Client.IAsynchronousClient asyncClient, OpenapiGenerator.MirthConnect311.Client.IReadableConfiguration configuration)
        {
            if (client == null) throw new ArgumentNullException("client");
            if (asyncClient == null) throw new ArgumentNullException("asyncClient");
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Client = client;
            this.AsynchronousClient = asyncClient;
            this.Configuration = configuration;
            this.ExceptionFactory = OpenapiGenerator.MirthConnect311.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// The client for accessing this underlying API asynchronously.
        /// </summary>
        public OpenapiGenerator.MirthConnect311.Client.IAsynchronousClient AsynchronousClient { get; set; }

        /// <summary>
        /// The client for accessing this underlying API synchronously.
        /// </summary>
        public OpenapiGenerator.MirthConnect311.Client.ISynchronousClient Client { get; set; }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public string GetBasePath()
        {
            return this.Configuration.BasePath;
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public OpenapiGenerator.MirthConnect311.Client.IReadableConfiguration Configuration { get; set; }

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public OpenapiGenerator.MirthConnect311.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// Exports a message attachment into a specific file path accessible by the server. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="messageId">The ID of the message.</param>
        /// <param name="attachmentId">The ID of the attachment.</param>
        /// <param name="body">The file path to export the attachment to.</param>
        /// <param name="binary">Indicates that the attachment is binary and should be Base64 decoded before writing to file. (optional, default to false)</param>
        /// <returns></returns>
        public void ExportAttachmentServer(string channelId, long messageId, string attachmentId, string body, bool? binary = default(bool?))
        {
            ExportAttachmentServerWithHttpInfo(channelId, messageId, attachmentId, body, binary);
        }

        /// <summary>
        /// Exports a message attachment into a specific file path accessible by the server. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="messageId">The ID of the message.</param>
        /// <param name="attachmentId">The ID of the attachment.</param>
        /// <param name="body">The file path to export the attachment to.</param>
        /// <param name="binary">Indicates that the attachment is binary and should be Base64 decoded before writing to file. (optional, default to false)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public OpenapiGenerator.MirthConnect311.Client.ApiResponse<Object> ExportAttachmentServerWithHttpInfo(string channelId, long messageId, string attachmentId, string body, bool? binary = default(bool?))
        {
            // verify the required parameter 'channelId' is set
            if (channelId == null)
            {
                throw new OpenapiGenerator.MirthConnect311.Client.ApiException(400, "Missing required parameter 'channelId' when calling MessagesApi->ExportAttachmentServer");
            }

            // verify the required parameter 'attachmentId' is set
            if (attachmentId == null)
            {
                throw new OpenapiGenerator.MirthConnect311.Client.ApiException(400, "Missing required parameter 'attachmentId' when calling MessagesApi->ExportAttachmentServer");
            }

            // verify the required parameter 'body' is set
            if (body == null)
            {
                throw new OpenapiGenerator.MirthConnect311.Client.ApiException(400, "Missing required parameter 'body' when calling MessagesApi->ExportAttachmentServer");
            }

            OpenapiGenerator.MirthConnect311.Client.RequestOptions localVarRequestOptions = new OpenapiGenerator.MirthConnect311.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/xml"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/xml",
                "application/json"
            };

            var localVarContentType = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("channelId", OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToString(channelId)); // path parameter
            localVarRequestOptions.PathParameters.Add("messageId", OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToString(messageId)); // path parameter
            localVarRequestOptions.PathParameters.Add("attachmentId", OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToString(attachmentId)); // path parameter
            if (binary != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "binary", binary));
            }
            localVarRequestOptions.Data = body;

            // authentication (cookieAuth) required
            // cookie parameter support
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("JSESSIONID")))
            {
                localVarRequestOptions.Cookies.Add(new Cookie("JSESSIONID", this.Configuration.GetApiKeyWithPrefix("JSESSIONID")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<Object>("/channels/{channelId}/messages/{messageId}/attachments/{attachmentId}/_export", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ExportAttachmentServer", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Exports a message attachment into a specific file path accessible by the server. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="messageId">The ID of the message.</param>
        /// <param name="attachmentId">The ID of the attachment.</param>
        /// <param name="body">The file path to export the attachment to.</param>
        /// <param name="binary">Indicates that the attachment is binary and should be Base64 decoded before writing to file. (optional, default to false)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task ExportAttachmentServerAsync(string channelId, long messageId, string attachmentId, string body, bool? binary = default(bool?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await ExportAttachmentServerWithHttpInfoAsync(channelId, messageId, attachmentId, body, binary, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Exports a message attachment into a specific file path accessible by the server. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="messageId">The ID of the message.</param>
        /// <param name="attachmentId">The ID of the attachment.</param>
        /// <param name="body">The file path to export the attachment to.</param>
        /// <param name="binary">Indicates that the attachment is binary and should be Base64 decoded before writing to file. (optional, default to false)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<OpenapiGenerator.MirthConnect311.Client.ApiResponse<Object>> ExportAttachmentServerWithHttpInfoAsync(string channelId, long messageId, string attachmentId, string body, bool? binary = default(bool?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'channelId' is set
            if (channelId == null)
            {
                throw new OpenapiGenerator.MirthConnect311.Client.ApiException(400, "Missing required parameter 'channelId' when calling MessagesApi->ExportAttachmentServer");
            }

            // verify the required parameter 'attachmentId' is set
            if (attachmentId == null)
            {
                throw new OpenapiGenerator.MirthConnect311.Client.ApiException(400, "Missing required parameter 'attachmentId' when calling MessagesApi->ExportAttachmentServer");
            }

            // verify the required parameter 'body' is set
            if (body == null)
            {
                throw new OpenapiGenerator.MirthConnect311.Client.ApiException(400, "Missing required parameter 'body' when calling MessagesApi->ExportAttachmentServer");
            }


            OpenapiGenerator.MirthConnect311.Client.RequestOptions localVarRequestOptions = new OpenapiGenerator.MirthConnect311.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/xml"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/xml",
                "application/json"
            };

            var localVarContentType = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("channelId", OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToString(channelId)); // path parameter
            localVarRequestOptions.PathParameters.Add("messageId", OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToString(messageId)); // path parameter
            localVarRequestOptions.PathParameters.Add("attachmentId", OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToString(attachmentId)); // path parameter
            if (binary != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "binary", binary));
            }
            localVarRequestOptions.Data = body;

            // authentication (cookieAuth) required
            // cookie parameter support
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("JSESSIONID")))
            {
                localVarRequestOptions.Cookies.Add(new Cookie("JSESSIONID", this.Configuration.GetApiKeyWithPrefix("JSESSIONID")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<Object>("/channels/{channelId}/messages/{messageId}/attachments/{attachmentId}/_export", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ExportAttachmentServer", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Exports messages into a specific directory path accessible by the server. (\&quot;Try it out\&quot; doesn&#39;t work for this endpoint, but the descriptions are valid. Please use another tool for testing.) 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="filter"></param>
        /// <param name="pageSize">The maximum number of messages that will be queried at a time. (optional)</param>
        /// <param name="writerOptions"> (optional)</param>
        /// <returns>int</returns>
        public int ExportMessagesServer(string channelId, MessageFilter filter, int? pageSize = default(int?), MessageWriterOptions writerOptions = default(MessageWriterOptions))
        {
            OpenapiGenerator.MirthConnect311.Client.ApiResponse<int> localVarResponse = ExportMessagesServerWithHttpInfo(channelId, filter, pageSize, writerOptions);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Exports messages into a specific directory path accessible by the server. (\&quot;Try it out\&quot; doesn&#39;t work for this endpoint, but the descriptions are valid. Please use another tool for testing.) 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="filter"></param>
        /// <param name="pageSize">The maximum number of messages that will be queried at a time. (optional)</param>
        /// <param name="writerOptions"> (optional)</param>
        /// <returns>ApiResponse of int</returns>
        public OpenapiGenerator.MirthConnect311.Client.ApiResponse<int> ExportMessagesServerWithHttpInfo(string channelId, MessageFilter filter, int? pageSize = default(int?), MessageWriterOptions writerOptions = default(MessageWriterOptions))
        {
            // verify the required parameter 'channelId' is set
            if (channelId == null)
            {
                throw new OpenapiGenerator.MirthConnect311.Client.ApiException(400, "Missing required parameter 'channelId' when calling MessagesApi->ExportMessagesServer");
            }

            // verify the required parameter 'filter' is set
            if (filter == null)
            {
                throw new OpenapiGenerator.MirthConnect311.Client.ApiException(400, "Missing required parameter 'filter' when calling MessagesApi->ExportMessagesServer");
            }

            OpenapiGenerator.MirthConnect311.Client.RequestOptions localVarRequestOptions = new OpenapiGenerator.MirthConnect311.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "multipart/form-data"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/xml",
                "application/json"
            };

            var localVarContentType = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("channelId", OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToString(channelId)); // path parameter
            if (pageSize != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "pageSize", pageSize));
            }
            localVarRequestOptions.FormParameters.Add("filter", OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToString(filter)); // form parameter
            if (writerOptions != null)
            {
                localVarRequestOptions.FormParameters.Add("writerOptions", OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToString(writerOptions)); // form parameter
            }

            // authentication (cookieAuth) required
            // cookie parameter support
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("JSESSIONID")))
            {
                localVarRequestOptions.Cookies.Add(new Cookie("JSESSIONID", this.Configuration.GetApiKeyWithPrefix("JSESSIONID")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<int>("/channels/{channelId}/messages/_exportUsingFilter", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ExportMessagesServer", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Exports messages into a specific directory path accessible by the server. (\&quot;Try it out\&quot; doesn&#39;t work for this endpoint, but the descriptions are valid. Please use another tool for testing.) 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="filter"></param>
        /// <param name="pageSize">The maximum number of messages that will be queried at a time. (optional)</param>
        /// <param name="writerOptions"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of int</returns>
        public async System.Threading.Tasks.Task<int> ExportMessagesServerAsync(string channelId, MessageFilter filter, int? pageSize = default(int?), MessageWriterOptions writerOptions = default(MessageWriterOptions), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            OpenapiGenerator.MirthConnect311.Client.ApiResponse<int> localVarResponse = await ExportMessagesServerWithHttpInfoAsync(channelId, filter, pageSize, writerOptions, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Exports messages into a specific directory path accessible by the server. (\&quot;Try it out\&quot; doesn&#39;t work for this endpoint, but the descriptions are valid. Please use another tool for testing.) 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="filter"></param>
        /// <param name="pageSize">The maximum number of messages that will be queried at a time. (optional)</param>
        /// <param name="writerOptions"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (int)</returns>
        public async System.Threading.Tasks.Task<OpenapiGenerator.MirthConnect311.Client.ApiResponse<int>> ExportMessagesServerWithHttpInfoAsync(string channelId, MessageFilter filter, int? pageSize = default(int?), MessageWriterOptions writerOptions = default(MessageWriterOptions), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'channelId' is set
            if (channelId == null)
            {
                throw new OpenapiGenerator.MirthConnect311.Client.ApiException(400, "Missing required parameter 'channelId' when calling MessagesApi->ExportMessagesServer");
            }

            // verify the required parameter 'filter' is set
            if (filter == null)
            {
                throw new OpenapiGenerator.MirthConnect311.Client.ApiException(400, "Missing required parameter 'filter' when calling MessagesApi->ExportMessagesServer");
            }


            OpenapiGenerator.MirthConnect311.Client.RequestOptions localVarRequestOptions = new OpenapiGenerator.MirthConnect311.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "multipart/form-data"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/xml",
                "application/json"
            };

            var localVarContentType = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("channelId", OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToString(channelId)); // path parameter
            if (pageSize != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "pageSize", pageSize));
            }
            localVarRequestOptions.FormParameters.Add("filter", OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToString(filter)); // form parameter
            if (writerOptions != null)
            {
                localVarRequestOptions.FormParameters.Add("writerOptions", OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToString(writerOptions)); // form parameter
            }

            // authentication (cookieAuth) required
            // cookie parameter support
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("JSESSIONID")))
            {
                localVarRequestOptions.Cookies.Add(new Cookie("JSESSIONID", this.Configuration.GetApiKeyWithPrefix("JSESSIONID")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<int>("/channels/{channelId}/messages/_exportUsingFilter", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ExportMessagesServer", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Exports messages into a specific directory path accessible by the server. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="minMessageId">The minimum message ID to query. (optional)</param>
        /// <param name="maxMessageId">The maximum message ID to query. (optional)</param>
        /// <param name="minOriginalId">The minimum original message ID to query. Messages that have been reprocessed will retain their original message ID. (optional)</param>
        /// <param name="maxOriginalId">The maximum original message ID to query. Messages that have been reprocessed will retain their original message ID. (optional)</param>
        /// <param name="minImportId">The minimum import message ID to query. Messages that have been imported will retain their original message ID under this value. (optional)</param>
        /// <param name="maxImportId">The maximum import message ID to query. Messages that have been imported will retain their original message ID under this value. (optional)</param>
        /// <param name="startDate">The earliest original received date to query by. Example: 1985-10-26T09:00:00.000-0700 (optional)</param>
        /// <param name="endDate">The latest original received date to query by. Example: 2015-10-21T07:28:00.000-0700 (optional)</param>
        /// <param name="textSearch">Searches all message content for this string. This process could take a long time depending on the amount of message content currently stored. Any message content that was encrypted by this channel will not be searchable. (optional)</param>
        /// <param name="textSearchRegex">If true, text search input will be considered a regular expression pattern to be matched. Only supported by PostgreSQL, MySQL and Oracle databases. (optional)</param>
        /// <param name="status">Determines which message statuses to query by. (optional)</param>
        /// <param name="includedMetaDataId">If present, only connector metadata IDs in this list will be queried. (optional)</param>
        /// <param name="excludedMetaDataId">If present, connector metadata IDs in this list will not be queried. (optional)</param>
        /// <param name="serverId">The server ID associated with messages. (optional)</param>
        /// <param name="rawContentSearch">Searches the raw content of messages. (optional)</param>
        /// <param name="processedRawContentSearch">Searches the processed raw content of messages. (optional)</param>
        /// <param name="transformedContentSearch">Searches the transformed content of messages. (optional)</param>
        /// <param name="encodedContentSearch">Searches the encoded content of messages. (optional)</param>
        /// <param name="sentContentSearch">Searches the sent content of messages. (optional)</param>
        /// <param name="responseContentSearch">Searches the response content of messages. (optional)</param>
        /// <param name="responseTransformedContentSearch">Searches the response transformed content of messages. (optional)</param>
        /// <param name="processedResponseContentSearch">Searches the processed response content of messages. (optional)</param>
        /// <param name="connectorMapContentSearch">Searches the connector map content of messages. (optional)</param>
        /// <param name="channelMapContentSearch">Searches the channel map content of messages. (optional)</param>
        /// <param name="sourceMapContentSearch">Searches the source map content of messages. (optional)</param>
        /// <param name="responseMapContentSearch">Searches the response map content of messages. (optional)</param>
        /// <param name="processingErrorContentSearch">Searches the processing error content of messages. (optional)</param>
        /// <param name="postprocessorErrorContentSearch">Searches the postprocessor error content of messages. (optional)</param>
        /// <param name="responseErrorContentSearch">Searches the response error content of messages. (optional)</param>
        /// <param name="metaDataSearch">Searches a custom metadata column. Value should be in the form: COLUMN_NAME &amp;lt;operator&amp;gt; value, where operator is one of the following: &#x3D;, !&#x3D;, &lt;, &lt;&#x3D;, &gt;, &gt;&#x3D;, CONTAINS, DOES NOT CONTAIN, STARTS WITH, DOES NOT START WITH, ENDS WITH, DOES NOT END WITH (optional)</param>
        /// <param name="metaDataCaseInsensitiveSearch">Searches a custom metadata column, ignoring case. Value should be in the form: COLUMN_NAME &amp;lt;operator&amp;gt; value. (optional)</param>
        /// <param name="textSearchMetaDataColumn">When using a text search, these custom metadata columns will also be searched. (optional)</param>
        /// <param name="minSendAttempts">The minimum number of send attempts for connector messages. (optional)</param>
        /// <param name="maxSendAttempts">The maximum number of send attempts for connector messages. (optional)</param>
        /// <param name="attachment">If true, only messages with attachments are included in the results. (optional)</param>
        /// <param name="error">If true, only messages with errors are included in the results. (optional)</param>
        /// <param name="pageSize">The maximum number of messages that will be queried at a time. (optional)</param>
        /// <param name="contentType">The ContentType that will be extracted from the message for writing. If null or not provided, the entire message will be written in serialized format. (optional)</param>
        /// <param name="destinationContent">If true, the content to write will be extracted from the destination message(s), rather than the source message. (optional, default to false)</param>
        /// <param name="encrypt">If true, message content will be encrypted before writing. (optional, default to false)</param>
        /// <param name="includeAttachments">Determines whether attachments will be included with messages. (optional, default to false)</param>
        /// <param name="baseFolder">The base directory to use when resolving relative paths in the root folder. (optional)</param>
        /// <param name="rootFolder">The root folder to contain the written messages/sub-folders. (optional)</param>
        /// <param name="filePattern">A string defining the folder/filename(s) for writing messages. It may contain variables to be replaced. (optional)</param>
        /// <param name="archiveFileName">The file name to use for archive exports. (optional)</param>
        /// <param name="archiveFormat">The archiver format to use to archive messages/folders that are written to the root folder. Valid values: zip, tar (optional)</param>
        /// <param name="compressFormat">The compressor format to use to compress the archive file. Only valid when using the TAR archive format. Valid values: gz, bzip2 (optional)</param>
        /// <param name="password">The password used to protect the archive file. Only valid when using the ZIP archive format. (optional)</param>
        /// <param name="encryptionType">The algorithm used to encrypt the password-protected archive file. Only valid when using the ZIP archive format. Valid values: STANDARD, AES128, AES256 (optional)</param>
        /// <returns>int</returns>
        public int ExportMessagesServer1(string channelId, long? minMessageId = default(long?), long? maxMessageId = default(long?), long? minOriginalId = default(long?), long? maxOriginalId = default(long?), long? minImportId = default(long?), long? maxImportId = default(long?), DateTime? startDate = default(DateTime?), DateTime? endDate = default(DateTime?), string textSearch = default(string), bool? textSearchRegex = default(bool?), List<string> status = default(List<string>), List<int> includedMetaDataId = default(List<int>), List<int> excludedMetaDataId = default(List<int>), string serverId = default(string), List<string> rawContentSearch = default(List<string>), List<string> processedRawContentSearch = default(List<string>), List<string> transformedContentSearch = default(List<string>), List<string> encodedContentSearch = default(List<string>), List<string> sentContentSearch = default(List<string>), List<string> responseContentSearch = default(List<string>), List<string> responseTransformedContentSearch = default(List<string>), List<string> processedResponseContentSearch = default(List<string>), List<string> connectorMapContentSearch = default(List<string>), List<string> channelMapContentSearch = default(List<string>), List<string> sourceMapContentSearch = default(List<string>), List<string> responseMapContentSearch = default(List<string>), List<string> processingErrorContentSearch = default(List<string>), List<string> postprocessorErrorContentSearch = default(List<string>), List<string> responseErrorContentSearch = default(List<string>), List<MetaDataSearch> metaDataSearch = default(List<MetaDataSearch>), List<MetaDataSearch> metaDataCaseInsensitiveSearch = default(List<MetaDataSearch>), List<string> textSearchMetaDataColumn = default(List<string>), int? minSendAttempts = default(int?), int? maxSendAttempts = default(int?), bool? attachment = default(bool?), bool? error = default(bool?), int? pageSize = default(int?), string contentType = default(string), bool? destinationContent = default(bool?), bool? encrypt = default(bool?), bool? includeAttachments = default(bool?), string baseFolder = default(string), string rootFolder = default(string), string filePattern = default(string), string archiveFileName = default(string), string archiveFormat = default(string), string compressFormat = default(string), string password = default(string), string encryptionType = default(string))
        {
            OpenapiGenerator.MirthConnect311.Client.ApiResponse<int> localVarResponse = ExportMessagesServer1WithHttpInfo(channelId, minMessageId, maxMessageId, minOriginalId, maxOriginalId, minImportId, maxImportId, startDate, endDate, textSearch, textSearchRegex, status, includedMetaDataId, excludedMetaDataId, serverId, rawContentSearch, processedRawContentSearch, transformedContentSearch, encodedContentSearch, sentContentSearch, responseContentSearch, responseTransformedContentSearch, processedResponseContentSearch, connectorMapContentSearch, channelMapContentSearch, sourceMapContentSearch, responseMapContentSearch, processingErrorContentSearch, postprocessorErrorContentSearch, responseErrorContentSearch, metaDataSearch, metaDataCaseInsensitiveSearch, textSearchMetaDataColumn, minSendAttempts, maxSendAttempts, attachment, error, pageSize, contentType, destinationContent, encrypt, includeAttachments, baseFolder, rootFolder, filePattern, archiveFileName, archiveFormat, compressFormat, password, encryptionType);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Exports messages into a specific directory path accessible by the server. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="minMessageId">The minimum message ID to query. (optional)</param>
        /// <param name="maxMessageId">The maximum message ID to query. (optional)</param>
        /// <param name="minOriginalId">The minimum original message ID to query. Messages that have been reprocessed will retain their original message ID. (optional)</param>
        /// <param name="maxOriginalId">The maximum original message ID to query. Messages that have been reprocessed will retain their original message ID. (optional)</param>
        /// <param name="minImportId">The minimum import message ID to query. Messages that have been imported will retain their original message ID under this value. (optional)</param>
        /// <param name="maxImportId">The maximum import message ID to query. Messages that have been imported will retain their original message ID under this value. (optional)</param>
        /// <param name="startDate">The earliest original received date to query by. Example: 1985-10-26T09:00:00.000-0700 (optional)</param>
        /// <param name="endDate">The latest original received date to query by. Example: 2015-10-21T07:28:00.000-0700 (optional)</param>
        /// <param name="textSearch">Searches all message content for this string. This process could take a long time depending on the amount of message content currently stored. Any message content that was encrypted by this channel will not be searchable. (optional)</param>
        /// <param name="textSearchRegex">If true, text search input will be considered a regular expression pattern to be matched. Only supported by PostgreSQL, MySQL and Oracle databases. (optional)</param>
        /// <param name="status">Determines which message statuses to query by. (optional)</param>
        /// <param name="includedMetaDataId">If present, only connector metadata IDs in this list will be queried. (optional)</param>
        /// <param name="excludedMetaDataId">If present, connector metadata IDs in this list will not be queried. (optional)</param>
        /// <param name="serverId">The server ID associated with messages. (optional)</param>
        /// <param name="rawContentSearch">Searches the raw content of messages. (optional)</param>
        /// <param name="processedRawContentSearch">Searches the processed raw content of messages. (optional)</param>
        /// <param name="transformedContentSearch">Searches the transformed content of messages. (optional)</param>
        /// <param name="encodedContentSearch">Searches the encoded content of messages. (optional)</param>
        /// <param name="sentContentSearch">Searches the sent content of messages. (optional)</param>
        /// <param name="responseContentSearch">Searches the response content of messages. (optional)</param>
        /// <param name="responseTransformedContentSearch">Searches the response transformed content of messages. (optional)</param>
        /// <param name="processedResponseContentSearch">Searches the processed response content of messages. (optional)</param>
        /// <param name="connectorMapContentSearch">Searches the connector map content of messages. (optional)</param>
        /// <param name="channelMapContentSearch">Searches the channel map content of messages. (optional)</param>
        /// <param name="sourceMapContentSearch">Searches the source map content of messages. (optional)</param>
        /// <param name="responseMapContentSearch">Searches the response map content of messages. (optional)</param>
        /// <param name="processingErrorContentSearch">Searches the processing error content of messages. (optional)</param>
        /// <param name="postprocessorErrorContentSearch">Searches the postprocessor error content of messages. (optional)</param>
        /// <param name="responseErrorContentSearch">Searches the response error content of messages. (optional)</param>
        /// <param name="metaDataSearch">Searches a custom metadata column. Value should be in the form: COLUMN_NAME &amp;lt;operator&amp;gt; value, where operator is one of the following: &#x3D;, !&#x3D;, &lt;, &lt;&#x3D;, &gt;, &gt;&#x3D;, CONTAINS, DOES NOT CONTAIN, STARTS WITH, DOES NOT START WITH, ENDS WITH, DOES NOT END WITH (optional)</param>
        /// <param name="metaDataCaseInsensitiveSearch">Searches a custom metadata column, ignoring case. Value should be in the form: COLUMN_NAME &amp;lt;operator&amp;gt; value. (optional)</param>
        /// <param name="textSearchMetaDataColumn">When using a text search, these custom metadata columns will also be searched. (optional)</param>
        /// <param name="minSendAttempts">The minimum number of send attempts for connector messages. (optional)</param>
        /// <param name="maxSendAttempts">The maximum number of send attempts for connector messages. (optional)</param>
        /// <param name="attachment">If true, only messages with attachments are included in the results. (optional)</param>
        /// <param name="error">If true, only messages with errors are included in the results. (optional)</param>
        /// <param name="pageSize">The maximum number of messages that will be queried at a time. (optional)</param>
        /// <param name="contentType">The ContentType that will be extracted from the message for writing. If null or not provided, the entire message will be written in serialized format. (optional)</param>
        /// <param name="destinationContent">If true, the content to write will be extracted from the destination message(s), rather than the source message. (optional, default to false)</param>
        /// <param name="encrypt">If true, message content will be encrypted before writing. (optional, default to false)</param>
        /// <param name="includeAttachments">Determines whether attachments will be included with messages. (optional, default to false)</param>
        /// <param name="baseFolder">The base directory to use when resolving relative paths in the root folder. (optional)</param>
        /// <param name="rootFolder">The root folder to contain the written messages/sub-folders. (optional)</param>
        /// <param name="filePattern">A string defining the folder/filename(s) for writing messages. It may contain variables to be replaced. (optional)</param>
        /// <param name="archiveFileName">The file name to use for archive exports. (optional)</param>
        /// <param name="archiveFormat">The archiver format to use to archive messages/folders that are written to the root folder. Valid values: zip, tar (optional)</param>
        /// <param name="compressFormat">The compressor format to use to compress the archive file. Only valid when using the TAR archive format. Valid values: gz, bzip2 (optional)</param>
        /// <param name="password">The password used to protect the archive file. Only valid when using the ZIP archive format. (optional)</param>
        /// <param name="encryptionType">The algorithm used to encrypt the password-protected archive file. Only valid when using the ZIP archive format. Valid values: STANDARD, AES128, AES256 (optional)</param>
        /// <returns>ApiResponse of int</returns>
        public OpenapiGenerator.MirthConnect311.Client.ApiResponse<int> ExportMessagesServer1WithHttpInfo(string channelId, long? minMessageId = default(long?), long? maxMessageId = default(long?), long? minOriginalId = default(long?), long? maxOriginalId = default(long?), long? minImportId = default(long?), long? maxImportId = default(long?), DateTime? startDate = default(DateTime?), DateTime? endDate = default(DateTime?), string textSearch = default(string), bool? textSearchRegex = default(bool?), List<string> status = default(List<string>), List<int> includedMetaDataId = default(List<int>), List<int> excludedMetaDataId = default(List<int>), string serverId = default(string), List<string> rawContentSearch = default(List<string>), List<string> processedRawContentSearch = default(List<string>), List<string> transformedContentSearch = default(List<string>), List<string> encodedContentSearch = default(List<string>), List<string> sentContentSearch = default(List<string>), List<string> responseContentSearch = default(List<string>), List<string> responseTransformedContentSearch = default(List<string>), List<string> processedResponseContentSearch = default(List<string>), List<string> connectorMapContentSearch = default(List<string>), List<string> channelMapContentSearch = default(List<string>), List<string> sourceMapContentSearch = default(List<string>), List<string> responseMapContentSearch = default(List<string>), List<string> processingErrorContentSearch = default(List<string>), List<string> postprocessorErrorContentSearch = default(List<string>), List<string> responseErrorContentSearch = default(List<string>), List<MetaDataSearch> metaDataSearch = default(List<MetaDataSearch>), List<MetaDataSearch> metaDataCaseInsensitiveSearch = default(List<MetaDataSearch>), List<string> textSearchMetaDataColumn = default(List<string>), int? minSendAttempts = default(int?), int? maxSendAttempts = default(int?), bool? attachment = default(bool?), bool? error = default(bool?), int? pageSize = default(int?), string contentType = default(string), bool? destinationContent = default(bool?), bool? encrypt = default(bool?), bool? includeAttachments = default(bool?), string baseFolder = default(string), string rootFolder = default(string), string filePattern = default(string), string archiveFileName = default(string), string archiveFormat = default(string), string compressFormat = default(string), string password = default(string), string encryptionType = default(string))
        {
            // verify the required parameter 'channelId' is set
            if (channelId == null)
            {
                throw new OpenapiGenerator.MirthConnect311.Client.ApiException(400, "Missing required parameter 'channelId' when calling MessagesApi->ExportMessagesServer1");
            }

            OpenapiGenerator.MirthConnect311.Client.RequestOptions localVarRequestOptions = new OpenapiGenerator.MirthConnect311.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/xml",
                "application/json"
            };

            var localVarContentType = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("channelId", OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToString(channelId)); // path parameter
            if (minMessageId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "minMessageId", minMessageId));
            }
            if (maxMessageId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "maxMessageId", maxMessageId));
            }
            if (minOriginalId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "minOriginalId", minOriginalId));
            }
            if (maxOriginalId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "maxOriginalId", maxOriginalId));
            }
            if (minImportId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "minImportId", minImportId));
            }
            if (maxImportId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "maxImportId", maxImportId));
            }
            if (startDate != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "startDate", startDate));
            }
            if (endDate != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "endDate", endDate));
            }
            if (textSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "textSearch", textSearch));
            }
            if (textSearchRegex != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "textSearchRegex", textSearchRegex));
            }
            if (status != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "status", status));
            }
            if (includedMetaDataId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "includedMetaDataId", includedMetaDataId));
            }
            if (excludedMetaDataId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "excludedMetaDataId", excludedMetaDataId));
            }
            if (serverId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "serverId", serverId));
            }
            if (rawContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "rawContentSearch", rawContentSearch));
            }
            if (processedRawContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "processedRawContentSearch", processedRawContentSearch));
            }
            if (transformedContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "transformedContentSearch", transformedContentSearch));
            }
            if (encodedContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "encodedContentSearch", encodedContentSearch));
            }
            if (sentContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "sentContentSearch", sentContentSearch));
            }
            if (responseContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "responseContentSearch", responseContentSearch));
            }
            if (responseTransformedContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "responseTransformedContentSearch", responseTransformedContentSearch));
            }
            if (processedResponseContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "processedResponseContentSearch", processedResponseContentSearch));
            }
            if (connectorMapContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "connectorMapContentSearch", connectorMapContentSearch));
            }
            if (channelMapContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "channelMapContentSearch", channelMapContentSearch));
            }
            if (sourceMapContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "sourceMapContentSearch", sourceMapContentSearch));
            }
            if (responseMapContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "responseMapContentSearch", responseMapContentSearch));
            }
            if (processingErrorContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "processingErrorContentSearch", processingErrorContentSearch));
            }
            if (postprocessorErrorContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "postprocessorErrorContentSearch", postprocessorErrorContentSearch));
            }
            if (responseErrorContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "responseErrorContentSearch", responseErrorContentSearch));
            }
            if (metaDataSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "metaDataSearch", metaDataSearch));
            }
            if (metaDataCaseInsensitiveSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "metaDataCaseInsensitiveSearch", metaDataCaseInsensitiveSearch));
            }
            if (textSearchMetaDataColumn != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "textSearchMetaDataColumn", textSearchMetaDataColumn));
            }
            if (minSendAttempts != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "minSendAttempts", minSendAttempts));
            }
            if (maxSendAttempts != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "maxSendAttempts", maxSendAttempts));
            }
            if (attachment != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "attachment", attachment));
            }
            if (error != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "error", error));
            }
            if (pageSize != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "pageSize", pageSize));
            }
            if (contentType != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "contentType", contentType));
            }
            if (destinationContent != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "destinationContent", destinationContent));
            }
            if (encrypt != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "encrypt", encrypt));
            }
            if (includeAttachments != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "includeAttachments", includeAttachments));
            }
            if (baseFolder != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "baseFolder", baseFolder));
            }
            if (rootFolder != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "rootFolder", rootFolder));
            }
            if (filePattern != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "filePattern", filePattern));
            }
            if (archiveFileName != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "archiveFileName", archiveFileName));
            }
            if (archiveFormat != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "archiveFormat", archiveFormat));
            }
            if (compressFormat != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "compressFormat", compressFormat));
            }
            if (password != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "password", password));
            }
            if (encryptionType != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "encryptionType", encryptionType));
            }

            // authentication (cookieAuth) required
            // cookie parameter support
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("JSESSIONID")))
            {
                localVarRequestOptions.Cookies.Add(new Cookie("JSESSIONID", this.Configuration.GetApiKeyWithPrefix("JSESSIONID")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<int>("/channels/{channelId}/messages/_export", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ExportMessagesServer1", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Exports messages into a specific directory path accessible by the server. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="minMessageId">The minimum message ID to query. (optional)</param>
        /// <param name="maxMessageId">The maximum message ID to query. (optional)</param>
        /// <param name="minOriginalId">The minimum original message ID to query. Messages that have been reprocessed will retain their original message ID. (optional)</param>
        /// <param name="maxOriginalId">The maximum original message ID to query. Messages that have been reprocessed will retain their original message ID. (optional)</param>
        /// <param name="minImportId">The minimum import message ID to query. Messages that have been imported will retain their original message ID under this value. (optional)</param>
        /// <param name="maxImportId">The maximum import message ID to query. Messages that have been imported will retain their original message ID under this value. (optional)</param>
        /// <param name="startDate">The earliest original received date to query by. Example: 1985-10-26T09:00:00.000-0700 (optional)</param>
        /// <param name="endDate">The latest original received date to query by. Example: 2015-10-21T07:28:00.000-0700 (optional)</param>
        /// <param name="textSearch">Searches all message content for this string. This process could take a long time depending on the amount of message content currently stored. Any message content that was encrypted by this channel will not be searchable. (optional)</param>
        /// <param name="textSearchRegex">If true, text search input will be considered a regular expression pattern to be matched. Only supported by PostgreSQL, MySQL and Oracle databases. (optional)</param>
        /// <param name="status">Determines which message statuses to query by. (optional)</param>
        /// <param name="includedMetaDataId">If present, only connector metadata IDs in this list will be queried. (optional)</param>
        /// <param name="excludedMetaDataId">If present, connector metadata IDs in this list will not be queried. (optional)</param>
        /// <param name="serverId">The server ID associated with messages. (optional)</param>
        /// <param name="rawContentSearch">Searches the raw content of messages. (optional)</param>
        /// <param name="processedRawContentSearch">Searches the processed raw content of messages. (optional)</param>
        /// <param name="transformedContentSearch">Searches the transformed content of messages. (optional)</param>
        /// <param name="encodedContentSearch">Searches the encoded content of messages. (optional)</param>
        /// <param name="sentContentSearch">Searches the sent content of messages. (optional)</param>
        /// <param name="responseContentSearch">Searches the response content of messages. (optional)</param>
        /// <param name="responseTransformedContentSearch">Searches the response transformed content of messages. (optional)</param>
        /// <param name="processedResponseContentSearch">Searches the processed response content of messages. (optional)</param>
        /// <param name="connectorMapContentSearch">Searches the connector map content of messages. (optional)</param>
        /// <param name="channelMapContentSearch">Searches the channel map content of messages. (optional)</param>
        /// <param name="sourceMapContentSearch">Searches the source map content of messages. (optional)</param>
        /// <param name="responseMapContentSearch">Searches the response map content of messages. (optional)</param>
        /// <param name="processingErrorContentSearch">Searches the processing error content of messages. (optional)</param>
        /// <param name="postprocessorErrorContentSearch">Searches the postprocessor error content of messages. (optional)</param>
        /// <param name="responseErrorContentSearch">Searches the response error content of messages. (optional)</param>
        /// <param name="metaDataSearch">Searches a custom metadata column. Value should be in the form: COLUMN_NAME &amp;lt;operator&amp;gt; value, where operator is one of the following: &#x3D;, !&#x3D;, &lt;, &lt;&#x3D;, &gt;, &gt;&#x3D;, CONTAINS, DOES NOT CONTAIN, STARTS WITH, DOES NOT START WITH, ENDS WITH, DOES NOT END WITH (optional)</param>
        /// <param name="metaDataCaseInsensitiveSearch">Searches a custom metadata column, ignoring case. Value should be in the form: COLUMN_NAME &amp;lt;operator&amp;gt; value. (optional)</param>
        /// <param name="textSearchMetaDataColumn">When using a text search, these custom metadata columns will also be searched. (optional)</param>
        /// <param name="minSendAttempts">The minimum number of send attempts for connector messages. (optional)</param>
        /// <param name="maxSendAttempts">The maximum number of send attempts for connector messages. (optional)</param>
        /// <param name="attachment">If true, only messages with attachments are included in the results. (optional)</param>
        /// <param name="error">If true, only messages with errors are included in the results. (optional)</param>
        /// <param name="pageSize">The maximum number of messages that will be queried at a time. (optional)</param>
        /// <param name="contentType">The ContentType that will be extracted from the message for writing. If null or not provided, the entire message will be written in serialized format. (optional)</param>
        /// <param name="destinationContent">If true, the content to write will be extracted from the destination message(s), rather than the source message. (optional, default to false)</param>
        /// <param name="encrypt">If true, message content will be encrypted before writing. (optional, default to false)</param>
        /// <param name="includeAttachments">Determines whether attachments will be included with messages. (optional, default to false)</param>
        /// <param name="baseFolder">The base directory to use when resolving relative paths in the root folder. (optional)</param>
        /// <param name="rootFolder">The root folder to contain the written messages/sub-folders. (optional)</param>
        /// <param name="filePattern">A string defining the folder/filename(s) for writing messages. It may contain variables to be replaced. (optional)</param>
        /// <param name="archiveFileName">The file name to use for archive exports. (optional)</param>
        /// <param name="archiveFormat">The archiver format to use to archive messages/folders that are written to the root folder. Valid values: zip, tar (optional)</param>
        /// <param name="compressFormat">The compressor format to use to compress the archive file. Only valid when using the TAR archive format. Valid values: gz, bzip2 (optional)</param>
        /// <param name="password">The password used to protect the archive file. Only valid when using the ZIP archive format. (optional)</param>
        /// <param name="encryptionType">The algorithm used to encrypt the password-protected archive file. Only valid when using the ZIP archive format. Valid values: STANDARD, AES128, AES256 (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of int</returns>
        public async System.Threading.Tasks.Task<int> ExportMessagesServer1Async(string channelId, long? minMessageId = default(long?), long? maxMessageId = default(long?), long? minOriginalId = default(long?), long? maxOriginalId = default(long?), long? minImportId = default(long?), long? maxImportId = default(long?), DateTime? startDate = default(DateTime?), DateTime? endDate = default(DateTime?), string textSearch = default(string), bool? textSearchRegex = default(bool?), List<string> status = default(List<string>), List<int> includedMetaDataId = default(List<int>), List<int> excludedMetaDataId = default(List<int>), string serverId = default(string), List<string> rawContentSearch = default(List<string>), List<string> processedRawContentSearch = default(List<string>), List<string> transformedContentSearch = default(List<string>), List<string> encodedContentSearch = default(List<string>), List<string> sentContentSearch = default(List<string>), List<string> responseContentSearch = default(List<string>), List<string> responseTransformedContentSearch = default(List<string>), List<string> processedResponseContentSearch = default(List<string>), List<string> connectorMapContentSearch = default(List<string>), List<string> channelMapContentSearch = default(List<string>), List<string> sourceMapContentSearch = default(List<string>), List<string> responseMapContentSearch = default(List<string>), List<string> processingErrorContentSearch = default(List<string>), List<string> postprocessorErrorContentSearch = default(List<string>), List<string> responseErrorContentSearch = default(List<string>), List<MetaDataSearch> metaDataSearch = default(List<MetaDataSearch>), List<MetaDataSearch> metaDataCaseInsensitiveSearch = default(List<MetaDataSearch>), List<string> textSearchMetaDataColumn = default(List<string>), int? minSendAttempts = default(int?), int? maxSendAttempts = default(int?), bool? attachment = default(bool?), bool? error = default(bool?), int? pageSize = default(int?), string contentType = default(string), bool? destinationContent = default(bool?), bool? encrypt = default(bool?), bool? includeAttachments = default(bool?), string baseFolder = default(string), string rootFolder = default(string), string filePattern = default(string), string archiveFileName = default(string), string archiveFormat = default(string), string compressFormat = default(string), string password = default(string), string encryptionType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            OpenapiGenerator.MirthConnect311.Client.ApiResponse<int> localVarResponse = await ExportMessagesServer1WithHttpInfoAsync(channelId, minMessageId, maxMessageId, minOriginalId, maxOriginalId, minImportId, maxImportId, startDate, endDate, textSearch, textSearchRegex, status, includedMetaDataId, excludedMetaDataId, serverId, rawContentSearch, processedRawContentSearch, transformedContentSearch, encodedContentSearch, sentContentSearch, responseContentSearch, responseTransformedContentSearch, processedResponseContentSearch, connectorMapContentSearch, channelMapContentSearch, sourceMapContentSearch, responseMapContentSearch, processingErrorContentSearch, postprocessorErrorContentSearch, responseErrorContentSearch, metaDataSearch, metaDataCaseInsensitiveSearch, textSearchMetaDataColumn, minSendAttempts, maxSendAttempts, attachment, error, pageSize, contentType, destinationContent, encrypt, includeAttachments, baseFolder, rootFolder, filePattern, archiveFileName, archiveFormat, compressFormat, password, encryptionType, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Exports messages into a specific directory path accessible by the server. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="minMessageId">The minimum message ID to query. (optional)</param>
        /// <param name="maxMessageId">The maximum message ID to query. (optional)</param>
        /// <param name="minOriginalId">The minimum original message ID to query. Messages that have been reprocessed will retain their original message ID. (optional)</param>
        /// <param name="maxOriginalId">The maximum original message ID to query. Messages that have been reprocessed will retain their original message ID. (optional)</param>
        /// <param name="minImportId">The minimum import message ID to query. Messages that have been imported will retain their original message ID under this value. (optional)</param>
        /// <param name="maxImportId">The maximum import message ID to query. Messages that have been imported will retain their original message ID under this value. (optional)</param>
        /// <param name="startDate">The earliest original received date to query by. Example: 1985-10-26T09:00:00.000-0700 (optional)</param>
        /// <param name="endDate">The latest original received date to query by. Example: 2015-10-21T07:28:00.000-0700 (optional)</param>
        /// <param name="textSearch">Searches all message content for this string. This process could take a long time depending on the amount of message content currently stored. Any message content that was encrypted by this channel will not be searchable. (optional)</param>
        /// <param name="textSearchRegex">If true, text search input will be considered a regular expression pattern to be matched. Only supported by PostgreSQL, MySQL and Oracle databases. (optional)</param>
        /// <param name="status">Determines which message statuses to query by. (optional)</param>
        /// <param name="includedMetaDataId">If present, only connector metadata IDs in this list will be queried. (optional)</param>
        /// <param name="excludedMetaDataId">If present, connector metadata IDs in this list will not be queried. (optional)</param>
        /// <param name="serverId">The server ID associated with messages. (optional)</param>
        /// <param name="rawContentSearch">Searches the raw content of messages. (optional)</param>
        /// <param name="processedRawContentSearch">Searches the processed raw content of messages. (optional)</param>
        /// <param name="transformedContentSearch">Searches the transformed content of messages. (optional)</param>
        /// <param name="encodedContentSearch">Searches the encoded content of messages. (optional)</param>
        /// <param name="sentContentSearch">Searches the sent content of messages. (optional)</param>
        /// <param name="responseContentSearch">Searches the response content of messages. (optional)</param>
        /// <param name="responseTransformedContentSearch">Searches the response transformed content of messages. (optional)</param>
        /// <param name="processedResponseContentSearch">Searches the processed response content of messages. (optional)</param>
        /// <param name="connectorMapContentSearch">Searches the connector map content of messages. (optional)</param>
        /// <param name="channelMapContentSearch">Searches the channel map content of messages. (optional)</param>
        /// <param name="sourceMapContentSearch">Searches the source map content of messages. (optional)</param>
        /// <param name="responseMapContentSearch">Searches the response map content of messages. (optional)</param>
        /// <param name="processingErrorContentSearch">Searches the processing error content of messages. (optional)</param>
        /// <param name="postprocessorErrorContentSearch">Searches the postprocessor error content of messages. (optional)</param>
        /// <param name="responseErrorContentSearch">Searches the response error content of messages. (optional)</param>
        /// <param name="metaDataSearch">Searches a custom metadata column. Value should be in the form: COLUMN_NAME &amp;lt;operator&amp;gt; value, where operator is one of the following: &#x3D;, !&#x3D;, &lt;, &lt;&#x3D;, &gt;, &gt;&#x3D;, CONTAINS, DOES NOT CONTAIN, STARTS WITH, DOES NOT START WITH, ENDS WITH, DOES NOT END WITH (optional)</param>
        /// <param name="metaDataCaseInsensitiveSearch">Searches a custom metadata column, ignoring case. Value should be in the form: COLUMN_NAME &amp;lt;operator&amp;gt; value. (optional)</param>
        /// <param name="textSearchMetaDataColumn">When using a text search, these custom metadata columns will also be searched. (optional)</param>
        /// <param name="minSendAttempts">The minimum number of send attempts for connector messages. (optional)</param>
        /// <param name="maxSendAttempts">The maximum number of send attempts for connector messages. (optional)</param>
        /// <param name="attachment">If true, only messages with attachments are included in the results. (optional)</param>
        /// <param name="error">If true, only messages with errors are included in the results. (optional)</param>
        /// <param name="pageSize">The maximum number of messages that will be queried at a time. (optional)</param>
        /// <param name="contentType">The ContentType that will be extracted from the message for writing. If null or not provided, the entire message will be written in serialized format. (optional)</param>
        /// <param name="destinationContent">If true, the content to write will be extracted from the destination message(s), rather than the source message. (optional, default to false)</param>
        /// <param name="encrypt">If true, message content will be encrypted before writing. (optional, default to false)</param>
        /// <param name="includeAttachments">Determines whether attachments will be included with messages. (optional, default to false)</param>
        /// <param name="baseFolder">The base directory to use when resolving relative paths in the root folder. (optional)</param>
        /// <param name="rootFolder">The root folder to contain the written messages/sub-folders. (optional)</param>
        /// <param name="filePattern">A string defining the folder/filename(s) for writing messages. It may contain variables to be replaced. (optional)</param>
        /// <param name="archiveFileName">The file name to use for archive exports. (optional)</param>
        /// <param name="archiveFormat">The archiver format to use to archive messages/folders that are written to the root folder. Valid values: zip, tar (optional)</param>
        /// <param name="compressFormat">The compressor format to use to compress the archive file. Only valid when using the TAR archive format. Valid values: gz, bzip2 (optional)</param>
        /// <param name="password">The password used to protect the archive file. Only valid when using the ZIP archive format. (optional)</param>
        /// <param name="encryptionType">The algorithm used to encrypt the password-protected archive file. Only valid when using the ZIP archive format. Valid values: STANDARD, AES128, AES256 (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (int)</returns>
        public async System.Threading.Tasks.Task<OpenapiGenerator.MirthConnect311.Client.ApiResponse<int>> ExportMessagesServer1WithHttpInfoAsync(string channelId, long? minMessageId = default(long?), long? maxMessageId = default(long?), long? minOriginalId = default(long?), long? maxOriginalId = default(long?), long? minImportId = default(long?), long? maxImportId = default(long?), DateTime? startDate = default(DateTime?), DateTime? endDate = default(DateTime?), string textSearch = default(string), bool? textSearchRegex = default(bool?), List<string> status = default(List<string>), List<int> includedMetaDataId = default(List<int>), List<int> excludedMetaDataId = default(List<int>), string serverId = default(string), List<string> rawContentSearch = default(List<string>), List<string> processedRawContentSearch = default(List<string>), List<string> transformedContentSearch = default(List<string>), List<string> encodedContentSearch = default(List<string>), List<string> sentContentSearch = default(List<string>), List<string> responseContentSearch = default(List<string>), List<string> responseTransformedContentSearch = default(List<string>), List<string> processedResponseContentSearch = default(List<string>), List<string> connectorMapContentSearch = default(List<string>), List<string> channelMapContentSearch = default(List<string>), List<string> sourceMapContentSearch = default(List<string>), List<string> responseMapContentSearch = default(List<string>), List<string> processingErrorContentSearch = default(List<string>), List<string> postprocessorErrorContentSearch = default(List<string>), List<string> responseErrorContentSearch = default(List<string>), List<MetaDataSearch> metaDataSearch = default(List<MetaDataSearch>), List<MetaDataSearch> metaDataCaseInsensitiveSearch = default(List<MetaDataSearch>), List<string> textSearchMetaDataColumn = default(List<string>), int? minSendAttempts = default(int?), int? maxSendAttempts = default(int?), bool? attachment = default(bool?), bool? error = default(bool?), int? pageSize = default(int?), string contentType = default(string), bool? destinationContent = default(bool?), bool? encrypt = default(bool?), bool? includeAttachments = default(bool?), string baseFolder = default(string), string rootFolder = default(string), string filePattern = default(string), string archiveFileName = default(string), string archiveFormat = default(string), string compressFormat = default(string), string password = default(string), string encryptionType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'channelId' is set
            if (channelId == null)
            {
                throw new OpenapiGenerator.MirthConnect311.Client.ApiException(400, "Missing required parameter 'channelId' when calling MessagesApi->ExportMessagesServer1");
            }


            OpenapiGenerator.MirthConnect311.Client.RequestOptions localVarRequestOptions = new OpenapiGenerator.MirthConnect311.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/xml",
                "application/json"
            };

            var localVarContentType = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("channelId", OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToString(channelId)); // path parameter
            if (minMessageId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "minMessageId", minMessageId));
            }
            if (maxMessageId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "maxMessageId", maxMessageId));
            }
            if (minOriginalId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "minOriginalId", minOriginalId));
            }
            if (maxOriginalId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "maxOriginalId", maxOriginalId));
            }
            if (minImportId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "minImportId", minImportId));
            }
            if (maxImportId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "maxImportId", maxImportId));
            }
            if (startDate != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "startDate", startDate));
            }
            if (endDate != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "endDate", endDate));
            }
            if (textSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "textSearch", textSearch));
            }
            if (textSearchRegex != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "textSearchRegex", textSearchRegex));
            }
            if (status != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "status", status));
            }
            if (includedMetaDataId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "includedMetaDataId", includedMetaDataId));
            }
            if (excludedMetaDataId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "excludedMetaDataId", excludedMetaDataId));
            }
            if (serverId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "serverId", serverId));
            }
            if (rawContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "rawContentSearch", rawContentSearch));
            }
            if (processedRawContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "processedRawContentSearch", processedRawContentSearch));
            }
            if (transformedContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "transformedContentSearch", transformedContentSearch));
            }
            if (encodedContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "encodedContentSearch", encodedContentSearch));
            }
            if (sentContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "sentContentSearch", sentContentSearch));
            }
            if (responseContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "responseContentSearch", responseContentSearch));
            }
            if (responseTransformedContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "responseTransformedContentSearch", responseTransformedContentSearch));
            }
            if (processedResponseContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "processedResponseContentSearch", processedResponseContentSearch));
            }
            if (connectorMapContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "connectorMapContentSearch", connectorMapContentSearch));
            }
            if (channelMapContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "channelMapContentSearch", channelMapContentSearch));
            }
            if (sourceMapContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "sourceMapContentSearch", sourceMapContentSearch));
            }
            if (responseMapContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "responseMapContentSearch", responseMapContentSearch));
            }
            if (processingErrorContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "processingErrorContentSearch", processingErrorContentSearch));
            }
            if (postprocessorErrorContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "postprocessorErrorContentSearch", postprocessorErrorContentSearch));
            }
            if (responseErrorContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "responseErrorContentSearch", responseErrorContentSearch));
            }
            if (metaDataSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "metaDataSearch", metaDataSearch));
            }
            if (metaDataCaseInsensitiveSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "metaDataCaseInsensitiveSearch", metaDataCaseInsensitiveSearch));
            }
            if (textSearchMetaDataColumn != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "textSearchMetaDataColumn", textSearchMetaDataColumn));
            }
            if (minSendAttempts != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "minSendAttempts", minSendAttempts));
            }
            if (maxSendAttempts != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "maxSendAttempts", maxSendAttempts));
            }
            if (attachment != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "attachment", attachment));
            }
            if (error != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "error", error));
            }
            if (pageSize != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "pageSize", pageSize));
            }
            if (contentType != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "contentType", contentType));
            }
            if (destinationContent != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "destinationContent", destinationContent));
            }
            if (encrypt != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "encrypt", encrypt));
            }
            if (includeAttachments != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "includeAttachments", includeAttachments));
            }
            if (baseFolder != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "baseFolder", baseFolder));
            }
            if (rootFolder != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "rootFolder", rootFolder));
            }
            if (filePattern != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "filePattern", filePattern));
            }
            if (archiveFileName != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "archiveFileName", archiveFileName));
            }
            if (archiveFormat != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "archiveFormat", archiveFormat));
            }
            if (compressFormat != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "compressFormat", compressFormat));
            }
            if (password != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "password", password));
            }
            if (encryptionType != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "encryptionType", encryptionType));
            }

            // authentication (cookieAuth) required
            // cookie parameter support
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("JSESSIONID")))
            {
                localVarRequestOptions.Cookies.Add(new Cookie("JSESSIONID", this.Configuration.GetApiKeyWithPrefix("JSESSIONID")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<int>("/channels/{channelId}/messages/_export", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ExportMessagesServer1", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Retrieve a message attachment by ID. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="messageId">The ID of the message.</param>
        /// <param name="attachmentId">The ID of the attachment.</param>
        /// <returns>Attachment</returns>
        public Attachment GetAttachment(string channelId, long messageId, string attachmentId)
        {
            OpenapiGenerator.MirthConnect311.Client.ApiResponse<Attachment> localVarResponse = GetAttachmentWithHttpInfo(channelId, messageId, attachmentId);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Retrieve a message attachment by ID. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="messageId">The ID of the message.</param>
        /// <param name="attachmentId">The ID of the attachment.</param>
        /// <returns>ApiResponse of Attachment</returns>
        public OpenapiGenerator.MirthConnect311.Client.ApiResponse<Attachment> GetAttachmentWithHttpInfo(string channelId, long messageId, string attachmentId)
        {
            // verify the required parameter 'channelId' is set
            if (channelId == null)
            {
                throw new OpenapiGenerator.MirthConnect311.Client.ApiException(400, "Missing required parameter 'channelId' when calling MessagesApi->GetAttachment");
            }

            // verify the required parameter 'attachmentId' is set
            if (attachmentId == null)
            {
                throw new OpenapiGenerator.MirthConnect311.Client.ApiException(400, "Missing required parameter 'attachmentId' when calling MessagesApi->GetAttachment");
            }

            OpenapiGenerator.MirthConnect311.Client.RequestOptions localVarRequestOptions = new OpenapiGenerator.MirthConnect311.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/xml",
                "application/json"
            };

            var localVarContentType = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("channelId", OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToString(channelId)); // path parameter
            localVarRequestOptions.PathParameters.Add("messageId", OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToString(messageId)); // path parameter
            localVarRequestOptions.PathParameters.Add("attachmentId", OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToString(attachmentId)); // path parameter

            // authentication (cookieAuth) required
            // cookie parameter support
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("JSESSIONID")))
            {
                localVarRequestOptions.Cookies.Add(new Cookie("JSESSIONID", this.Configuration.GetApiKeyWithPrefix("JSESSIONID")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<Attachment>("/channels/{channelId}/messages/{messageId}/attachments/{attachmentId}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetAttachment", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Retrieve a message attachment by ID. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="messageId">The ID of the message.</param>
        /// <param name="attachmentId">The ID of the attachment.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Attachment</returns>
        public async System.Threading.Tasks.Task<Attachment> GetAttachmentAsync(string channelId, long messageId, string attachmentId, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            OpenapiGenerator.MirthConnect311.Client.ApiResponse<Attachment> localVarResponse = await GetAttachmentWithHttpInfoAsync(channelId, messageId, attachmentId, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Retrieve a message attachment by ID. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="messageId">The ID of the message.</param>
        /// <param name="attachmentId">The ID of the attachment.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Attachment)</returns>
        public async System.Threading.Tasks.Task<OpenapiGenerator.MirthConnect311.Client.ApiResponse<Attachment>> GetAttachmentWithHttpInfoAsync(string channelId, long messageId, string attachmentId, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'channelId' is set
            if (channelId == null)
            {
                throw new OpenapiGenerator.MirthConnect311.Client.ApiException(400, "Missing required parameter 'channelId' when calling MessagesApi->GetAttachment");
            }

            // verify the required parameter 'attachmentId' is set
            if (attachmentId == null)
            {
                throw new OpenapiGenerator.MirthConnect311.Client.ApiException(400, "Missing required parameter 'attachmentId' when calling MessagesApi->GetAttachment");
            }


            OpenapiGenerator.MirthConnect311.Client.RequestOptions localVarRequestOptions = new OpenapiGenerator.MirthConnect311.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/xml",
                "application/json"
            };

            var localVarContentType = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("channelId", OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToString(channelId)); // path parameter
            localVarRequestOptions.PathParameters.Add("messageId", OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToString(messageId)); // path parameter
            localVarRequestOptions.PathParameters.Add("attachmentId", OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToString(attachmentId)); // path parameter

            // authentication (cookieAuth) required
            // cookie parameter support
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("JSESSIONID")))
            {
                localVarRequestOptions.Cookies.Add(new Cookie("JSESSIONID", this.Configuration.GetApiKeyWithPrefix("JSESSIONID")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<Attachment>("/channels/{channelId}/messages/{messageId}/attachments/{attachmentId}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetAttachment", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Retrieve a list of attachments by message ID. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="messageId">The ID of the message.</param>
        /// <param name="includeContent">If false, only the attachment ID and type will be returned. (optional, default to true)</param>
        /// <returns>List&lt;Attachment&gt;</returns>
        public List<Attachment> GetAttachmentsByMessageId(string channelId, long messageId, bool? includeContent = default(bool?))
        {
            OpenapiGenerator.MirthConnect311.Client.ApiResponse<List<Attachment>> localVarResponse = GetAttachmentsByMessageIdWithHttpInfo(channelId, messageId, includeContent);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Retrieve a list of attachments by message ID. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="messageId">The ID of the message.</param>
        /// <param name="includeContent">If false, only the attachment ID and type will be returned. (optional, default to true)</param>
        /// <returns>ApiResponse of List&lt;Attachment&gt;</returns>
        public OpenapiGenerator.MirthConnect311.Client.ApiResponse<List<Attachment>> GetAttachmentsByMessageIdWithHttpInfo(string channelId, long messageId, bool? includeContent = default(bool?))
        {
            // verify the required parameter 'channelId' is set
            if (channelId == null)
            {
                throw new OpenapiGenerator.MirthConnect311.Client.ApiException(400, "Missing required parameter 'channelId' when calling MessagesApi->GetAttachmentsByMessageId");
            }

            OpenapiGenerator.MirthConnect311.Client.RequestOptions localVarRequestOptions = new OpenapiGenerator.MirthConnect311.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/xml",
                "application/json"
            };

            var localVarContentType = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("channelId", OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToString(channelId)); // path parameter
            localVarRequestOptions.PathParameters.Add("messageId", OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToString(messageId)); // path parameter
            if (includeContent != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "includeContent", includeContent));
            }

            // authentication (cookieAuth) required
            // cookie parameter support
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("JSESSIONID")))
            {
                localVarRequestOptions.Cookies.Add(new Cookie("JSESSIONID", this.Configuration.GetApiKeyWithPrefix("JSESSIONID")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<List<Attachment>>("/channels/{channelId}/messages/{messageId}/attachments", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetAttachmentsByMessageId", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Retrieve a list of attachments by message ID. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="messageId">The ID of the message.</param>
        /// <param name="includeContent">If false, only the attachment ID and type will be returned. (optional, default to true)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;Attachment&gt;</returns>
        public async System.Threading.Tasks.Task<List<Attachment>> GetAttachmentsByMessageIdAsync(string channelId, long messageId, bool? includeContent = default(bool?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            OpenapiGenerator.MirthConnect311.Client.ApiResponse<List<Attachment>> localVarResponse = await GetAttachmentsByMessageIdWithHttpInfoAsync(channelId, messageId, includeContent, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Retrieve a list of attachments by message ID. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="messageId">The ID of the message.</param>
        /// <param name="includeContent">If false, only the attachment ID and type will be returned. (optional, default to true)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;Attachment&gt;)</returns>
        public async System.Threading.Tasks.Task<OpenapiGenerator.MirthConnect311.Client.ApiResponse<List<Attachment>>> GetAttachmentsByMessageIdWithHttpInfoAsync(string channelId, long messageId, bool? includeContent = default(bool?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'channelId' is set
            if (channelId == null)
            {
                throw new OpenapiGenerator.MirthConnect311.Client.ApiException(400, "Missing required parameter 'channelId' when calling MessagesApi->GetAttachmentsByMessageId");
            }


            OpenapiGenerator.MirthConnect311.Client.RequestOptions localVarRequestOptions = new OpenapiGenerator.MirthConnect311.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/xml",
                "application/json"
            };

            var localVarContentType = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("channelId", OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToString(channelId)); // path parameter
            localVarRequestOptions.PathParameters.Add("messageId", OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToString(messageId)); // path parameter
            if (includeContent != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "includeContent", includeContent));
            }

            // authentication (cookieAuth) required
            // cookie parameter support
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("JSESSIONID")))
            {
                localVarRequestOptions.Cookies.Add(new Cookie("JSESSIONID", this.Configuration.GetApiKeyWithPrefix("JSESSIONID")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<List<Attachment>>("/channels/{channelId}/messages/{messageId}/attachments", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetAttachmentsByMessageId", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Given a ConnectorMessage object, reattaches any DICOM attachment data and returns the raw Base64 encoded message data. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="messageId">The ID of the message.</param>
        /// <param name="connectorMessage">The ConnectorMessage to retrieve DICOM data for.</param>
        /// <returns>string</returns>
        public string GetDICOMMessage(string channelId, long messageId, ConnectorMessage connectorMessage)
        {
            OpenapiGenerator.MirthConnect311.Client.ApiResponse<string> localVarResponse = GetDICOMMessageWithHttpInfo(channelId, messageId, connectorMessage);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Given a ConnectorMessage object, reattaches any DICOM attachment data and returns the raw Base64 encoded message data. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="messageId">The ID of the message.</param>
        /// <param name="connectorMessage">The ConnectorMessage to retrieve DICOM data for.</param>
        /// <returns>ApiResponse of string</returns>
        public OpenapiGenerator.MirthConnect311.Client.ApiResponse<string> GetDICOMMessageWithHttpInfo(string channelId, long messageId, ConnectorMessage connectorMessage)
        {
            // verify the required parameter 'channelId' is set
            if (channelId == null)
            {
                throw new OpenapiGenerator.MirthConnect311.Client.ApiException(400, "Missing required parameter 'channelId' when calling MessagesApi->GetDICOMMessage");
            }

            // verify the required parameter 'connectorMessage' is set
            if (connectorMessage == null)
            {
                throw new OpenapiGenerator.MirthConnect311.Client.ApiException(400, "Missing required parameter 'connectorMessage' when calling MessagesApi->GetDICOMMessage");
            }

            OpenapiGenerator.MirthConnect311.Client.RequestOptions localVarRequestOptions = new OpenapiGenerator.MirthConnect311.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/xml",
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain"
            };

            var localVarContentType = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("channelId", OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToString(channelId)); // path parameter
            localVarRequestOptions.PathParameters.Add("messageId", OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToString(messageId)); // path parameter
            localVarRequestOptions.Data = connectorMessage;

            // authentication (cookieAuth) required
            // cookie parameter support
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("JSESSIONID")))
            {
                localVarRequestOptions.Cookies.Add(new Cookie("JSESSIONID", this.Configuration.GetApiKeyWithPrefix("JSESSIONID")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<string>("/channels/{channelId}/messages/{messageId}/_getDICOMMessage", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetDICOMMessage", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Given a ConnectorMessage object, reattaches any DICOM attachment data and returns the raw Base64 encoded message data. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="messageId">The ID of the message.</param>
        /// <param name="connectorMessage">The ConnectorMessage to retrieve DICOM data for.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> GetDICOMMessageAsync(string channelId, long messageId, ConnectorMessage connectorMessage, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            OpenapiGenerator.MirthConnect311.Client.ApiResponse<string> localVarResponse = await GetDICOMMessageWithHttpInfoAsync(channelId, messageId, connectorMessage, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Given a ConnectorMessage object, reattaches any DICOM attachment data and returns the raw Base64 encoded message data. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="messageId">The ID of the message.</param>
        /// <param name="connectorMessage">The ConnectorMessage to retrieve DICOM data for.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<OpenapiGenerator.MirthConnect311.Client.ApiResponse<string>> GetDICOMMessageWithHttpInfoAsync(string channelId, long messageId, ConnectorMessage connectorMessage, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'channelId' is set
            if (channelId == null)
            {
                throw new OpenapiGenerator.MirthConnect311.Client.ApiException(400, "Missing required parameter 'channelId' when calling MessagesApi->GetDICOMMessage");
            }

            // verify the required parameter 'connectorMessage' is set
            if (connectorMessage == null)
            {
                throw new OpenapiGenerator.MirthConnect311.Client.ApiException(400, "Missing required parameter 'connectorMessage' when calling MessagesApi->GetDICOMMessage");
            }


            OpenapiGenerator.MirthConnect311.Client.RequestOptions localVarRequestOptions = new OpenapiGenerator.MirthConnect311.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/xml", 
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain"
            };

            var localVarContentType = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("channelId", OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToString(channelId)); // path parameter
            localVarRequestOptions.PathParameters.Add("messageId", OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToString(messageId)); // path parameter
            localVarRequestOptions.Data = connectorMessage;

            // authentication (cookieAuth) required
            // cookie parameter support
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("JSESSIONID")))
            {
                localVarRequestOptions.Cookies.Add(new Cookie("JSESSIONID", this.Configuration.GetApiKeyWithPrefix("JSESSIONID")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<string>("/channels/{channelId}/messages/{messageId}/_getDICOMMessage", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetDICOMMessage", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Returns the maximum message ID for the given channel. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <returns>long</returns>
        public long GetMaxMessageId(string channelId)
        {
            OpenapiGenerator.MirthConnect311.Client.ApiResponse<long> localVarResponse = GetMaxMessageIdWithHttpInfo(channelId);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Returns the maximum message ID for the given channel. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <returns>ApiResponse of long</returns>
        public OpenapiGenerator.MirthConnect311.Client.ApiResponse<long> GetMaxMessageIdWithHttpInfo(string channelId)
        {
            // verify the required parameter 'channelId' is set
            if (channelId == null)
            {
                throw new OpenapiGenerator.MirthConnect311.Client.ApiException(400, "Missing required parameter 'channelId' when calling MessagesApi->GetMaxMessageId");
            }

            OpenapiGenerator.MirthConnect311.Client.RequestOptions localVarRequestOptions = new OpenapiGenerator.MirthConnect311.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/xml",
                "application/json"
            };

            var localVarContentType = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("channelId", OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToString(channelId)); // path parameter

            // authentication (cookieAuth) required
            // cookie parameter support
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("JSESSIONID")))
            {
                localVarRequestOptions.Cookies.Add(new Cookie("JSESSIONID", this.Configuration.GetApiKeyWithPrefix("JSESSIONID")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<long>("/channels/{channelId}/messages/maxMessageId", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetMaxMessageId", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Returns the maximum message ID for the given channel. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of long</returns>
        public async System.Threading.Tasks.Task<long> GetMaxMessageIdAsync(string channelId, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            OpenapiGenerator.MirthConnect311.Client.ApiResponse<long> localVarResponse = await GetMaxMessageIdWithHttpInfoAsync(channelId, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Returns the maximum message ID for the given channel. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (long)</returns>
        public async System.Threading.Tasks.Task<OpenapiGenerator.MirthConnect311.Client.ApiResponse<long>> GetMaxMessageIdWithHttpInfoAsync(string channelId, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'channelId' is set
            if (channelId == null)
            {
                throw new OpenapiGenerator.MirthConnect311.Client.ApiException(400, "Missing required parameter 'channelId' when calling MessagesApi->GetMaxMessageId");
            }


            OpenapiGenerator.MirthConnect311.Client.RequestOptions localVarRequestOptions = new OpenapiGenerator.MirthConnect311.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/xml",
                "application/json"
            };

            var localVarContentType = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("channelId", OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToString(channelId)); // path parameter

            // authentication (cookieAuth) required
            // cookie parameter support
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("JSESSIONID")))
            {
                localVarRequestOptions.Cookies.Add(new Cookie("JSESSIONID", this.Configuration.GetApiKeyWithPrefix("JSESSIONID")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<long>("/channels/{channelId}/messages/maxMessageId", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetMaxMessageId", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Retrieve a message by ID. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="messageId">The ID of the message.</param>
        /// <param name="metaDataId">The metadata IDs of the connectors. (optional)</param>
        /// <returns>Message</returns>
        public Message GetMessageContent(string channelId, long messageId, List<int> metaDataId = default(List<int>))
        {
            OpenapiGenerator.MirthConnect311.Client.ApiResponse<Message> localVarResponse = GetMessageContentWithHttpInfo(channelId, messageId, metaDataId);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Retrieve a message by ID. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="messageId">The ID of the message.</param>
        /// <param name="metaDataId">The metadata IDs of the connectors. (optional)</param>
        /// <returns>ApiResponse of Message</returns>
        public OpenapiGenerator.MirthConnect311.Client.ApiResponse<Message> GetMessageContentWithHttpInfo(string channelId, long messageId, List<int> metaDataId = default(List<int>))
        {
            // verify the required parameter 'channelId' is set
            if (channelId == null)
            {
                throw new OpenapiGenerator.MirthConnect311.Client.ApiException(400, "Missing required parameter 'channelId' when calling MessagesApi->GetMessageContent");
            }

            OpenapiGenerator.MirthConnect311.Client.RequestOptions localVarRequestOptions = new OpenapiGenerator.MirthConnect311.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/xml",
                "application/json"
            };

            var localVarContentType = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("channelId", OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToString(channelId)); // path parameter
            localVarRequestOptions.PathParameters.Add("messageId", OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToString(messageId)); // path parameter
            if (metaDataId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "metaDataId", metaDataId));
            }

            // authentication (cookieAuth) required
            // cookie parameter support
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("JSESSIONID")))
            {
                localVarRequestOptions.Cookies.Add(new Cookie("JSESSIONID", this.Configuration.GetApiKeyWithPrefix("JSESSIONID")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<Message>("/channels/{channelId}/messages/{messageId}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetMessageContent", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Retrieve a message by ID. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="messageId">The ID of the message.</param>
        /// <param name="metaDataId">The metadata IDs of the connectors. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Message</returns>
        public async System.Threading.Tasks.Task<Message> GetMessageContentAsync(string channelId, long messageId, List<int> metaDataId = default(List<int>), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            OpenapiGenerator.MirthConnect311.Client.ApiResponse<Message> localVarResponse = await GetMessageContentWithHttpInfoAsync(channelId, messageId, metaDataId, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Retrieve a message by ID. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="messageId">The ID of the message.</param>
        /// <param name="metaDataId">The metadata IDs of the connectors. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Message)</returns>
        public async System.Threading.Tasks.Task<OpenapiGenerator.MirthConnect311.Client.ApiResponse<Message>> GetMessageContentWithHttpInfoAsync(string channelId, long messageId, List<int> metaDataId = default(List<int>), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'channelId' is set
            if (channelId == null)
            {
                throw new OpenapiGenerator.MirthConnect311.Client.ApiException(400, "Missing required parameter 'channelId' when calling MessagesApi->GetMessageContent");
            }


            OpenapiGenerator.MirthConnect311.Client.RequestOptions localVarRequestOptions = new OpenapiGenerator.MirthConnect311.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/xml",
                "application/json"
            };

            var localVarContentType = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("channelId", OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToString(channelId)); // path parameter
            localVarRequestOptions.PathParameters.Add("messageId", OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToString(messageId)); // path parameter
            if (metaDataId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "metaDataId", metaDataId));
            }

            // authentication (cookieAuth) required
            // cookie parameter support
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("JSESSIONID")))
            {
                localVarRequestOptions.Cookies.Add(new Cookie("JSESSIONID", this.Configuration.GetApiKeyWithPrefix("JSESSIONID")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<Message>("/channels/{channelId}/messages/{messageId}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetMessageContent", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Count number for messages by specific filter criteria. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="minMessageId">The minimum message ID to query. (optional)</param>
        /// <param name="maxMessageId">The maximum message ID to query. (optional)</param>
        /// <param name="minOriginalId">The minimum original message ID to query. Messages that have been reprocessed will retain their original message ID. (optional)</param>
        /// <param name="maxOriginalId">The maximum original message ID to query. Messages that have been reprocessed will retain their original message ID. (optional)</param>
        /// <param name="minImportId">The minimum import message ID to query. Messages that have been imported will retain their original message ID under this value. (optional)</param>
        /// <param name="maxImportId">The maximum import message ID to query. Messages that have been imported will retain their original message ID under this value. (optional)</param>
        /// <param name="startDate">The earliest original received date to query by. Example: 1985-10-26T09:00:00.000-0700 (optional)</param>
        /// <param name="endDate">The latest original received date to query by. Example: 2015-10-21T07:28:00.000-0700 (optional)</param>
        /// <param name="textSearch">Searches all message content for this string. This process could take a long time depending on the amount of message content currently stored. Any message content that was encrypted by this channel will not be searchable. (optional)</param>
        /// <param name="textSearchRegex">If true, text search input will be considered a regular expression pattern to be matched. Only supported by PostgreSQL, MySQL and Oracle databases. (optional)</param>
        /// <param name="status">Determines which message statuses to query by. (optional)</param>
        /// <param name="includedMetaDataId">If present, only connector metadata IDs in this list will be queried. (optional)</param>
        /// <param name="excludedMetaDataId">If present, connector metadata IDs in this list will not be queried. (optional)</param>
        /// <param name="serverId">The server ID associated with messages. (optional)</param>
        /// <param name="rawContentSearch">Searches the raw content of messages. (optional)</param>
        /// <param name="processedRawContentSearch">Searches the processed raw content of messages. (optional)</param>
        /// <param name="transformedContentSearch">Searches the transformed content of messages. (optional)</param>
        /// <param name="encodedContentSearch">Searches the encoded content of messages. (optional)</param>
        /// <param name="sentContentSearch">Searches the sent content of messages. (optional)</param>
        /// <param name="responseContentSearch">Searches the response content of messages. (optional)</param>
        /// <param name="responseTransformedContentSearch">Searches the response transformed content of messages. (optional)</param>
        /// <param name="processedResponseContentSearch">Searches the processed response content of messages. (optional)</param>
        /// <param name="connectorMapContentSearch">Searches the connector map content of messages. (optional)</param>
        /// <param name="channelMapContentSearch">Searches the channel map content of messages. (optional)</param>
        /// <param name="sourceMapContentSearch">Searches the source map content of messages. (optional)</param>
        /// <param name="responseMapContentSearch">Searches the response map content of messages. (optional)</param>
        /// <param name="processingErrorContentSearch">Searches the processing error content of messages. (optional)</param>
        /// <param name="postprocessorErrorContentSearch">Searches the postprocessor error content of messages. (optional)</param>
        /// <param name="responseErrorContentSearch">Searches the response error content of messages. (optional)</param>
        /// <param name="metaDataSearch">Searches a custom metadata column. Value should be in the form: COLUMN_NAME &amp;lt;operator&amp;gt; value, where operator is one of the following: &#x3D;, !&#x3D;, &lt;, &lt;&#x3D;, &gt;, &gt;&#x3D;, CONTAINS, DOES NOT CONTAIN, STARTS WITH, DOES NOT START WITH, ENDS WITH, DOES NOT END WITH (optional)</param>
        /// <param name="metaDataCaseInsensitiveSearch">Searches a custom metadata column, ignoring case. Value should be in the form: COLUMN_NAME &amp;lt;operator&amp;gt; value. (optional)</param>
        /// <param name="textSearchMetaDataColumn">When using a text search, these custom metadata columns will also be searched. (optional)</param>
        /// <param name="minSendAttempts">The minimum number of send attempts for connector messages. (optional)</param>
        /// <param name="maxSendAttempts">The maximum number of send attempts for connector messages. (optional)</param>
        /// <param name="attachment">If true, only messages with attachments are included in the results. (optional)</param>
        /// <param name="error">If true, only messages with errors are included in the results. (optional)</param>
        /// <returns>long</returns>
        public long GetMessageCount(string channelId, long? minMessageId = default(long?), long? maxMessageId = default(long?), long? minOriginalId = default(long?), long? maxOriginalId = default(long?), long? minImportId = default(long?), long? maxImportId = default(long?), DateTime? startDate = default(DateTime?), DateTime? endDate = default(DateTime?), string textSearch = default(string), bool? textSearchRegex = default(bool?), List<string> status = default(List<string>), List<int> includedMetaDataId = default(List<int>), List<int> excludedMetaDataId = default(List<int>), string serverId = default(string), List<string> rawContentSearch = default(List<string>), List<string> processedRawContentSearch = default(List<string>), List<string> transformedContentSearch = default(List<string>), List<string> encodedContentSearch = default(List<string>), List<string> sentContentSearch = default(List<string>), List<string> responseContentSearch = default(List<string>), List<string> responseTransformedContentSearch = default(List<string>), List<string> processedResponseContentSearch = default(List<string>), List<string> connectorMapContentSearch = default(List<string>), List<string> channelMapContentSearch = default(List<string>), List<string> sourceMapContentSearch = default(List<string>), List<string> responseMapContentSearch = default(List<string>), List<string> processingErrorContentSearch = default(List<string>), List<string> postprocessorErrorContentSearch = default(List<string>), List<string> responseErrorContentSearch = default(List<string>), List<MetaDataSearch> metaDataSearch = default(List<MetaDataSearch>), List<MetaDataSearch> metaDataCaseInsensitiveSearch = default(List<MetaDataSearch>), List<string> textSearchMetaDataColumn = default(List<string>), int? minSendAttempts = default(int?), int? maxSendAttempts = default(int?), bool? attachment = default(bool?), bool? error = default(bool?))
        {
            OpenapiGenerator.MirthConnect311.Client.ApiResponse<long> localVarResponse = GetMessageCountWithHttpInfo(channelId, minMessageId, maxMessageId, minOriginalId, maxOriginalId, minImportId, maxImportId, startDate, endDate, textSearch, textSearchRegex, status, includedMetaDataId, excludedMetaDataId, serverId, rawContentSearch, processedRawContentSearch, transformedContentSearch, encodedContentSearch, sentContentSearch, responseContentSearch, responseTransformedContentSearch, processedResponseContentSearch, connectorMapContentSearch, channelMapContentSearch, sourceMapContentSearch, responseMapContentSearch, processingErrorContentSearch, postprocessorErrorContentSearch, responseErrorContentSearch, metaDataSearch, metaDataCaseInsensitiveSearch, textSearchMetaDataColumn, minSendAttempts, maxSendAttempts, attachment, error);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Count number for messages by specific filter criteria. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="minMessageId">The minimum message ID to query. (optional)</param>
        /// <param name="maxMessageId">The maximum message ID to query. (optional)</param>
        /// <param name="minOriginalId">The minimum original message ID to query. Messages that have been reprocessed will retain their original message ID. (optional)</param>
        /// <param name="maxOriginalId">The maximum original message ID to query. Messages that have been reprocessed will retain their original message ID. (optional)</param>
        /// <param name="minImportId">The minimum import message ID to query. Messages that have been imported will retain their original message ID under this value. (optional)</param>
        /// <param name="maxImportId">The maximum import message ID to query. Messages that have been imported will retain their original message ID under this value. (optional)</param>
        /// <param name="startDate">The earliest original received date to query by. Example: 1985-10-26T09:00:00.000-0700 (optional)</param>
        /// <param name="endDate">The latest original received date to query by. Example: 2015-10-21T07:28:00.000-0700 (optional)</param>
        /// <param name="textSearch">Searches all message content for this string. This process could take a long time depending on the amount of message content currently stored. Any message content that was encrypted by this channel will not be searchable. (optional)</param>
        /// <param name="textSearchRegex">If true, text search input will be considered a regular expression pattern to be matched. Only supported by PostgreSQL, MySQL and Oracle databases. (optional)</param>
        /// <param name="status">Determines which message statuses to query by. (optional)</param>
        /// <param name="includedMetaDataId">If present, only connector metadata IDs in this list will be queried. (optional)</param>
        /// <param name="excludedMetaDataId">If present, connector metadata IDs in this list will not be queried. (optional)</param>
        /// <param name="serverId">The server ID associated with messages. (optional)</param>
        /// <param name="rawContentSearch">Searches the raw content of messages. (optional)</param>
        /// <param name="processedRawContentSearch">Searches the processed raw content of messages. (optional)</param>
        /// <param name="transformedContentSearch">Searches the transformed content of messages. (optional)</param>
        /// <param name="encodedContentSearch">Searches the encoded content of messages. (optional)</param>
        /// <param name="sentContentSearch">Searches the sent content of messages. (optional)</param>
        /// <param name="responseContentSearch">Searches the response content of messages. (optional)</param>
        /// <param name="responseTransformedContentSearch">Searches the response transformed content of messages. (optional)</param>
        /// <param name="processedResponseContentSearch">Searches the processed response content of messages. (optional)</param>
        /// <param name="connectorMapContentSearch">Searches the connector map content of messages. (optional)</param>
        /// <param name="channelMapContentSearch">Searches the channel map content of messages. (optional)</param>
        /// <param name="sourceMapContentSearch">Searches the source map content of messages. (optional)</param>
        /// <param name="responseMapContentSearch">Searches the response map content of messages. (optional)</param>
        /// <param name="processingErrorContentSearch">Searches the processing error content of messages. (optional)</param>
        /// <param name="postprocessorErrorContentSearch">Searches the postprocessor error content of messages. (optional)</param>
        /// <param name="responseErrorContentSearch">Searches the response error content of messages. (optional)</param>
        /// <param name="metaDataSearch">Searches a custom metadata column. Value should be in the form: COLUMN_NAME &amp;lt;operator&amp;gt; value, where operator is one of the following: &#x3D;, !&#x3D;, &lt;, &lt;&#x3D;, &gt;, &gt;&#x3D;, CONTAINS, DOES NOT CONTAIN, STARTS WITH, DOES NOT START WITH, ENDS WITH, DOES NOT END WITH (optional)</param>
        /// <param name="metaDataCaseInsensitiveSearch">Searches a custom metadata column, ignoring case. Value should be in the form: COLUMN_NAME &amp;lt;operator&amp;gt; value. (optional)</param>
        /// <param name="textSearchMetaDataColumn">When using a text search, these custom metadata columns will also be searched. (optional)</param>
        /// <param name="minSendAttempts">The minimum number of send attempts for connector messages. (optional)</param>
        /// <param name="maxSendAttempts">The maximum number of send attempts for connector messages. (optional)</param>
        /// <param name="attachment">If true, only messages with attachments are included in the results. (optional)</param>
        /// <param name="error">If true, only messages with errors are included in the results. (optional)</param>
        /// <returns>ApiResponse of long</returns>
        public OpenapiGenerator.MirthConnect311.Client.ApiResponse<long> GetMessageCountWithHttpInfo(string channelId, long? minMessageId = default(long?), long? maxMessageId = default(long?), long? minOriginalId = default(long?), long? maxOriginalId = default(long?), long? minImportId = default(long?), long? maxImportId = default(long?), DateTime? startDate = default(DateTime?), DateTime? endDate = default(DateTime?), string textSearch = default(string), bool? textSearchRegex = default(bool?), List<string> status = default(List<string>), List<int> includedMetaDataId = default(List<int>), List<int> excludedMetaDataId = default(List<int>), string serverId = default(string), List<string> rawContentSearch = default(List<string>), List<string> processedRawContentSearch = default(List<string>), List<string> transformedContentSearch = default(List<string>), List<string> encodedContentSearch = default(List<string>), List<string> sentContentSearch = default(List<string>), List<string> responseContentSearch = default(List<string>), List<string> responseTransformedContentSearch = default(List<string>), List<string> processedResponseContentSearch = default(List<string>), List<string> connectorMapContentSearch = default(List<string>), List<string> channelMapContentSearch = default(List<string>), List<string> sourceMapContentSearch = default(List<string>), List<string> responseMapContentSearch = default(List<string>), List<string> processingErrorContentSearch = default(List<string>), List<string> postprocessorErrorContentSearch = default(List<string>), List<string> responseErrorContentSearch = default(List<string>), List<MetaDataSearch> metaDataSearch = default(List<MetaDataSearch>), List<MetaDataSearch> metaDataCaseInsensitiveSearch = default(List<MetaDataSearch>), List<string> textSearchMetaDataColumn = default(List<string>), int? minSendAttempts = default(int?), int? maxSendAttempts = default(int?), bool? attachment = default(bool?), bool? error = default(bool?))
        {
            // verify the required parameter 'channelId' is set
            if (channelId == null)
            {
                throw new OpenapiGenerator.MirthConnect311.Client.ApiException(400, "Missing required parameter 'channelId' when calling MessagesApi->GetMessageCount");
            }

            OpenapiGenerator.MirthConnect311.Client.RequestOptions localVarRequestOptions = new OpenapiGenerator.MirthConnect311.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/xml",
                "application/json"
            };

            var localVarContentType = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("channelId", OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToString(channelId)); // path parameter
            if (minMessageId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "minMessageId", minMessageId));
            }
            if (maxMessageId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "maxMessageId", maxMessageId));
            }
            if (minOriginalId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "minOriginalId", minOriginalId));
            }
            if (maxOriginalId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "maxOriginalId", maxOriginalId));
            }
            if (minImportId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "minImportId", minImportId));
            }
            if (maxImportId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "maxImportId", maxImportId));
            }
            if (startDate != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "startDate", startDate));
            }
            if (endDate != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "endDate", endDate));
            }
            if (textSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "textSearch", textSearch));
            }
            if (textSearchRegex != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "textSearchRegex", textSearchRegex));
            }
            if (status != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "status", status));
            }
            if (includedMetaDataId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "includedMetaDataId", includedMetaDataId));
            }
            if (excludedMetaDataId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "excludedMetaDataId", excludedMetaDataId));
            }
            if (serverId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "serverId", serverId));
            }
            if (rawContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "rawContentSearch", rawContentSearch));
            }
            if (processedRawContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "processedRawContentSearch", processedRawContentSearch));
            }
            if (transformedContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "transformedContentSearch", transformedContentSearch));
            }
            if (encodedContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "encodedContentSearch", encodedContentSearch));
            }
            if (sentContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "sentContentSearch", sentContentSearch));
            }
            if (responseContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "responseContentSearch", responseContentSearch));
            }
            if (responseTransformedContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "responseTransformedContentSearch", responseTransformedContentSearch));
            }
            if (processedResponseContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "processedResponseContentSearch", processedResponseContentSearch));
            }
            if (connectorMapContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "connectorMapContentSearch", connectorMapContentSearch));
            }
            if (channelMapContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "channelMapContentSearch", channelMapContentSearch));
            }
            if (sourceMapContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "sourceMapContentSearch", sourceMapContentSearch));
            }
            if (responseMapContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "responseMapContentSearch", responseMapContentSearch));
            }
            if (processingErrorContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "processingErrorContentSearch", processingErrorContentSearch));
            }
            if (postprocessorErrorContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "postprocessorErrorContentSearch", postprocessorErrorContentSearch));
            }
            if (responseErrorContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "responseErrorContentSearch", responseErrorContentSearch));
            }
            if (metaDataSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "metaDataSearch", metaDataSearch));
            }
            if (metaDataCaseInsensitiveSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "metaDataCaseInsensitiveSearch", metaDataCaseInsensitiveSearch));
            }
            if (textSearchMetaDataColumn != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "textSearchMetaDataColumn", textSearchMetaDataColumn));
            }
            if (minSendAttempts != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "minSendAttempts", minSendAttempts));
            }
            if (maxSendAttempts != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "maxSendAttempts", maxSendAttempts));
            }
            if (attachment != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "attachment", attachment));
            }
            if (error != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "error", error));
            }

            // authentication (cookieAuth) required
            // cookie parameter support
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("JSESSIONID")))
            {
                localVarRequestOptions.Cookies.Add(new Cookie("JSESSIONID", this.Configuration.GetApiKeyWithPrefix("JSESSIONID")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<long>("/channels/{channelId}/messages/count", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetMessageCount", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Count number for messages by specific filter criteria. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="minMessageId">The minimum message ID to query. (optional)</param>
        /// <param name="maxMessageId">The maximum message ID to query. (optional)</param>
        /// <param name="minOriginalId">The minimum original message ID to query. Messages that have been reprocessed will retain their original message ID. (optional)</param>
        /// <param name="maxOriginalId">The maximum original message ID to query. Messages that have been reprocessed will retain their original message ID. (optional)</param>
        /// <param name="minImportId">The minimum import message ID to query. Messages that have been imported will retain their original message ID under this value. (optional)</param>
        /// <param name="maxImportId">The maximum import message ID to query. Messages that have been imported will retain their original message ID under this value. (optional)</param>
        /// <param name="startDate">The earliest original received date to query by. Example: 1985-10-26T09:00:00.000-0700 (optional)</param>
        /// <param name="endDate">The latest original received date to query by. Example: 2015-10-21T07:28:00.000-0700 (optional)</param>
        /// <param name="textSearch">Searches all message content for this string. This process could take a long time depending on the amount of message content currently stored. Any message content that was encrypted by this channel will not be searchable. (optional)</param>
        /// <param name="textSearchRegex">If true, text search input will be considered a regular expression pattern to be matched. Only supported by PostgreSQL, MySQL and Oracle databases. (optional)</param>
        /// <param name="status">Determines which message statuses to query by. (optional)</param>
        /// <param name="includedMetaDataId">If present, only connector metadata IDs in this list will be queried. (optional)</param>
        /// <param name="excludedMetaDataId">If present, connector metadata IDs in this list will not be queried. (optional)</param>
        /// <param name="serverId">The server ID associated with messages. (optional)</param>
        /// <param name="rawContentSearch">Searches the raw content of messages. (optional)</param>
        /// <param name="processedRawContentSearch">Searches the processed raw content of messages. (optional)</param>
        /// <param name="transformedContentSearch">Searches the transformed content of messages. (optional)</param>
        /// <param name="encodedContentSearch">Searches the encoded content of messages. (optional)</param>
        /// <param name="sentContentSearch">Searches the sent content of messages. (optional)</param>
        /// <param name="responseContentSearch">Searches the response content of messages. (optional)</param>
        /// <param name="responseTransformedContentSearch">Searches the response transformed content of messages. (optional)</param>
        /// <param name="processedResponseContentSearch">Searches the processed response content of messages. (optional)</param>
        /// <param name="connectorMapContentSearch">Searches the connector map content of messages. (optional)</param>
        /// <param name="channelMapContentSearch">Searches the channel map content of messages. (optional)</param>
        /// <param name="sourceMapContentSearch">Searches the source map content of messages. (optional)</param>
        /// <param name="responseMapContentSearch">Searches the response map content of messages. (optional)</param>
        /// <param name="processingErrorContentSearch">Searches the processing error content of messages. (optional)</param>
        /// <param name="postprocessorErrorContentSearch">Searches the postprocessor error content of messages. (optional)</param>
        /// <param name="responseErrorContentSearch">Searches the response error content of messages. (optional)</param>
        /// <param name="metaDataSearch">Searches a custom metadata column. Value should be in the form: COLUMN_NAME &amp;lt;operator&amp;gt; value, where operator is one of the following: &#x3D;, !&#x3D;, &lt;, &lt;&#x3D;, &gt;, &gt;&#x3D;, CONTAINS, DOES NOT CONTAIN, STARTS WITH, DOES NOT START WITH, ENDS WITH, DOES NOT END WITH (optional)</param>
        /// <param name="metaDataCaseInsensitiveSearch">Searches a custom metadata column, ignoring case. Value should be in the form: COLUMN_NAME &amp;lt;operator&amp;gt; value. (optional)</param>
        /// <param name="textSearchMetaDataColumn">When using a text search, these custom metadata columns will also be searched. (optional)</param>
        /// <param name="minSendAttempts">The minimum number of send attempts for connector messages. (optional)</param>
        /// <param name="maxSendAttempts">The maximum number of send attempts for connector messages. (optional)</param>
        /// <param name="attachment">If true, only messages with attachments are included in the results. (optional)</param>
        /// <param name="error">If true, only messages with errors are included in the results. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of long</returns>
        public async System.Threading.Tasks.Task<long> GetMessageCountAsync(string channelId, long? minMessageId = default(long?), long? maxMessageId = default(long?), long? minOriginalId = default(long?), long? maxOriginalId = default(long?), long? minImportId = default(long?), long? maxImportId = default(long?), DateTime? startDate = default(DateTime?), DateTime? endDate = default(DateTime?), string textSearch = default(string), bool? textSearchRegex = default(bool?), List<string> status = default(List<string>), List<int> includedMetaDataId = default(List<int>), List<int> excludedMetaDataId = default(List<int>), string serverId = default(string), List<string> rawContentSearch = default(List<string>), List<string> processedRawContentSearch = default(List<string>), List<string> transformedContentSearch = default(List<string>), List<string> encodedContentSearch = default(List<string>), List<string> sentContentSearch = default(List<string>), List<string> responseContentSearch = default(List<string>), List<string> responseTransformedContentSearch = default(List<string>), List<string> processedResponseContentSearch = default(List<string>), List<string> connectorMapContentSearch = default(List<string>), List<string> channelMapContentSearch = default(List<string>), List<string> sourceMapContentSearch = default(List<string>), List<string> responseMapContentSearch = default(List<string>), List<string> processingErrorContentSearch = default(List<string>), List<string> postprocessorErrorContentSearch = default(List<string>), List<string> responseErrorContentSearch = default(List<string>), List<MetaDataSearch> metaDataSearch = default(List<MetaDataSearch>), List<MetaDataSearch> metaDataCaseInsensitiveSearch = default(List<MetaDataSearch>), List<string> textSearchMetaDataColumn = default(List<string>), int? minSendAttempts = default(int?), int? maxSendAttempts = default(int?), bool? attachment = default(bool?), bool? error = default(bool?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            OpenapiGenerator.MirthConnect311.Client.ApiResponse<long> localVarResponse = await GetMessageCountWithHttpInfoAsync(channelId, minMessageId, maxMessageId, minOriginalId, maxOriginalId, minImportId, maxImportId, startDate, endDate, textSearch, textSearchRegex, status, includedMetaDataId, excludedMetaDataId, serverId, rawContentSearch, processedRawContentSearch, transformedContentSearch, encodedContentSearch, sentContentSearch, responseContentSearch, responseTransformedContentSearch, processedResponseContentSearch, connectorMapContentSearch, channelMapContentSearch, sourceMapContentSearch, responseMapContentSearch, processingErrorContentSearch, postprocessorErrorContentSearch, responseErrorContentSearch, metaDataSearch, metaDataCaseInsensitiveSearch, textSearchMetaDataColumn, minSendAttempts, maxSendAttempts, attachment, error, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Count number for messages by specific filter criteria. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="minMessageId">The minimum message ID to query. (optional)</param>
        /// <param name="maxMessageId">The maximum message ID to query. (optional)</param>
        /// <param name="minOriginalId">The minimum original message ID to query. Messages that have been reprocessed will retain their original message ID. (optional)</param>
        /// <param name="maxOriginalId">The maximum original message ID to query. Messages that have been reprocessed will retain their original message ID. (optional)</param>
        /// <param name="minImportId">The minimum import message ID to query. Messages that have been imported will retain their original message ID under this value. (optional)</param>
        /// <param name="maxImportId">The maximum import message ID to query. Messages that have been imported will retain their original message ID under this value. (optional)</param>
        /// <param name="startDate">The earliest original received date to query by. Example: 1985-10-26T09:00:00.000-0700 (optional)</param>
        /// <param name="endDate">The latest original received date to query by. Example: 2015-10-21T07:28:00.000-0700 (optional)</param>
        /// <param name="textSearch">Searches all message content for this string. This process could take a long time depending on the amount of message content currently stored. Any message content that was encrypted by this channel will not be searchable. (optional)</param>
        /// <param name="textSearchRegex">If true, text search input will be considered a regular expression pattern to be matched. Only supported by PostgreSQL, MySQL and Oracle databases. (optional)</param>
        /// <param name="status">Determines which message statuses to query by. (optional)</param>
        /// <param name="includedMetaDataId">If present, only connector metadata IDs in this list will be queried. (optional)</param>
        /// <param name="excludedMetaDataId">If present, connector metadata IDs in this list will not be queried. (optional)</param>
        /// <param name="serverId">The server ID associated with messages. (optional)</param>
        /// <param name="rawContentSearch">Searches the raw content of messages. (optional)</param>
        /// <param name="processedRawContentSearch">Searches the processed raw content of messages. (optional)</param>
        /// <param name="transformedContentSearch">Searches the transformed content of messages. (optional)</param>
        /// <param name="encodedContentSearch">Searches the encoded content of messages. (optional)</param>
        /// <param name="sentContentSearch">Searches the sent content of messages. (optional)</param>
        /// <param name="responseContentSearch">Searches the response content of messages. (optional)</param>
        /// <param name="responseTransformedContentSearch">Searches the response transformed content of messages. (optional)</param>
        /// <param name="processedResponseContentSearch">Searches the processed response content of messages. (optional)</param>
        /// <param name="connectorMapContentSearch">Searches the connector map content of messages. (optional)</param>
        /// <param name="channelMapContentSearch">Searches the channel map content of messages. (optional)</param>
        /// <param name="sourceMapContentSearch">Searches the source map content of messages. (optional)</param>
        /// <param name="responseMapContentSearch">Searches the response map content of messages. (optional)</param>
        /// <param name="processingErrorContentSearch">Searches the processing error content of messages. (optional)</param>
        /// <param name="postprocessorErrorContentSearch">Searches the postprocessor error content of messages. (optional)</param>
        /// <param name="responseErrorContentSearch">Searches the response error content of messages. (optional)</param>
        /// <param name="metaDataSearch">Searches a custom metadata column. Value should be in the form: COLUMN_NAME &amp;lt;operator&amp;gt; value, where operator is one of the following: &#x3D;, !&#x3D;, &lt;, &lt;&#x3D;, &gt;, &gt;&#x3D;, CONTAINS, DOES NOT CONTAIN, STARTS WITH, DOES NOT START WITH, ENDS WITH, DOES NOT END WITH (optional)</param>
        /// <param name="metaDataCaseInsensitiveSearch">Searches a custom metadata column, ignoring case. Value should be in the form: COLUMN_NAME &amp;lt;operator&amp;gt; value. (optional)</param>
        /// <param name="textSearchMetaDataColumn">When using a text search, these custom metadata columns will also be searched. (optional)</param>
        /// <param name="minSendAttempts">The minimum number of send attempts for connector messages. (optional)</param>
        /// <param name="maxSendAttempts">The maximum number of send attempts for connector messages. (optional)</param>
        /// <param name="attachment">If true, only messages with attachments are included in the results. (optional)</param>
        /// <param name="error">If true, only messages with errors are included in the results. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (long)</returns>
        public async System.Threading.Tasks.Task<OpenapiGenerator.MirthConnect311.Client.ApiResponse<long>> GetMessageCountWithHttpInfoAsync(string channelId, long? minMessageId = default(long?), long? maxMessageId = default(long?), long? minOriginalId = default(long?), long? maxOriginalId = default(long?), long? minImportId = default(long?), long? maxImportId = default(long?), DateTime? startDate = default(DateTime?), DateTime? endDate = default(DateTime?), string textSearch = default(string), bool? textSearchRegex = default(bool?), List<string> status = default(List<string>), List<int> includedMetaDataId = default(List<int>), List<int> excludedMetaDataId = default(List<int>), string serverId = default(string), List<string> rawContentSearch = default(List<string>), List<string> processedRawContentSearch = default(List<string>), List<string> transformedContentSearch = default(List<string>), List<string> encodedContentSearch = default(List<string>), List<string> sentContentSearch = default(List<string>), List<string> responseContentSearch = default(List<string>), List<string> responseTransformedContentSearch = default(List<string>), List<string> processedResponseContentSearch = default(List<string>), List<string> connectorMapContentSearch = default(List<string>), List<string> channelMapContentSearch = default(List<string>), List<string> sourceMapContentSearch = default(List<string>), List<string> responseMapContentSearch = default(List<string>), List<string> processingErrorContentSearch = default(List<string>), List<string> postprocessorErrorContentSearch = default(List<string>), List<string> responseErrorContentSearch = default(List<string>), List<MetaDataSearch> metaDataSearch = default(List<MetaDataSearch>), List<MetaDataSearch> metaDataCaseInsensitiveSearch = default(List<MetaDataSearch>), List<string> textSearchMetaDataColumn = default(List<string>), int? minSendAttempts = default(int?), int? maxSendAttempts = default(int?), bool? attachment = default(bool?), bool? error = default(bool?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'channelId' is set
            if (channelId == null)
            {
                throw new OpenapiGenerator.MirthConnect311.Client.ApiException(400, "Missing required parameter 'channelId' when calling MessagesApi->GetMessageCount");
            }


            OpenapiGenerator.MirthConnect311.Client.RequestOptions localVarRequestOptions = new OpenapiGenerator.MirthConnect311.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/xml",
                "application/json"
            };

            var localVarContentType = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("channelId", OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToString(channelId)); // path parameter
            if (minMessageId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "minMessageId", minMessageId));
            }
            if (maxMessageId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "maxMessageId", maxMessageId));
            }
            if (minOriginalId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "minOriginalId", minOriginalId));
            }
            if (maxOriginalId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "maxOriginalId", maxOriginalId));
            }
            if (minImportId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "minImportId", minImportId));
            }
            if (maxImportId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "maxImportId", maxImportId));
            }
            if (startDate != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "startDate", startDate));
            }
            if (endDate != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "endDate", endDate));
            }
            if (textSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "textSearch", textSearch));
            }
            if (textSearchRegex != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "textSearchRegex", textSearchRegex));
            }
            if (status != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "status", status));
            }
            if (includedMetaDataId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "includedMetaDataId", includedMetaDataId));
            }
            if (excludedMetaDataId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "excludedMetaDataId", excludedMetaDataId));
            }
            if (serverId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "serverId", serverId));
            }
            if (rawContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "rawContentSearch", rawContentSearch));
            }
            if (processedRawContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "processedRawContentSearch", processedRawContentSearch));
            }
            if (transformedContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "transformedContentSearch", transformedContentSearch));
            }
            if (encodedContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "encodedContentSearch", encodedContentSearch));
            }
            if (sentContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "sentContentSearch", sentContentSearch));
            }
            if (responseContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "responseContentSearch", responseContentSearch));
            }
            if (responseTransformedContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "responseTransformedContentSearch", responseTransformedContentSearch));
            }
            if (processedResponseContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "processedResponseContentSearch", processedResponseContentSearch));
            }
            if (connectorMapContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "connectorMapContentSearch", connectorMapContentSearch));
            }
            if (channelMapContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "channelMapContentSearch", channelMapContentSearch));
            }
            if (sourceMapContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "sourceMapContentSearch", sourceMapContentSearch));
            }
            if (responseMapContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "responseMapContentSearch", responseMapContentSearch));
            }
            if (processingErrorContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "processingErrorContentSearch", processingErrorContentSearch));
            }
            if (postprocessorErrorContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "postprocessorErrorContentSearch", postprocessorErrorContentSearch));
            }
            if (responseErrorContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "responseErrorContentSearch", responseErrorContentSearch));
            }
            if (metaDataSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "metaDataSearch", metaDataSearch));
            }
            if (metaDataCaseInsensitiveSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "metaDataCaseInsensitiveSearch", metaDataCaseInsensitiveSearch));
            }
            if (textSearchMetaDataColumn != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "textSearchMetaDataColumn", textSearchMetaDataColumn));
            }
            if (minSendAttempts != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "minSendAttempts", minSendAttempts));
            }
            if (maxSendAttempts != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "maxSendAttempts", maxSendAttempts));
            }
            if (attachment != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "attachment", attachment));
            }
            if (error != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "error", error));
            }

            // authentication (cookieAuth) required
            // cookie parameter support
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("JSESSIONID")))
            {
                localVarRequestOptions.Cookies.Add(new Cookie("JSESSIONID", this.Configuration.GetApiKeyWithPrefix("JSESSIONID")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<long>("/channels/{channelId}/messages/count", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetMessageCount", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Count number for messages by specific filter criteria. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="messageFilter">The MessageFilter object to use to query messages by.</param>
        /// <returns>long</returns>
        public long GetMessageCount1(string channelId, MessageFilter messageFilter)
        {
            OpenapiGenerator.MirthConnect311.Client.ApiResponse<long> localVarResponse = GetMessageCount1WithHttpInfo(channelId, messageFilter);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Count number for messages by specific filter criteria. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="messageFilter">The MessageFilter object to use to query messages by.</param>
        /// <returns>ApiResponse of long</returns>
        public OpenapiGenerator.MirthConnect311.Client.ApiResponse<long> GetMessageCount1WithHttpInfo(string channelId, MessageFilter messageFilter)
        {
            // verify the required parameter 'channelId' is set
            if (channelId == null)
            {
                throw new OpenapiGenerator.MirthConnect311.Client.ApiException(400, "Missing required parameter 'channelId' when calling MessagesApi->GetMessageCount1");
            }

            // verify the required parameter 'messageFilter' is set
            if (messageFilter == null)
            {
                throw new OpenapiGenerator.MirthConnect311.Client.ApiException(400, "Missing required parameter 'messageFilter' when calling MessagesApi->GetMessageCount1");
            }

            OpenapiGenerator.MirthConnect311.Client.RequestOptions localVarRequestOptions = new OpenapiGenerator.MirthConnect311.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/xml",
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/xml",
                "application/json"
            };

            var localVarContentType = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("channelId", OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToString(channelId)); // path parameter
            localVarRequestOptions.Data = messageFilter;

            // authentication (cookieAuth) required
            // cookie parameter support
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("JSESSIONID")))
            {
                localVarRequestOptions.Cookies.Add(new Cookie("JSESSIONID", this.Configuration.GetApiKeyWithPrefix("JSESSIONID")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<long>("/channels/{channelId}/messages/count/_search", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetMessageCount1", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Count number for messages by specific filter criteria. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="messageFilter">The MessageFilter object to use to query messages by.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of long</returns>
        public async System.Threading.Tasks.Task<long> GetMessageCount1Async(string channelId, MessageFilter messageFilter, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            OpenapiGenerator.MirthConnect311.Client.ApiResponse<long> localVarResponse = await GetMessageCount1WithHttpInfoAsync(channelId, messageFilter, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Count number for messages by specific filter criteria. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="messageFilter">The MessageFilter object to use to query messages by.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (long)</returns>
        public async System.Threading.Tasks.Task<OpenapiGenerator.MirthConnect311.Client.ApiResponse<long>> GetMessageCount1WithHttpInfoAsync(string channelId, MessageFilter messageFilter, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'channelId' is set
            if (channelId == null)
            {
                throw new OpenapiGenerator.MirthConnect311.Client.ApiException(400, "Missing required parameter 'channelId' when calling MessagesApi->GetMessageCount1");
            }

            // verify the required parameter 'messageFilter' is set
            if (messageFilter == null)
            {
                throw new OpenapiGenerator.MirthConnect311.Client.ApiException(400, "Missing required parameter 'messageFilter' when calling MessagesApi->GetMessageCount1");
            }


            OpenapiGenerator.MirthConnect311.Client.RequestOptions localVarRequestOptions = new OpenapiGenerator.MirthConnect311.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/xml", 
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/xml",
                "application/json"
            };

            var localVarContentType = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("channelId", OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToString(channelId)); // path parameter
            localVarRequestOptions.Data = messageFilter;

            // authentication (cookieAuth) required
            // cookie parameter support
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("JSESSIONID")))
            {
                localVarRequestOptions.Cookies.Add(new Cookie("JSESSIONID", this.Configuration.GetApiKeyWithPrefix("JSESSIONID")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<long>("/channels/{channelId}/messages/count/_search", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetMessageCount1", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Search for messages by specific filter criteria. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="minMessageId">The minimum message ID to query. (optional)</param>
        /// <param name="maxMessageId">The maximum message ID to query. (optional)</param>
        /// <param name="minOriginalId">The minimum original message ID to query. Messages that have been reprocessed will retain their original message ID. (optional)</param>
        /// <param name="maxOriginalId">The maximum original message ID to query. Messages that have been reprocessed will retain their original message ID. (optional)</param>
        /// <param name="minImportId">The minimum import message ID to query. Messages that have been imported will retain their original message ID under this value. (optional)</param>
        /// <param name="maxImportId">The maximum import message ID to query. Messages that have been imported will retain their original message ID under this value. (optional)</param>
        /// <param name="startDate">The earliest original received date to query by. Example: 1985-10-26T09:00:00.000-0700 (optional)</param>
        /// <param name="endDate">The latest original received date to query by. Example: 2015-10-21T07:28:00.000-0700 (optional)</param>
        /// <param name="textSearch">Searches all message content for this string. This process could take a long time depending on the amount of message content currently stored. Any message content that was encrypted by this channel will not be searchable. (optional)</param>
        /// <param name="textSearchRegex">If true, text search input will be considered a regular expression pattern to be matched. Only supported by PostgreSQL, MySQL and Oracle databases. (optional)</param>
        /// <param name="status">Determines which message statuses to query by. (optional)</param>
        /// <param name="includedMetaDataId">If present, only connector metadata IDs in this list will be queried. (optional)</param>
        /// <param name="excludedMetaDataId">If present, connector metadata IDs in this list will not be queried. (optional)</param>
        /// <param name="serverId">The server ID associated with messages. (optional)</param>
        /// <param name="rawContentSearch">Searches the raw content of messages. (optional)</param>
        /// <param name="processedRawContentSearch">Searches the processed raw content of messages. (optional)</param>
        /// <param name="transformedContentSearch">Searches the transformed content of messages. (optional)</param>
        /// <param name="encodedContentSearch">Searches the encoded content of messages. (optional)</param>
        /// <param name="sentContentSearch">Searches the sent content of messages. (optional)</param>
        /// <param name="responseContentSearch">Searches the response content of messages. (optional)</param>
        /// <param name="responseTransformedContentSearch">Searches the response transformed content of messages. (optional)</param>
        /// <param name="processedResponseContentSearch">Searches the processed response content of messages. (optional)</param>
        /// <param name="connectorMapContentSearch">Searches the connector map content of messages. (optional)</param>
        /// <param name="channelMapContentSearch">Searches the channel map content of messages. (optional)</param>
        /// <param name="sourceMapContentSearch">Searches the source map content of messages. (optional)</param>
        /// <param name="responseMapContentSearch">Searches the response map content of messages. (optional)</param>
        /// <param name="processingErrorContentSearch">Searches the processing error content of messages. (optional)</param>
        /// <param name="postprocessorErrorContentSearch">Searches the postprocessor error content of messages. (optional)</param>
        /// <param name="responseErrorContentSearch">Searches the response error content of messages. (optional)</param>
        /// <param name="metaDataSearch">Searches a custom metadata column. Value should be in the form: COLUMN_NAME &amp;lt;operator&amp;gt; value, where operator is one of the following: &#x3D;, !&#x3D;, &lt;, &lt;&#x3D;, &gt;, &gt;&#x3D;, CONTAINS, DOES NOT CONTAIN, STARTS WITH, DOES NOT START WITH, ENDS WITH, DOES NOT END WITH (optional)</param>
        /// <param name="metaDataCaseInsensitiveSearch">Searches a custom metadata column, ignoring case. Value should be in the form: COLUMN_NAME &amp;lt;operator&amp;gt; value. (optional)</param>
        /// <param name="textSearchMetaDataColumn">When using a text search, these custom metadata columns will also be searched. (optional)</param>
        /// <param name="minSendAttempts">The minimum number of send attempts for connector messages. (optional)</param>
        /// <param name="maxSendAttempts">The maximum number of send attempts for connector messages. (optional)</param>
        /// <param name="attachment">If true, only messages with attachments are included in the results. (optional)</param>
        /// <param name="error">If true, only messages with errors are included in the results. (optional)</param>
        /// <param name="includeContent">If true, message content will be returned with the results. (optional, default to false)</param>
        /// <param name="offset">Used for pagination, determines where to start in the search results. (optional, default to 0)</param>
        /// <param name="limit">Used for pagination, determines the maximum number of results to return. (optional, default to 20)</param>
        /// <returns>List&lt;Message&gt;</returns>
        public List<Message> GetMessages(string channelId, long? minMessageId = default(long?), long? maxMessageId = default(long?), long? minOriginalId = default(long?), long? maxOriginalId = default(long?), long? minImportId = default(long?), long? maxImportId = default(long?), DateTime? startDate = default(DateTime?), DateTime? endDate = default(DateTime?), string textSearch = default(string), bool? textSearchRegex = default(bool?), List<string> status = default(List<string>), List<int> includedMetaDataId = default(List<int>), List<int> excludedMetaDataId = default(List<int>), string serverId = default(string), List<string> rawContentSearch = default(List<string>), List<string> processedRawContentSearch = default(List<string>), List<string> transformedContentSearch = default(List<string>), List<string> encodedContentSearch = default(List<string>), List<string> sentContentSearch = default(List<string>), List<string> responseContentSearch = default(List<string>), List<string> responseTransformedContentSearch = default(List<string>), List<string> processedResponseContentSearch = default(List<string>), List<string> connectorMapContentSearch = default(List<string>), List<string> channelMapContentSearch = default(List<string>), List<string> sourceMapContentSearch = default(List<string>), List<string> responseMapContentSearch = default(List<string>), List<string> processingErrorContentSearch = default(List<string>), List<string> postprocessorErrorContentSearch = default(List<string>), List<string> responseErrorContentSearch = default(List<string>), List<MetaDataSearch> metaDataSearch = default(List<MetaDataSearch>), List<MetaDataSearch> metaDataCaseInsensitiveSearch = default(List<MetaDataSearch>), List<string> textSearchMetaDataColumn = default(List<string>), int? minSendAttempts = default(int?), int? maxSendAttempts = default(int?), bool? attachment = default(bool?), bool? error = default(bool?), bool? includeContent = default(bool?), int? offset = default(int?), int? limit = default(int?))
        {
            OpenapiGenerator.MirthConnect311.Client.ApiResponse<List<Message>> localVarResponse = GetMessagesWithHttpInfo(channelId, minMessageId, maxMessageId, minOriginalId, maxOriginalId, minImportId, maxImportId, startDate, endDate, textSearch, textSearchRegex, status, includedMetaDataId, excludedMetaDataId, serverId, rawContentSearch, processedRawContentSearch, transformedContentSearch, encodedContentSearch, sentContentSearch, responseContentSearch, responseTransformedContentSearch, processedResponseContentSearch, connectorMapContentSearch, channelMapContentSearch, sourceMapContentSearch, responseMapContentSearch, processingErrorContentSearch, postprocessorErrorContentSearch, responseErrorContentSearch, metaDataSearch, metaDataCaseInsensitiveSearch, textSearchMetaDataColumn, minSendAttempts, maxSendAttempts, attachment, error, includeContent, offset, limit);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Search for messages by specific filter criteria. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="minMessageId">The minimum message ID to query. (optional)</param>
        /// <param name="maxMessageId">The maximum message ID to query. (optional)</param>
        /// <param name="minOriginalId">The minimum original message ID to query. Messages that have been reprocessed will retain their original message ID. (optional)</param>
        /// <param name="maxOriginalId">The maximum original message ID to query. Messages that have been reprocessed will retain their original message ID. (optional)</param>
        /// <param name="minImportId">The minimum import message ID to query. Messages that have been imported will retain their original message ID under this value. (optional)</param>
        /// <param name="maxImportId">The maximum import message ID to query. Messages that have been imported will retain their original message ID under this value. (optional)</param>
        /// <param name="startDate">The earliest original received date to query by. Example: 1985-10-26T09:00:00.000-0700 (optional)</param>
        /// <param name="endDate">The latest original received date to query by. Example: 2015-10-21T07:28:00.000-0700 (optional)</param>
        /// <param name="textSearch">Searches all message content for this string. This process could take a long time depending on the amount of message content currently stored. Any message content that was encrypted by this channel will not be searchable. (optional)</param>
        /// <param name="textSearchRegex">If true, text search input will be considered a regular expression pattern to be matched. Only supported by PostgreSQL, MySQL and Oracle databases. (optional)</param>
        /// <param name="status">Determines which message statuses to query by. (optional)</param>
        /// <param name="includedMetaDataId">If present, only connector metadata IDs in this list will be queried. (optional)</param>
        /// <param name="excludedMetaDataId">If present, connector metadata IDs in this list will not be queried. (optional)</param>
        /// <param name="serverId">The server ID associated with messages. (optional)</param>
        /// <param name="rawContentSearch">Searches the raw content of messages. (optional)</param>
        /// <param name="processedRawContentSearch">Searches the processed raw content of messages. (optional)</param>
        /// <param name="transformedContentSearch">Searches the transformed content of messages. (optional)</param>
        /// <param name="encodedContentSearch">Searches the encoded content of messages. (optional)</param>
        /// <param name="sentContentSearch">Searches the sent content of messages. (optional)</param>
        /// <param name="responseContentSearch">Searches the response content of messages. (optional)</param>
        /// <param name="responseTransformedContentSearch">Searches the response transformed content of messages. (optional)</param>
        /// <param name="processedResponseContentSearch">Searches the processed response content of messages. (optional)</param>
        /// <param name="connectorMapContentSearch">Searches the connector map content of messages. (optional)</param>
        /// <param name="channelMapContentSearch">Searches the channel map content of messages. (optional)</param>
        /// <param name="sourceMapContentSearch">Searches the source map content of messages. (optional)</param>
        /// <param name="responseMapContentSearch">Searches the response map content of messages. (optional)</param>
        /// <param name="processingErrorContentSearch">Searches the processing error content of messages. (optional)</param>
        /// <param name="postprocessorErrorContentSearch">Searches the postprocessor error content of messages. (optional)</param>
        /// <param name="responseErrorContentSearch">Searches the response error content of messages. (optional)</param>
        /// <param name="metaDataSearch">Searches a custom metadata column. Value should be in the form: COLUMN_NAME &amp;lt;operator&amp;gt; value, where operator is one of the following: &#x3D;, !&#x3D;, &lt;, &lt;&#x3D;, &gt;, &gt;&#x3D;, CONTAINS, DOES NOT CONTAIN, STARTS WITH, DOES NOT START WITH, ENDS WITH, DOES NOT END WITH (optional)</param>
        /// <param name="metaDataCaseInsensitiveSearch">Searches a custom metadata column, ignoring case. Value should be in the form: COLUMN_NAME &amp;lt;operator&amp;gt; value. (optional)</param>
        /// <param name="textSearchMetaDataColumn">When using a text search, these custom metadata columns will also be searched. (optional)</param>
        /// <param name="minSendAttempts">The minimum number of send attempts for connector messages. (optional)</param>
        /// <param name="maxSendAttempts">The maximum number of send attempts for connector messages. (optional)</param>
        /// <param name="attachment">If true, only messages with attachments are included in the results. (optional)</param>
        /// <param name="error">If true, only messages with errors are included in the results. (optional)</param>
        /// <param name="includeContent">If true, message content will be returned with the results. (optional, default to false)</param>
        /// <param name="offset">Used for pagination, determines where to start in the search results. (optional, default to 0)</param>
        /// <param name="limit">Used for pagination, determines the maximum number of results to return. (optional, default to 20)</param>
        /// <returns>ApiResponse of List&lt;Message&gt;</returns>
        public OpenapiGenerator.MirthConnect311.Client.ApiResponse<List<Message>> GetMessagesWithHttpInfo(string channelId, long? minMessageId = default(long?), long? maxMessageId = default(long?), long? minOriginalId = default(long?), long? maxOriginalId = default(long?), long? minImportId = default(long?), long? maxImportId = default(long?), DateTime? startDate = default(DateTime?), DateTime? endDate = default(DateTime?), string textSearch = default(string), bool? textSearchRegex = default(bool?), List<string> status = default(List<string>), List<int> includedMetaDataId = default(List<int>), List<int> excludedMetaDataId = default(List<int>), string serverId = default(string), List<string> rawContentSearch = default(List<string>), List<string> processedRawContentSearch = default(List<string>), List<string> transformedContentSearch = default(List<string>), List<string> encodedContentSearch = default(List<string>), List<string> sentContentSearch = default(List<string>), List<string> responseContentSearch = default(List<string>), List<string> responseTransformedContentSearch = default(List<string>), List<string> processedResponseContentSearch = default(List<string>), List<string> connectorMapContentSearch = default(List<string>), List<string> channelMapContentSearch = default(List<string>), List<string> sourceMapContentSearch = default(List<string>), List<string> responseMapContentSearch = default(List<string>), List<string> processingErrorContentSearch = default(List<string>), List<string> postprocessorErrorContentSearch = default(List<string>), List<string> responseErrorContentSearch = default(List<string>), List<MetaDataSearch> metaDataSearch = default(List<MetaDataSearch>), List<MetaDataSearch> metaDataCaseInsensitiveSearch = default(List<MetaDataSearch>), List<string> textSearchMetaDataColumn = default(List<string>), int? minSendAttempts = default(int?), int? maxSendAttempts = default(int?), bool? attachment = default(bool?), bool? error = default(bool?), bool? includeContent = default(bool?), int? offset = default(int?), int? limit = default(int?))
        {
            // verify the required parameter 'channelId' is set
            if (channelId == null)
            {
                throw new OpenapiGenerator.MirthConnect311.Client.ApiException(400, "Missing required parameter 'channelId' when calling MessagesApi->GetMessages");
            }

            OpenapiGenerator.MirthConnect311.Client.RequestOptions localVarRequestOptions = new OpenapiGenerator.MirthConnect311.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/xml",
                "application/json"
            };

            var localVarContentType = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("channelId", OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToString(channelId)); // path parameter
            if (minMessageId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "minMessageId", minMessageId));
            }
            if (maxMessageId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "maxMessageId", maxMessageId));
            }
            if (minOriginalId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "minOriginalId", minOriginalId));
            }
            if (maxOriginalId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "maxOriginalId", maxOriginalId));
            }
            if (minImportId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "minImportId", minImportId));
            }
            if (maxImportId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "maxImportId", maxImportId));
            }
            if (startDate != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "startDate", startDate));
            }
            if (endDate != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "endDate", endDate));
            }
            if (textSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "textSearch", textSearch));
            }
            if (textSearchRegex != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "textSearchRegex", textSearchRegex));
            }
            if (status != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "status", status));
            }
            if (includedMetaDataId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "includedMetaDataId", includedMetaDataId));
            }
            if (excludedMetaDataId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "excludedMetaDataId", excludedMetaDataId));
            }
            if (serverId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "serverId", serverId));
            }
            if (rawContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "rawContentSearch", rawContentSearch));
            }
            if (processedRawContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "processedRawContentSearch", processedRawContentSearch));
            }
            if (transformedContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "transformedContentSearch", transformedContentSearch));
            }
            if (encodedContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "encodedContentSearch", encodedContentSearch));
            }
            if (sentContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "sentContentSearch", sentContentSearch));
            }
            if (responseContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "responseContentSearch", responseContentSearch));
            }
            if (responseTransformedContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "responseTransformedContentSearch", responseTransformedContentSearch));
            }
            if (processedResponseContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "processedResponseContentSearch", processedResponseContentSearch));
            }
            if (connectorMapContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "connectorMapContentSearch", connectorMapContentSearch));
            }
            if (channelMapContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "channelMapContentSearch", channelMapContentSearch));
            }
            if (sourceMapContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "sourceMapContentSearch", sourceMapContentSearch));
            }
            if (responseMapContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "responseMapContentSearch", responseMapContentSearch));
            }
            if (processingErrorContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "processingErrorContentSearch", processingErrorContentSearch));
            }
            if (postprocessorErrorContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "postprocessorErrorContentSearch", postprocessorErrorContentSearch));
            }
            if (responseErrorContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "responseErrorContentSearch", responseErrorContentSearch));
            }
            if (metaDataSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "metaDataSearch", metaDataSearch));
            }
            if (metaDataCaseInsensitiveSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "metaDataCaseInsensitiveSearch", metaDataCaseInsensitiveSearch));
            }
            if (textSearchMetaDataColumn != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "textSearchMetaDataColumn", textSearchMetaDataColumn));
            }
            if (minSendAttempts != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "minSendAttempts", minSendAttempts));
            }
            if (maxSendAttempts != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "maxSendAttempts", maxSendAttempts));
            }
            if (attachment != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "attachment", attachment));
            }
            if (error != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "error", error));
            }
            if (includeContent != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "includeContent", includeContent));
            }
            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }

            // authentication (cookieAuth) required
            // cookie parameter support
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("JSESSIONID")))
            {
                localVarRequestOptions.Cookies.Add(new Cookie("JSESSIONID", this.Configuration.GetApiKeyWithPrefix("JSESSIONID")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<List<Message>>("/channels/{channelId}/messages", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetMessages", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Search for messages by specific filter criteria. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="minMessageId">The minimum message ID to query. (optional)</param>
        /// <param name="maxMessageId">The maximum message ID to query. (optional)</param>
        /// <param name="minOriginalId">The minimum original message ID to query. Messages that have been reprocessed will retain their original message ID. (optional)</param>
        /// <param name="maxOriginalId">The maximum original message ID to query. Messages that have been reprocessed will retain their original message ID. (optional)</param>
        /// <param name="minImportId">The minimum import message ID to query. Messages that have been imported will retain their original message ID under this value. (optional)</param>
        /// <param name="maxImportId">The maximum import message ID to query. Messages that have been imported will retain their original message ID under this value. (optional)</param>
        /// <param name="startDate">The earliest original received date to query by. Example: 1985-10-26T09:00:00.000-0700 (optional)</param>
        /// <param name="endDate">The latest original received date to query by. Example: 2015-10-21T07:28:00.000-0700 (optional)</param>
        /// <param name="textSearch">Searches all message content for this string. This process could take a long time depending on the amount of message content currently stored. Any message content that was encrypted by this channel will not be searchable. (optional)</param>
        /// <param name="textSearchRegex">If true, text search input will be considered a regular expression pattern to be matched. Only supported by PostgreSQL, MySQL and Oracle databases. (optional)</param>
        /// <param name="status">Determines which message statuses to query by. (optional)</param>
        /// <param name="includedMetaDataId">If present, only connector metadata IDs in this list will be queried. (optional)</param>
        /// <param name="excludedMetaDataId">If present, connector metadata IDs in this list will not be queried. (optional)</param>
        /// <param name="serverId">The server ID associated with messages. (optional)</param>
        /// <param name="rawContentSearch">Searches the raw content of messages. (optional)</param>
        /// <param name="processedRawContentSearch">Searches the processed raw content of messages. (optional)</param>
        /// <param name="transformedContentSearch">Searches the transformed content of messages. (optional)</param>
        /// <param name="encodedContentSearch">Searches the encoded content of messages. (optional)</param>
        /// <param name="sentContentSearch">Searches the sent content of messages. (optional)</param>
        /// <param name="responseContentSearch">Searches the response content of messages. (optional)</param>
        /// <param name="responseTransformedContentSearch">Searches the response transformed content of messages. (optional)</param>
        /// <param name="processedResponseContentSearch">Searches the processed response content of messages. (optional)</param>
        /// <param name="connectorMapContentSearch">Searches the connector map content of messages. (optional)</param>
        /// <param name="channelMapContentSearch">Searches the channel map content of messages. (optional)</param>
        /// <param name="sourceMapContentSearch">Searches the source map content of messages. (optional)</param>
        /// <param name="responseMapContentSearch">Searches the response map content of messages. (optional)</param>
        /// <param name="processingErrorContentSearch">Searches the processing error content of messages. (optional)</param>
        /// <param name="postprocessorErrorContentSearch">Searches the postprocessor error content of messages. (optional)</param>
        /// <param name="responseErrorContentSearch">Searches the response error content of messages. (optional)</param>
        /// <param name="metaDataSearch">Searches a custom metadata column. Value should be in the form: COLUMN_NAME &amp;lt;operator&amp;gt; value, where operator is one of the following: &#x3D;, !&#x3D;, &lt;, &lt;&#x3D;, &gt;, &gt;&#x3D;, CONTAINS, DOES NOT CONTAIN, STARTS WITH, DOES NOT START WITH, ENDS WITH, DOES NOT END WITH (optional)</param>
        /// <param name="metaDataCaseInsensitiveSearch">Searches a custom metadata column, ignoring case. Value should be in the form: COLUMN_NAME &amp;lt;operator&amp;gt; value. (optional)</param>
        /// <param name="textSearchMetaDataColumn">When using a text search, these custom metadata columns will also be searched. (optional)</param>
        /// <param name="minSendAttempts">The minimum number of send attempts for connector messages. (optional)</param>
        /// <param name="maxSendAttempts">The maximum number of send attempts for connector messages. (optional)</param>
        /// <param name="attachment">If true, only messages with attachments are included in the results. (optional)</param>
        /// <param name="error">If true, only messages with errors are included in the results. (optional)</param>
        /// <param name="includeContent">If true, message content will be returned with the results. (optional, default to false)</param>
        /// <param name="offset">Used for pagination, determines where to start in the search results. (optional, default to 0)</param>
        /// <param name="limit">Used for pagination, determines the maximum number of results to return. (optional, default to 20)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;Message&gt;</returns>
        public async System.Threading.Tasks.Task<List<Message>> GetMessagesAsync(string channelId, long? minMessageId = default(long?), long? maxMessageId = default(long?), long? minOriginalId = default(long?), long? maxOriginalId = default(long?), long? minImportId = default(long?), long? maxImportId = default(long?), DateTime? startDate = default(DateTime?), DateTime? endDate = default(DateTime?), string textSearch = default(string), bool? textSearchRegex = default(bool?), List<string> status = default(List<string>), List<int> includedMetaDataId = default(List<int>), List<int> excludedMetaDataId = default(List<int>), string serverId = default(string), List<string> rawContentSearch = default(List<string>), List<string> processedRawContentSearch = default(List<string>), List<string> transformedContentSearch = default(List<string>), List<string> encodedContentSearch = default(List<string>), List<string> sentContentSearch = default(List<string>), List<string> responseContentSearch = default(List<string>), List<string> responseTransformedContentSearch = default(List<string>), List<string> processedResponseContentSearch = default(List<string>), List<string> connectorMapContentSearch = default(List<string>), List<string> channelMapContentSearch = default(List<string>), List<string> sourceMapContentSearch = default(List<string>), List<string> responseMapContentSearch = default(List<string>), List<string> processingErrorContentSearch = default(List<string>), List<string> postprocessorErrorContentSearch = default(List<string>), List<string> responseErrorContentSearch = default(List<string>), List<MetaDataSearch> metaDataSearch = default(List<MetaDataSearch>), List<MetaDataSearch> metaDataCaseInsensitiveSearch = default(List<MetaDataSearch>), List<string> textSearchMetaDataColumn = default(List<string>), int? minSendAttempts = default(int?), int? maxSendAttempts = default(int?), bool? attachment = default(bool?), bool? error = default(bool?), bool? includeContent = default(bool?), int? offset = default(int?), int? limit = default(int?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            OpenapiGenerator.MirthConnect311.Client.ApiResponse<List<Message>> localVarResponse = await GetMessagesWithHttpInfoAsync(channelId, minMessageId, maxMessageId, minOriginalId, maxOriginalId, minImportId, maxImportId, startDate, endDate, textSearch, textSearchRegex, status, includedMetaDataId, excludedMetaDataId, serverId, rawContentSearch, processedRawContentSearch, transformedContentSearch, encodedContentSearch, sentContentSearch, responseContentSearch, responseTransformedContentSearch, processedResponseContentSearch, connectorMapContentSearch, channelMapContentSearch, sourceMapContentSearch, responseMapContentSearch, processingErrorContentSearch, postprocessorErrorContentSearch, responseErrorContentSearch, metaDataSearch, metaDataCaseInsensitiveSearch, textSearchMetaDataColumn, minSendAttempts, maxSendAttempts, attachment, error, includeContent, offset, limit, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Search for messages by specific filter criteria. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="minMessageId">The minimum message ID to query. (optional)</param>
        /// <param name="maxMessageId">The maximum message ID to query. (optional)</param>
        /// <param name="minOriginalId">The minimum original message ID to query. Messages that have been reprocessed will retain their original message ID. (optional)</param>
        /// <param name="maxOriginalId">The maximum original message ID to query. Messages that have been reprocessed will retain their original message ID. (optional)</param>
        /// <param name="minImportId">The minimum import message ID to query. Messages that have been imported will retain their original message ID under this value. (optional)</param>
        /// <param name="maxImportId">The maximum import message ID to query. Messages that have been imported will retain their original message ID under this value. (optional)</param>
        /// <param name="startDate">The earliest original received date to query by. Example: 1985-10-26T09:00:00.000-0700 (optional)</param>
        /// <param name="endDate">The latest original received date to query by. Example: 2015-10-21T07:28:00.000-0700 (optional)</param>
        /// <param name="textSearch">Searches all message content for this string. This process could take a long time depending on the amount of message content currently stored. Any message content that was encrypted by this channel will not be searchable. (optional)</param>
        /// <param name="textSearchRegex">If true, text search input will be considered a regular expression pattern to be matched. Only supported by PostgreSQL, MySQL and Oracle databases. (optional)</param>
        /// <param name="status">Determines which message statuses to query by. (optional)</param>
        /// <param name="includedMetaDataId">If present, only connector metadata IDs in this list will be queried. (optional)</param>
        /// <param name="excludedMetaDataId">If present, connector metadata IDs in this list will not be queried. (optional)</param>
        /// <param name="serverId">The server ID associated with messages. (optional)</param>
        /// <param name="rawContentSearch">Searches the raw content of messages. (optional)</param>
        /// <param name="processedRawContentSearch">Searches the processed raw content of messages. (optional)</param>
        /// <param name="transformedContentSearch">Searches the transformed content of messages. (optional)</param>
        /// <param name="encodedContentSearch">Searches the encoded content of messages. (optional)</param>
        /// <param name="sentContentSearch">Searches the sent content of messages. (optional)</param>
        /// <param name="responseContentSearch">Searches the response content of messages. (optional)</param>
        /// <param name="responseTransformedContentSearch">Searches the response transformed content of messages. (optional)</param>
        /// <param name="processedResponseContentSearch">Searches the processed response content of messages. (optional)</param>
        /// <param name="connectorMapContentSearch">Searches the connector map content of messages. (optional)</param>
        /// <param name="channelMapContentSearch">Searches the channel map content of messages. (optional)</param>
        /// <param name="sourceMapContentSearch">Searches the source map content of messages. (optional)</param>
        /// <param name="responseMapContentSearch">Searches the response map content of messages. (optional)</param>
        /// <param name="processingErrorContentSearch">Searches the processing error content of messages. (optional)</param>
        /// <param name="postprocessorErrorContentSearch">Searches the postprocessor error content of messages. (optional)</param>
        /// <param name="responseErrorContentSearch">Searches the response error content of messages. (optional)</param>
        /// <param name="metaDataSearch">Searches a custom metadata column. Value should be in the form: COLUMN_NAME &amp;lt;operator&amp;gt; value, where operator is one of the following: &#x3D;, !&#x3D;, &lt;, &lt;&#x3D;, &gt;, &gt;&#x3D;, CONTAINS, DOES NOT CONTAIN, STARTS WITH, DOES NOT START WITH, ENDS WITH, DOES NOT END WITH (optional)</param>
        /// <param name="metaDataCaseInsensitiveSearch">Searches a custom metadata column, ignoring case. Value should be in the form: COLUMN_NAME &amp;lt;operator&amp;gt; value. (optional)</param>
        /// <param name="textSearchMetaDataColumn">When using a text search, these custom metadata columns will also be searched. (optional)</param>
        /// <param name="minSendAttempts">The minimum number of send attempts for connector messages. (optional)</param>
        /// <param name="maxSendAttempts">The maximum number of send attempts for connector messages. (optional)</param>
        /// <param name="attachment">If true, only messages with attachments are included in the results. (optional)</param>
        /// <param name="error">If true, only messages with errors are included in the results. (optional)</param>
        /// <param name="includeContent">If true, message content will be returned with the results. (optional, default to false)</param>
        /// <param name="offset">Used for pagination, determines where to start in the search results. (optional, default to 0)</param>
        /// <param name="limit">Used for pagination, determines the maximum number of results to return. (optional, default to 20)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;Message&gt;)</returns>
        public async System.Threading.Tasks.Task<OpenapiGenerator.MirthConnect311.Client.ApiResponse<List<Message>>> GetMessagesWithHttpInfoAsync(string channelId, long? minMessageId = default(long?), long? maxMessageId = default(long?), long? minOriginalId = default(long?), long? maxOriginalId = default(long?), long? minImportId = default(long?), long? maxImportId = default(long?), DateTime? startDate = default(DateTime?), DateTime? endDate = default(DateTime?), string textSearch = default(string), bool? textSearchRegex = default(bool?), List<string> status = default(List<string>), List<int> includedMetaDataId = default(List<int>), List<int> excludedMetaDataId = default(List<int>), string serverId = default(string), List<string> rawContentSearch = default(List<string>), List<string> processedRawContentSearch = default(List<string>), List<string> transformedContentSearch = default(List<string>), List<string> encodedContentSearch = default(List<string>), List<string> sentContentSearch = default(List<string>), List<string> responseContentSearch = default(List<string>), List<string> responseTransformedContentSearch = default(List<string>), List<string> processedResponseContentSearch = default(List<string>), List<string> connectorMapContentSearch = default(List<string>), List<string> channelMapContentSearch = default(List<string>), List<string> sourceMapContentSearch = default(List<string>), List<string> responseMapContentSearch = default(List<string>), List<string> processingErrorContentSearch = default(List<string>), List<string> postprocessorErrorContentSearch = default(List<string>), List<string> responseErrorContentSearch = default(List<string>), List<MetaDataSearch> metaDataSearch = default(List<MetaDataSearch>), List<MetaDataSearch> metaDataCaseInsensitiveSearch = default(List<MetaDataSearch>), List<string> textSearchMetaDataColumn = default(List<string>), int? minSendAttempts = default(int?), int? maxSendAttempts = default(int?), bool? attachment = default(bool?), bool? error = default(bool?), bool? includeContent = default(bool?), int? offset = default(int?), int? limit = default(int?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'channelId' is set
            if (channelId == null)
            {
                throw new OpenapiGenerator.MirthConnect311.Client.ApiException(400, "Missing required parameter 'channelId' when calling MessagesApi->GetMessages");
            }


            OpenapiGenerator.MirthConnect311.Client.RequestOptions localVarRequestOptions = new OpenapiGenerator.MirthConnect311.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/xml",
                "application/json"
            };

            var localVarContentType = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("channelId", OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToString(channelId)); // path parameter
            if (minMessageId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "minMessageId", minMessageId));
            }
            if (maxMessageId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "maxMessageId", maxMessageId));
            }
            if (minOriginalId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "minOriginalId", minOriginalId));
            }
            if (maxOriginalId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "maxOriginalId", maxOriginalId));
            }
            if (minImportId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "minImportId", minImportId));
            }
            if (maxImportId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "maxImportId", maxImportId));
            }
            if (startDate != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "startDate", startDate));
            }
            if (endDate != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "endDate", endDate));
            }
            if (textSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "textSearch", textSearch));
            }
            if (textSearchRegex != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "textSearchRegex", textSearchRegex));
            }
            if (status != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "status", status));
            }
            if (includedMetaDataId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "includedMetaDataId", includedMetaDataId));
            }
            if (excludedMetaDataId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "excludedMetaDataId", excludedMetaDataId));
            }
            if (serverId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "serverId", serverId));
            }
            if (rawContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "rawContentSearch", rawContentSearch));
            }
            if (processedRawContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "processedRawContentSearch", processedRawContentSearch));
            }
            if (transformedContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "transformedContentSearch", transformedContentSearch));
            }
            if (encodedContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "encodedContentSearch", encodedContentSearch));
            }
            if (sentContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "sentContentSearch", sentContentSearch));
            }
            if (responseContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "responseContentSearch", responseContentSearch));
            }
            if (responseTransformedContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "responseTransformedContentSearch", responseTransformedContentSearch));
            }
            if (processedResponseContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "processedResponseContentSearch", processedResponseContentSearch));
            }
            if (connectorMapContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "connectorMapContentSearch", connectorMapContentSearch));
            }
            if (channelMapContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "channelMapContentSearch", channelMapContentSearch));
            }
            if (sourceMapContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "sourceMapContentSearch", sourceMapContentSearch));
            }
            if (responseMapContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "responseMapContentSearch", responseMapContentSearch));
            }
            if (processingErrorContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "processingErrorContentSearch", processingErrorContentSearch));
            }
            if (postprocessorErrorContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "postprocessorErrorContentSearch", postprocessorErrorContentSearch));
            }
            if (responseErrorContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "responseErrorContentSearch", responseErrorContentSearch));
            }
            if (metaDataSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "metaDataSearch", metaDataSearch));
            }
            if (metaDataCaseInsensitiveSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "metaDataCaseInsensitiveSearch", metaDataCaseInsensitiveSearch));
            }
            if (textSearchMetaDataColumn != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "textSearchMetaDataColumn", textSearchMetaDataColumn));
            }
            if (minSendAttempts != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "minSendAttempts", minSendAttempts));
            }
            if (maxSendAttempts != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "maxSendAttempts", maxSendAttempts));
            }
            if (attachment != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "attachment", attachment));
            }
            if (error != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "error", error));
            }
            if (includeContent != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "includeContent", includeContent));
            }
            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }

            // authentication (cookieAuth) required
            // cookie parameter support
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("JSESSIONID")))
            {
                localVarRequestOptions.Cookies.Add(new Cookie("JSESSIONID", this.Configuration.GetApiKeyWithPrefix("JSESSIONID")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<List<Message>>("/channels/{channelId}/messages", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetMessages", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Search for messages by specific filter criteria. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="messageFilter">The MessageFilter object to use to query messages by.</param>
        /// <param name="includeContent">If true, message content will be returned with the results. (optional, default to false)</param>
        /// <param name="offset">Used for pagination, determines where to start in the search results. (optional, default to 0)</param>
        /// <param name="limit">Used for pagination, determines the maximum number of results to return. (optional, default to 20)</param>
        /// <returns>List&lt;Message&gt;</returns>
        public List<Message> GetMessages1(string channelId, MessageFilter messageFilter, bool? includeContent = default(bool?), int? offset = default(int?), int? limit = default(int?))
        {
            OpenapiGenerator.MirthConnect311.Client.ApiResponse<List<Message>> localVarResponse = GetMessages1WithHttpInfo(channelId, messageFilter, includeContent, offset, limit);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Search for messages by specific filter criteria. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="messageFilter">The MessageFilter object to use to query messages by.</param>
        /// <param name="includeContent">If true, message content will be returned with the results. (optional, default to false)</param>
        /// <param name="offset">Used for pagination, determines where to start in the search results. (optional, default to 0)</param>
        /// <param name="limit">Used for pagination, determines the maximum number of results to return. (optional, default to 20)</param>
        /// <returns>ApiResponse of List&lt;Message&gt;</returns>
        public OpenapiGenerator.MirthConnect311.Client.ApiResponse<List<Message>> GetMessages1WithHttpInfo(string channelId, MessageFilter messageFilter, bool? includeContent = default(bool?), int? offset = default(int?), int? limit = default(int?))
        {
            // verify the required parameter 'channelId' is set
            if (channelId == null)
            {
                throw new OpenapiGenerator.MirthConnect311.Client.ApiException(400, "Missing required parameter 'channelId' when calling MessagesApi->GetMessages1");
            }

            // verify the required parameter 'messageFilter' is set
            if (messageFilter == null)
            {
                throw new OpenapiGenerator.MirthConnect311.Client.ApiException(400, "Missing required parameter 'messageFilter' when calling MessagesApi->GetMessages1");
            }

            OpenapiGenerator.MirthConnect311.Client.RequestOptions localVarRequestOptions = new OpenapiGenerator.MirthConnect311.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/xml",
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/xml",
                "application/json"
            };

            var localVarContentType = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("channelId", OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToString(channelId)); // path parameter
            if (includeContent != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "includeContent", includeContent));
            }
            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            localVarRequestOptions.Data = messageFilter;

            // authentication (cookieAuth) required
            // cookie parameter support
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("JSESSIONID")))
            {
                localVarRequestOptions.Cookies.Add(new Cookie("JSESSIONID", this.Configuration.GetApiKeyWithPrefix("JSESSIONID")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<List<Message>>("/channels/{channelId}/messages/_search", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetMessages1", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Search for messages by specific filter criteria. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="messageFilter">The MessageFilter object to use to query messages by.</param>
        /// <param name="includeContent">If true, message content will be returned with the results. (optional, default to false)</param>
        /// <param name="offset">Used for pagination, determines where to start in the search results. (optional, default to 0)</param>
        /// <param name="limit">Used for pagination, determines the maximum number of results to return. (optional, default to 20)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;Message&gt;</returns>
        public async System.Threading.Tasks.Task<List<Message>> GetMessages1Async(string channelId, MessageFilter messageFilter, bool? includeContent = default(bool?), int? offset = default(int?), int? limit = default(int?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            OpenapiGenerator.MirthConnect311.Client.ApiResponse<List<Message>> localVarResponse = await GetMessages1WithHttpInfoAsync(channelId, messageFilter, includeContent, offset, limit, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Search for messages by specific filter criteria. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="messageFilter">The MessageFilter object to use to query messages by.</param>
        /// <param name="includeContent">If true, message content will be returned with the results. (optional, default to false)</param>
        /// <param name="offset">Used for pagination, determines where to start in the search results. (optional, default to 0)</param>
        /// <param name="limit">Used for pagination, determines the maximum number of results to return. (optional, default to 20)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;Message&gt;)</returns>
        public async System.Threading.Tasks.Task<OpenapiGenerator.MirthConnect311.Client.ApiResponse<List<Message>>> GetMessages1WithHttpInfoAsync(string channelId, MessageFilter messageFilter, bool? includeContent = default(bool?), int? offset = default(int?), int? limit = default(int?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'channelId' is set
            if (channelId == null)
            {
                throw new OpenapiGenerator.MirthConnect311.Client.ApiException(400, "Missing required parameter 'channelId' when calling MessagesApi->GetMessages1");
            }

            // verify the required parameter 'messageFilter' is set
            if (messageFilter == null)
            {
                throw new OpenapiGenerator.MirthConnect311.Client.ApiException(400, "Missing required parameter 'messageFilter' when calling MessagesApi->GetMessages1");
            }


            OpenapiGenerator.MirthConnect311.Client.RequestOptions localVarRequestOptions = new OpenapiGenerator.MirthConnect311.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/xml", 
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/xml",
                "application/json"
            };

            var localVarContentType = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("channelId", OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToString(channelId)); // path parameter
            if (includeContent != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "includeContent", includeContent));
            }
            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            localVarRequestOptions.Data = messageFilter;

            // authentication (cookieAuth) required
            // cookie parameter support
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("JSESSIONID")))
            {
                localVarRequestOptions.Cookies.Add(new Cookie("JSESSIONID", this.Configuration.GetApiKeyWithPrefix("JSESSIONID")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<List<Message>>("/channels/{channelId}/messages/_search", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetMessages1", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Imports a Message object into a channel. The message will not actually be processed through the channel, only imported. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="message">The Message object to import.</param>
        /// <returns></returns>
        public void ImportMessage(string channelId, Message message)
        {
            ImportMessageWithHttpInfo(channelId, message);
        }

        /// <summary>
        /// Imports a Message object into a channel. The message will not actually be processed through the channel, only imported. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="message">The Message object to import.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public OpenapiGenerator.MirthConnect311.Client.ApiResponse<Object> ImportMessageWithHttpInfo(string channelId, Message message)
        {
            // verify the required parameter 'channelId' is set
            if (channelId == null)
            {
                throw new OpenapiGenerator.MirthConnect311.Client.ApiException(400, "Missing required parameter 'channelId' when calling MessagesApi->ImportMessage");
            }

            // verify the required parameter 'message' is set
            if (message == null)
            {
                throw new OpenapiGenerator.MirthConnect311.Client.ApiException(400, "Missing required parameter 'message' when calling MessagesApi->ImportMessage");
            }

            OpenapiGenerator.MirthConnect311.Client.RequestOptions localVarRequestOptions = new OpenapiGenerator.MirthConnect311.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/xml",
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/xml",
                "application/json"
            };

            var localVarContentType = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("channelId", OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToString(channelId)); // path parameter
            localVarRequestOptions.Data = message;

            // authentication (cookieAuth) required
            // cookie parameter support
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("JSESSIONID")))
            {
                localVarRequestOptions.Cookies.Add(new Cookie("JSESSIONID", this.Configuration.GetApiKeyWithPrefix("JSESSIONID")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<Object>("/channels/{channelId}/messages/_import", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ImportMessage", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Imports a Message object into a channel. The message will not actually be processed through the channel, only imported. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="message">The Message object to import.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task ImportMessageAsync(string channelId, Message message, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await ImportMessageWithHttpInfoAsync(channelId, message, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Imports a Message object into a channel. The message will not actually be processed through the channel, only imported. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="message">The Message object to import.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<OpenapiGenerator.MirthConnect311.Client.ApiResponse<Object>> ImportMessageWithHttpInfoAsync(string channelId, Message message, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'channelId' is set
            if (channelId == null)
            {
                throw new OpenapiGenerator.MirthConnect311.Client.ApiException(400, "Missing required parameter 'channelId' when calling MessagesApi->ImportMessage");
            }

            // verify the required parameter 'message' is set
            if (message == null)
            {
                throw new OpenapiGenerator.MirthConnect311.Client.ApiException(400, "Missing required parameter 'message' when calling MessagesApi->ImportMessage");
            }


            OpenapiGenerator.MirthConnect311.Client.RequestOptions localVarRequestOptions = new OpenapiGenerator.MirthConnect311.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/xml", 
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/xml",
                "application/json"
            };

            var localVarContentType = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("channelId", OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToString(channelId)); // path parameter
            localVarRequestOptions.Data = message;

            // authentication (cookieAuth) required
            // cookie parameter support
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("JSESSIONID")))
            {
                localVarRequestOptions.Cookies.Add(new Cookie("JSESSIONID", this.Configuration.GetApiKeyWithPrefix("JSESSIONID")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<Object>("/channels/{channelId}/messages/_import", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ImportMessage", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Imports messages into a channel from a path accessible by the server. The messages will not actually be processed through the channel, only imported. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="body">The directory path on the server side to import messages from.</param>
        /// <param name="includeSubfolders">If true, sub-folders will also be scanned recursively for messages. (optional, default to false)</param>
        /// <returns>MessageImportResult</returns>
        public MessageImportResult ImportMessagesServer(string channelId, string body, bool? includeSubfolders = default(bool?))
        {
            OpenapiGenerator.MirthConnect311.Client.ApiResponse<MessageImportResult> localVarResponse = ImportMessagesServerWithHttpInfo(channelId, body, includeSubfolders);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Imports messages into a channel from a path accessible by the server. The messages will not actually be processed through the channel, only imported. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="body">The directory path on the server side to import messages from.</param>
        /// <param name="includeSubfolders">If true, sub-folders will also be scanned recursively for messages. (optional, default to false)</param>
        /// <returns>ApiResponse of MessageImportResult</returns>
        public OpenapiGenerator.MirthConnect311.Client.ApiResponse<MessageImportResult> ImportMessagesServerWithHttpInfo(string channelId, string body, bool? includeSubfolders = default(bool?))
        {
            // verify the required parameter 'channelId' is set
            if (channelId == null)
            {
                throw new OpenapiGenerator.MirthConnect311.Client.ApiException(400, "Missing required parameter 'channelId' when calling MessagesApi->ImportMessagesServer");
            }

            // verify the required parameter 'body' is set
            if (body == null)
            {
                throw new OpenapiGenerator.MirthConnect311.Client.ApiException(400, "Missing required parameter 'body' when calling MessagesApi->ImportMessagesServer");
            }

            OpenapiGenerator.MirthConnect311.Client.RequestOptions localVarRequestOptions = new OpenapiGenerator.MirthConnect311.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "text/plain"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/xml",
                "application/json"
            };

            var localVarContentType = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("channelId", OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToString(channelId)); // path parameter
            if (includeSubfolders != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "includeSubfolders", includeSubfolders));
            }
            localVarRequestOptions.Data = body;

            // authentication (cookieAuth) required
            // cookie parameter support
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("JSESSIONID")))
            {
                localVarRequestOptions.Cookies.Add(new Cookie("JSESSIONID", this.Configuration.GetApiKeyWithPrefix("JSESSIONID")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<MessageImportResult>("/channels/{channelId}/messages/_importFromPath", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ImportMessagesServer", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Imports messages into a channel from a path accessible by the server. The messages will not actually be processed through the channel, only imported. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="body">The directory path on the server side to import messages from.</param>
        /// <param name="includeSubfolders">If true, sub-folders will also be scanned recursively for messages. (optional, default to false)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of MessageImportResult</returns>
        public async System.Threading.Tasks.Task<MessageImportResult> ImportMessagesServerAsync(string channelId, string body, bool? includeSubfolders = default(bool?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            OpenapiGenerator.MirthConnect311.Client.ApiResponse<MessageImportResult> localVarResponse = await ImportMessagesServerWithHttpInfoAsync(channelId, body, includeSubfolders, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Imports messages into a channel from a path accessible by the server. The messages will not actually be processed through the channel, only imported. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="body">The directory path on the server side to import messages from.</param>
        /// <param name="includeSubfolders">If true, sub-folders will also be scanned recursively for messages. (optional, default to false)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (MessageImportResult)</returns>
        public async System.Threading.Tasks.Task<OpenapiGenerator.MirthConnect311.Client.ApiResponse<MessageImportResult>> ImportMessagesServerWithHttpInfoAsync(string channelId, string body, bool? includeSubfolders = default(bool?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'channelId' is set
            if (channelId == null)
            {
                throw new OpenapiGenerator.MirthConnect311.Client.ApiException(400, "Missing required parameter 'channelId' when calling MessagesApi->ImportMessagesServer");
            }

            // verify the required parameter 'body' is set
            if (body == null)
            {
                throw new OpenapiGenerator.MirthConnect311.Client.ApiException(400, "Missing required parameter 'body' when calling MessagesApi->ImportMessagesServer");
            }


            OpenapiGenerator.MirthConnect311.Client.RequestOptions localVarRequestOptions = new OpenapiGenerator.MirthConnect311.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "text/plain"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/xml",
                "application/json"
            };

            var localVarContentType = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("channelId", OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToString(channelId)); // path parameter
            if (includeSubfolders != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "includeSubfolders", includeSubfolders));
            }
            localVarRequestOptions.Data = body;

            // authentication (cookieAuth) required
            // cookie parameter support
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("JSESSIONID")))
            {
                localVarRequestOptions.Cookies.Add(new Cookie("JSESSIONID", this.Configuration.GetApiKeyWithPrefix("JSESSIONID")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<MessageImportResult>("/channels/{channelId}/messages/_importFromPath", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ImportMessagesServer", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Processes a new message through a channel. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="body">The raw message data to process.</param>
        /// <param name="destinationMetaDataId">Indicates which destinations to send the message to. (optional)</param>
        /// <param name="sourceMapEntry">These entries will be injected into the source map for the message. Value should be in the format: key&#x3D;value (optional)</param>
        /// <param name="overwrite">If true and a valid original message ID is given, this message will overwrite the existing one. (optional)</param>
        /// <param name="imported">If true, marks this message as being imported. If the message is overwriting an existing one, then statistics will not be decremented. (optional)</param>
        /// <param name="originalMessageId">The original message ID this message is associated with. (optional)</param>
        /// <returns>long</returns>
        public long ProcessMessage(string channelId, string body, List<int> destinationMetaDataId = default(List<int>), List<string> sourceMapEntry = default(List<string>), bool? overwrite = default(bool?), bool? imported = default(bool?), long? originalMessageId = default(long?))
        {
            OpenapiGenerator.MirthConnect311.Client.ApiResponse<long> localVarResponse = ProcessMessageWithHttpInfo(channelId, body, destinationMetaDataId, sourceMapEntry, overwrite, imported, originalMessageId);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Processes a new message through a channel. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="body">The raw message data to process.</param>
        /// <param name="destinationMetaDataId">Indicates which destinations to send the message to. (optional)</param>
        /// <param name="sourceMapEntry">These entries will be injected into the source map for the message. Value should be in the format: key&#x3D;value (optional)</param>
        /// <param name="overwrite">If true and a valid original message ID is given, this message will overwrite the existing one. (optional)</param>
        /// <param name="imported">If true, marks this message as being imported. If the message is overwriting an existing one, then statistics will not be decremented. (optional)</param>
        /// <param name="originalMessageId">The original message ID this message is associated with. (optional)</param>
        /// <returns>ApiResponse of long</returns>
        public OpenapiGenerator.MirthConnect311.Client.ApiResponse<long> ProcessMessageWithHttpInfo(string channelId, string body, List<int> destinationMetaDataId = default(List<int>), List<string> sourceMapEntry = default(List<string>), bool? overwrite = default(bool?), bool? imported = default(bool?), long? originalMessageId = default(long?))
        {
            // verify the required parameter 'channelId' is set
            if (channelId == null)
            {
                throw new OpenapiGenerator.MirthConnect311.Client.ApiException(400, "Missing required parameter 'channelId' when calling MessagesApi->ProcessMessage");
            }

            // verify the required parameter 'body' is set
            if (body == null)
            {
                throw new OpenapiGenerator.MirthConnect311.Client.ApiException(400, "Missing required parameter 'body' when calling MessagesApi->ProcessMessage");
            }

            OpenapiGenerator.MirthConnect311.Client.RequestOptions localVarRequestOptions = new OpenapiGenerator.MirthConnect311.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "text/plain"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/xml",
                "application/json"
            };

            var localVarContentType = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("channelId", OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToString(channelId)); // path parameter
            if (destinationMetaDataId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "destinationMetaDataId", destinationMetaDataId));
            }
            if (sourceMapEntry != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "sourceMapEntry", sourceMapEntry));
            }
            if (overwrite != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "overwrite", overwrite));
            }
            if (imported != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "imported", imported));
            }
            if (originalMessageId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "originalMessageId", originalMessageId));
            }
            localVarRequestOptions.Data = body;

            // authentication (cookieAuth) required
            // cookie parameter support
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("JSESSIONID")))
            {
                localVarRequestOptions.Cookies.Add(new Cookie("JSESSIONID", this.Configuration.GetApiKeyWithPrefix("JSESSIONID")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<long>("/channels/{channelId}/messages", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ProcessMessage", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Processes a new message through a channel. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="body">The raw message data to process.</param>
        /// <param name="destinationMetaDataId">Indicates which destinations to send the message to. (optional)</param>
        /// <param name="sourceMapEntry">These entries will be injected into the source map for the message. Value should be in the format: key&#x3D;value (optional)</param>
        /// <param name="overwrite">If true and a valid original message ID is given, this message will overwrite the existing one. (optional)</param>
        /// <param name="imported">If true, marks this message as being imported. If the message is overwriting an existing one, then statistics will not be decremented. (optional)</param>
        /// <param name="originalMessageId">The original message ID this message is associated with. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of long</returns>
        public async System.Threading.Tasks.Task<long> ProcessMessageAsync(string channelId, string body, List<int> destinationMetaDataId = default(List<int>), List<string> sourceMapEntry = default(List<string>), bool? overwrite = default(bool?), bool? imported = default(bool?), long? originalMessageId = default(long?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            OpenapiGenerator.MirthConnect311.Client.ApiResponse<long> localVarResponse = await ProcessMessageWithHttpInfoAsync(channelId, body, destinationMetaDataId, sourceMapEntry, overwrite, imported, originalMessageId, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Processes a new message through a channel. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="body">The raw message data to process.</param>
        /// <param name="destinationMetaDataId">Indicates which destinations to send the message to. (optional)</param>
        /// <param name="sourceMapEntry">These entries will be injected into the source map for the message. Value should be in the format: key&#x3D;value (optional)</param>
        /// <param name="overwrite">If true and a valid original message ID is given, this message will overwrite the existing one. (optional)</param>
        /// <param name="imported">If true, marks this message as being imported. If the message is overwriting an existing one, then statistics will not be decremented. (optional)</param>
        /// <param name="originalMessageId">The original message ID this message is associated with. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (long)</returns>
        public async System.Threading.Tasks.Task<OpenapiGenerator.MirthConnect311.Client.ApiResponse<long>> ProcessMessageWithHttpInfoAsync(string channelId, string body, List<int> destinationMetaDataId = default(List<int>), List<string> sourceMapEntry = default(List<string>), bool? overwrite = default(bool?), bool? imported = default(bool?), long? originalMessageId = default(long?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'channelId' is set
            if (channelId == null)
            {
                throw new OpenapiGenerator.MirthConnect311.Client.ApiException(400, "Missing required parameter 'channelId' when calling MessagesApi->ProcessMessage");
            }

            // verify the required parameter 'body' is set
            if (body == null)
            {
                throw new OpenapiGenerator.MirthConnect311.Client.ApiException(400, "Missing required parameter 'body' when calling MessagesApi->ProcessMessage");
            }


            OpenapiGenerator.MirthConnect311.Client.RequestOptions localVarRequestOptions = new OpenapiGenerator.MirthConnect311.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "text/plain"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/xml",
                "application/json"
            };

            var localVarContentType = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("channelId", OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToString(channelId)); // path parameter
            if (destinationMetaDataId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "destinationMetaDataId", destinationMetaDataId));
            }
            if (sourceMapEntry != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "sourceMapEntry", sourceMapEntry));
            }
            if (overwrite != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "overwrite", overwrite));
            }
            if (imported != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "imported", imported));
            }
            if (originalMessageId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "originalMessageId", originalMessageId));
            }
            localVarRequestOptions.Data = body;

            // authentication (cookieAuth) required
            // cookie parameter support
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("JSESSIONID")))
            {
                localVarRequestOptions.Cookies.Add(new Cookie("JSESSIONID", this.Configuration.GetApiKeyWithPrefix("JSESSIONID")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<long>("/channels/{channelId}/messages", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ProcessMessage", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Processes a new message through a channel, using the RawMessage object. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="rawMessage">The RawMessage object to process.</param>
        /// <returns>long</returns>
        public long ProcessMessage1(string channelId, RawMessage rawMessage)
        {
            OpenapiGenerator.MirthConnect311.Client.ApiResponse<long> localVarResponse = ProcessMessage1WithHttpInfo(channelId, rawMessage);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Processes a new message through a channel, using the RawMessage object. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="rawMessage">The RawMessage object to process.</param>
        /// <returns>ApiResponse of long</returns>
        public OpenapiGenerator.MirthConnect311.Client.ApiResponse<long> ProcessMessage1WithHttpInfo(string channelId, RawMessage rawMessage)
        {
            // verify the required parameter 'channelId' is set
            if (channelId == null)
            {
                throw new OpenapiGenerator.MirthConnect311.Client.ApiException(400, "Missing required parameter 'channelId' when calling MessagesApi->ProcessMessage1");
            }

            // verify the required parameter 'rawMessage' is set
            if (rawMessage == null)
            {
                throw new OpenapiGenerator.MirthConnect311.Client.ApiException(400, "Missing required parameter 'rawMessage' when calling MessagesApi->ProcessMessage1");
            }

            OpenapiGenerator.MirthConnect311.Client.RequestOptions localVarRequestOptions = new OpenapiGenerator.MirthConnect311.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/xml",
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/xml",
                "application/json"
            };

            var localVarContentType = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("channelId", OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToString(channelId)); // path parameter
            localVarRequestOptions.Data = rawMessage;

            // authentication (cookieAuth) required
            // cookie parameter support
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("JSESSIONID")))
            {
                localVarRequestOptions.Cookies.Add(new Cookie("JSESSIONID", this.Configuration.GetApiKeyWithPrefix("JSESSIONID")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<long>("/channels/{channelId}/messagesWithObj", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ProcessMessage1", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Processes a new message through a channel, using the RawMessage object. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="rawMessage">The RawMessage object to process.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of long</returns>
        public async System.Threading.Tasks.Task<long> ProcessMessage1Async(string channelId, RawMessage rawMessage, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            OpenapiGenerator.MirthConnect311.Client.ApiResponse<long> localVarResponse = await ProcessMessage1WithHttpInfoAsync(channelId, rawMessage, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Processes a new message through a channel, using the RawMessage object. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="rawMessage">The RawMessage object to process.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (long)</returns>
        public async System.Threading.Tasks.Task<OpenapiGenerator.MirthConnect311.Client.ApiResponse<long>> ProcessMessage1WithHttpInfoAsync(string channelId, RawMessage rawMessage, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'channelId' is set
            if (channelId == null)
            {
                throw new OpenapiGenerator.MirthConnect311.Client.ApiException(400, "Missing required parameter 'channelId' when calling MessagesApi->ProcessMessage1");
            }

            // verify the required parameter 'rawMessage' is set
            if (rawMessage == null)
            {
                throw new OpenapiGenerator.MirthConnect311.Client.ApiException(400, "Missing required parameter 'rawMessage' when calling MessagesApi->ProcessMessage1");
            }


            OpenapiGenerator.MirthConnect311.Client.RequestOptions localVarRequestOptions = new OpenapiGenerator.MirthConnect311.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/xml", 
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/xml",
                "application/json"
            };

            var localVarContentType = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("channelId", OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToString(channelId)); // path parameter
            localVarRequestOptions.Data = rawMessage;

            // authentication (cookieAuth) required
            // cookie parameter support
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("JSESSIONID")))
            {
                localVarRequestOptions.Cookies.Add(new Cookie("JSESSIONID", this.Configuration.GetApiKeyWithPrefix("JSESSIONID")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<long>("/channels/{channelId}/messagesWithObj", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ProcessMessage1", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Removes all messages for the specified channel. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="restartRunningChannels">If true, currently running channels will be stopped and restarted as part of the remove process. Otherwise, currently running channels will not be included. (optional, default to false)</param>
        /// <param name="clearStatistics">If true, message statistics will also be cleared. (optional, default to true)</param>
        /// <returns></returns>
        public void RemoveAllMessages(string channelId, bool? restartRunningChannels = default(bool?), bool? clearStatistics = default(bool?))
        {
            RemoveAllMessagesWithHttpInfo(channelId, restartRunningChannels, clearStatistics);
        }

        /// <summary>
        /// Removes all messages for the specified channel. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="restartRunningChannels">If true, currently running channels will be stopped and restarted as part of the remove process. Otherwise, currently running channels will not be included. (optional, default to false)</param>
        /// <param name="clearStatistics">If true, message statistics will also be cleared. (optional, default to true)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public OpenapiGenerator.MirthConnect311.Client.ApiResponse<Object> RemoveAllMessagesWithHttpInfo(string channelId, bool? restartRunningChannels = default(bool?), bool? clearStatistics = default(bool?))
        {
            // verify the required parameter 'channelId' is set
            if (channelId == null)
            {
                throw new OpenapiGenerator.MirthConnect311.Client.ApiException(400, "Missing required parameter 'channelId' when calling MessagesApi->RemoveAllMessages");
            }

            OpenapiGenerator.MirthConnect311.Client.RequestOptions localVarRequestOptions = new OpenapiGenerator.MirthConnect311.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/xml",
                "application/json"
            };

            var localVarContentType = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("channelId", OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToString(channelId)); // path parameter
            if (restartRunningChannels != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "restartRunningChannels", restartRunningChannels));
            }
            if (clearStatistics != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "clearStatistics", clearStatistics));
            }

            // authentication (cookieAuth) required
            // cookie parameter support
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("JSESSIONID")))
            {
                localVarRequestOptions.Cookies.Add(new Cookie("JSESSIONID", this.Configuration.GetApiKeyWithPrefix("JSESSIONID")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Delete<Object>("/channels/{channelId}/messages/_removeAll", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RemoveAllMessages", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Removes all messages for the specified channel. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="restartRunningChannels">If true, currently running channels will be stopped and restarted as part of the remove process. Otherwise, currently running channels will not be included. (optional, default to false)</param>
        /// <param name="clearStatistics">If true, message statistics will also be cleared. (optional, default to true)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RemoveAllMessagesAsync(string channelId, bool? restartRunningChannels = default(bool?), bool? clearStatistics = default(bool?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await RemoveAllMessagesWithHttpInfoAsync(channelId, restartRunningChannels, clearStatistics, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Removes all messages for the specified channel. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="restartRunningChannels">If true, currently running channels will be stopped and restarted as part of the remove process. Otherwise, currently running channels will not be included. (optional, default to false)</param>
        /// <param name="clearStatistics">If true, message statistics will also be cleared. (optional, default to true)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<OpenapiGenerator.MirthConnect311.Client.ApiResponse<Object>> RemoveAllMessagesWithHttpInfoAsync(string channelId, bool? restartRunningChannels = default(bool?), bool? clearStatistics = default(bool?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'channelId' is set
            if (channelId == null)
            {
                throw new OpenapiGenerator.MirthConnect311.Client.ApiException(400, "Missing required parameter 'channelId' when calling MessagesApi->RemoveAllMessages");
            }


            OpenapiGenerator.MirthConnect311.Client.RequestOptions localVarRequestOptions = new OpenapiGenerator.MirthConnect311.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/xml",
                "application/json"
            };

            var localVarContentType = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("channelId", OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToString(channelId)); // path parameter
            if (restartRunningChannels != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "restartRunningChannels", restartRunningChannels));
            }
            if (clearStatistics != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "clearStatistics", clearStatistics));
            }

            // authentication (cookieAuth) required
            // cookie parameter support
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("JSESSIONID")))
            {
                localVarRequestOptions.Cookies.Add(new Cookie("JSESSIONID", this.Configuration.GetApiKeyWithPrefix("JSESSIONID")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.DeleteAsync<Object>("/channels/{channelId}/messages/_removeAll", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RemoveAllMessages", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Removes all messages for multiple specified channels. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The IDs of the channels.</param>
        /// <param name="restartRunningChannels">If true, currently running channels will be stopped and restarted as part of the remove process. Otherwise, currently running channels will not be included. (optional, default to false)</param>
        /// <param name="clearStatistics">If true, message statistics will also be cleared. (optional, default to true)</param>
        /// <returns></returns>
        public void RemoveAllMessages1(List<string> channelId, bool? restartRunningChannels = default(bool?), bool? clearStatistics = default(bool?))
        {
            RemoveAllMessages1WithHttpInfo(channelId, restartRunningChannels, clearStatistics);
        }

        /// <summary>
        /// Removes all messages for multiple specified channels. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The IDs of the channels.</param>
        /// <param name="restartRunningChannels">If true, currently running channels will be stopped and restarted as part of the remove process. Otherwise, currently running channels will not be included. (optional, default to false)</param>
        /// <param name="clearStatistics">If true, message statistics will also be cleared. (optional, default to true)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public OpenapiGenerator.MirthConnect311.Client.ApiResponse<Object> RemoveAllMessages1WithHttpInfo(List<string> channelId, bool? restartRunningChannels = default(bool?), bool? clearStatistics = default(bool?))
        {
            // verify the required parameter 'channelId' is set
            if (channelId == null)
            {
                throw new OpenapiGenerator.MirthConnect311.Client.ApiException(400, "Missing required parameter 'channelId' when calling MessagesApi->RemoveAllMessages1");
            }

            OpenapiGenerator.MirthConnect311.Client.RequestOptions localVarRequestOptions = new OpenapiGenerator.MirthConnect311.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/xml",
                "application/json"
            };

            var localVarContentType = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "channelId", channelId));
            if (restartRunningChannels != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "restartRunningChannels", restartRunningChannels));
            }
            if (clearStatistics != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "clearStatistics", clearStatistics));
            }

            // authentication (cookieAuth) required
            // cookie parameter support
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("JSESSIONID")))
            {
                localVarRequestOptions.Cookies.Add(new Cookie("JSESSIONID", this.Configuration.GetApiKeyWithPrefix("JSESSIONID")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Delete<Object>("/channels/_removeAllMessages", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RemoveAllMessages1", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Removes all messages for multiple specified channels. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The IDs of the channels.</param>
        /// <param name="restartRunningChannels">If true, currently running channels will be stopped and restarted as part of the remove process. Otherwise, currently running channels will not be included. (optional, default to false)</param>
        /// <param name="clearStatistics">If true, message statistics will also be cleared. (optional, default to true)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RemoveAllMessages1Async(List<string> channelId, bool? restartRunningChannels = default(bool?), bool? clearStatistics = default(bool?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await RemoveAllMessages1WithHttpInfoAsync(channelId, restartRunningChannels, clearStatistics, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Removes all messages for multiple specified channels. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The IDs of the channels.</param>
        /// <param name="restartRunningChannels">If true, currently running channels will be stopped and restarted as part of the remove process. Otherwise, currently running channels will not be included. (optional, default to false)</param>
        /// <param name="clearStatistics">If true, message statistics will also be cleared. (optional, default to true)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<OpenapiGenerator.MirthConnect311.Client.ApiResponse<Object>> RemoveAllMessages1WithHttpInfoAsync(List<string> channelId, bool? restartRunningChannels = default(bool?), bool? clearStatistics = default(bool?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'channelId' is set
            if (channelId == null)
            {
                throw new OpenapiGenerator.MirthConnect311.Client.ApiException(400, "Missing required parameter 'channelId' when calling MessagesApi->RemoveAllMessages1");
            }


            OpenapiGenerator.MirthConnect311.Client.RequestOptions localVarRequestOptions = new OpenapiGenerator.MirthConnect311.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/xml",
                "application/json"
            };

            var localVarContentType = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "channelId", channelId));
            if (restartRunningChannels != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "restartRunningChannels", restartRunningChannels));
            }
            if (clearStatistics != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "clearStatistics", clearStatistics));
            }

            // authentication (cookieAuth) required
            // cookie parameter support
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("JSESSIONID")))
            {
                localVarRequestOptions.Cookies.Add(new Cookie("JSESSIONID", this.Configuration.GetApiKeyWithPrefix("JSESSIONID")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.DeleteAsync<Object>("/channels/_removeAllMessages", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RemoveAllMessages1", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Removes all messages for multiple specified channels. This is a POST request alternative to DELETE /_removeAllMessages that may be used when there are too many channel IDs to include in the query parameters. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="requestBody">The IDs of the channels.</param>
        /// <param name="restartRunningChannels">If true, currently running channels will be stopped and restarted as part of the remove process. Otherwise, currently running channels will not be included. (optional, default to false)</param>
        /// <param name="clearStatistics">If true, message statistics will also be cleared. (optional, default to true)</param>
        /// <returns></returns>
        public void RemoveAllMessagesPost(List<string> requestBody, bool? restartRunningChannels = default(bool?), bool? clearStatistics = default(bool?))
        {
            RemoveAllMessagesPostWithHttpInfo(requestBody, restartRunningChannels, clearStatistics);
        }

        /// <summary>
        /// Removes all messages for multiple specified channels. This is a POST request alternative to DELETE /_removeAllMessages that may be used when there are too many channel IDs to include in the query parameters. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="requestBody">The IDs of the channels.</param>
        /// <param name="restartRunningChannels">If true, currently running channels will be stopped and restarted as part of the remove process. Otherwise, currently running channels will not be included. (optional, default to false)</param>
        /// <param name="clearStatistics">If true, message statistics will also be cleared. (optional, default to true)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public OpenapiGenerator.MirthConnect311.Client.ApiResponse<Object> RemoveAllMessagesPostWithHttpInfo(List<string> requestBody, bool? restartRunningChannels = default(bool?), bool? clearStatistics = default(bool?))
        {
            // verify the required parameter 'requestBody' is set
            if (requestBody == null)
            {
                throw new OpenapiGenerator.MirthConnect311.Client.ApiException(400, "Missing required parameter 'requestBody' when calling MessagesApi->RemoveAllMessagesPost");
            }

            OpenapiGenerator.MirthConnect311.Client.RequestOptions localVarRequestOptions = new OpenapiGenerator.MirthConnect311.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/xml",
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/xml",
                "application/json"
            };

            var localVarContentType = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (restartRunningChannels != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "restartRunningChannels", restartRunningChannels));
            }
            if (clearStatistics != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "clearStatistics", clearStatistics));
            }
            localVarRequestOptions.Data = requestBody;

            // authentication (cookieAuth) required
            // cookie parameter support
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("JSESSIONID")))
            {
                localVarRequestOptions.Cookies.Add(new Cookie("JSESSIONID", this.Configuration.GetApiKeyWithPrefix("JSESSIONID")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<Object>("/channels/_removeAllMessagesPost", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RemoveAllMessagesPost", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Removes all messages for multiple specified channels. This is a POST request alternative to DELETE /_removeAllMessages that may be used when there are too many channel IDs to include in the query parameters. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="requestBody">The IDs of the channels.</param>
        /// <param name="restartRunningChannels">If true, currently running channels will be stopped and restarted as part of the remove process. Otherwise, currently running channels will not be included. (optional, default to false)</param>
        /// <param name="clearStatistics">If true, message statistics will also be cleared. (optional, default to true)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RemoveAllMessagesPostAsync(List<string> requestBody, bool? restartRunningChannels = default(bool?), bool? clearStatistics = default(bool?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await RemoveAllMessagesPostWithHttpInfoAsync(requestBody, restartRunningChannels, clearStatistics, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Removes all messages for multiple specified channels. This is a POST request alternative to DELETE /_removeAllMessages that may be used when there are too many channel IDs to include in the query parameters. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="requestBody">The IDs of the channels.</param>
        /// <param name="restartRunningChannels">If true, currently running channels will be stopped and restarted as part of the remove process. Otherwise, currently running channels will not be included. (optional, default to false)</param>
        /// <param name="clearStatistics">If true, message statistics will also be cleared. (optional, default to true)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<OpenapiGenerator.MirthConnect311.Client.ApiResponse<Object>> RemoveAllMessagesPostWithHttpInfoAsync(List<string> requestBody, bool? restartRunningChannels = default(bool?), bool? clearStatistics = default(bool?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'requestBody' is set
            if (requestBody == null)
            {
                throw new OpenapiGenerator.MirthConnect311.Client.ApiException(400, "Missing required parameter 'requestBody' when calling MessagesApi->RemoveAllMessagesPost");
            }


            OpenapiGenerator.MirthConnect311.Client.RequestOptions localVarRequestOptions = new OpenapiGenerator.MirthConnect311.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/xml", 
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/xml",
                "application/json"
            };

            var localVarContentType = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (restartRunningChannels != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "restartRunningChannels", restartRunningChannels));
            }
            if (clearStatistics != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "clearStatistics", clearStatistics));
            }
            localVarRequestOptions.Data = requestBody;

            // authentication (cookieAuth) required
            // cookie parameter support
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("JSESSIONID")))
            {
                localVarRequestOptions.Cookies.Add(new Cookie("JSESSIONID", this.Configuration.GetApiKeyWithPrefix("JSESSIONID")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<Object>("/channels/_removeAllMessagesPost", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RemoveAllMessagesPost", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Remove a single message by ID. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="messageId">The ID of the message.</param>
        /// <param name="metaDataId">If present, only the specific connector message will be removed. If the metadata ID is 0, the entire message will be removed. (optional)</param>
        /// <returns></returns>
        public void RemoveMessage(string channelId, long messageId, int? metaDataId = default(int?))
        {
            RemoveMessageWithHttpInfo(channelId, messageId, metaDataId);
        }

        /// <summary>
        /// Remove a single message by ID. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="messageId">The ID of the message.</param>
        /// <param name="metaDataId">If present, only the specific connector message will be removed. If the metadata ID is 0, the entire message will be removed. (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public OpenapiGenerator.MirthConnect311.Client.ApiResponse<Object> RemoveMessageWithHttpInfo(string channelId, long messageId, int? metaDataId = default(int?))
        {
            // verify the required parameter 'channelId' is set
            if (channelId == null)
            {
                throw new OpenapiGenerator.MirthConnect311.Client.ApiException(400, "Missing required parameter 'channelId' when calling MessagesApi->RemoveMessage");
            }

            OpenapiGenerator.MirthConnect311.Client.RequestOptions localVarRequestOptions = new OpenapiGenerator.MirthConnect311.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/xml",
                "application/json"
            };

            var localVarContentType = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("channelId", OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToString(channelId)); // path parameter
            localVarRequestOptions.PathParameters.Add("messageId", OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToString(messageId)); // path parameter
            if (metaDataId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "metaDataId", metaDataId));
            }

            // authentication (cookieAuth) required
            // cookie parameter support
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("JSESSIONID")))
            {
                localVarRequestOptions.Cookies.Add(new Cookie("JSESSIONID", this.Configuration.GetApiKeyWithPrefix("JSESSIONID")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Delete<Object>("/channels/{channelId}/messages/{messageId}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RemoveMessage", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Remove a single message by ID. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="messageId">The ID of the message.</param>
        /// <param name="metaDataId">If present, only the specific connector message will be removed. If the metadata ID is 0, the entire message will be removed. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RemoveMessageAsync(string channelId, long messageId, int? metaDataId = default(int?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await RemoveMessageWithHttpInfoAsync(channelId, messageId, metaDataId, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Remove a single message by ID. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="messageId">The ID of the message.</param>
        /// <param name="metaDataId">If present, only the specific connector message will be removed. If the metadata ID is 0, the entire message will be removed. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<OpenapiGenerator.MirthConnect311.Client.ApiResponse<Object>> RemoveMessageWithHttpInfoAsync(string channelId, long messageId, int? metaDataId = default(int?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'channelId' is set
            if (channelId == null)
            {
                throw new OpenapiGenerator.MirthConnect311.Client.ApiException(400, "Missing required parameter 'channelId' when calling MessagesApi->RemoveMessage");
            }


            OpenapiGenerator.MirthConnect311.Client.RequestOptions localVarRequestOptions = new OpenapiGenerator.MirthConnect311.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/xml",
                "application/json"
            };

            var localVarContentType = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("channelId", OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToString(channelId)); // path parameter
            localVarRequestOptions.PathParameters.Add("messageId", OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToString(messageId)); // path parameter
            if (metaDataId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "metaDataId", metaDataId));
            }

            // authentication (cookieAuth) required
            // cookie parameter support
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("JSESSIONID")))
            {
                localVarRequestOptions.Cookies.Add(new Cookie("JSESSIONID", this.Configuration.GetApiKeyWithPrefix("JSESSIONID")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.DeleteAsync<Object>("/channels/{channelId}/messages/{messageId}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RemoveMessage", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Remove messages by specific filter criteria. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="messageFilter">The MessageFilter object to use to query messages by.</param>
        /// <returns></returns>
        public void RemoveMessages(string channelId, MessageFilter messageFilter)
        {
            RemoveMessagesWithHttpInfo(channelId, messageFilter);
        }

        /// <summary>
        /// Remove messages by specific filter criteria. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="messageFilter">The MessageFilter object to use to query messages by.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public OpenapiGenerator.MirthConnect311.Client.ApiResponse<Object> RemoveMessagesWithHttpInfo(string channelId, MessageFilter messageFilter)
        {
            // verify the required parameter 'channelId' is set
            if (channelId == null)
            {
                throw new OpenapiGenerator.MirthConnect311.Client.ApiException(400, "Missing required parameter 'channelId' when calling MessagesApi->RemoveMessages");
            }

            // verify the required parameter 'messageFilter' is set
            if (messageFilter == null)
            {
                throw new OpenapiGenerator.MirthConnect311.Client.ApiException(400, "Missing required parameter 'messageFilter' when calling MessagesApi->RemoveMessages");
            }

            OpenapiGenerator.MirthConnect311.Client.RequestOptions localVarRequestOptions = new OpenapiGenerator.MirthConnect311.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/xml",
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/xml",
                "application/json"
            };

            var localVarContentType = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("channelId", OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToString(channelId)); // path parameter
            localVarRequestOptions.Data = messageFilter;

            // authentication (cookieAuth) required
            // cookie parameter support
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("JSESSIONID")))
            {
                localVarRequestOptions.Cookies.Add(new Cookie("JSESSIONID", this.Configuration.GetApiKeyWithPrefix("JSESSIONID")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<Object>("/channels/{channelId}/messages/_remove", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RemoveMessages", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Remove messages by specific filter criteria. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="messageFilter">The MessageFilter object to use to query messages by.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RemoveMessagesAsync(string channelId, MessageFilter messageFilter, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await RemoveMessagesWithHttpInfoAsync(channelId, messageFilter, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Remove messages by specific filter criteria. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="messageFilter">The MessageFilter object to use to query messages by.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<OpenapiGenerator.MirthConnect311.Client.ApiResponse<Object>> RemoveMessagesWithHttpInfoAsync(string channelId, MessageFilter messageFilter, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'channelId' is set
            if (channelId == null)
            {
                throw new OpenapiGenerator.MirthConnect311.Client.ApiException(400, "Missing required parameter 'channelId' when calling MessagesApi->RemoveMessages");
            }

            // verify the required parameter 'messageFilter' is set
            if (messageFilter == null)
            {
                throw new OpenapiGenerator.MirthConnect311.Client.ApiException(400, "Missing required parameter 'messageFilter' when calling MessagesApi->RemoveMessages");
            }


            OpenapiGenerator.MirthConnect311.Client.RequestOptions localVarRequestOptions = new OpenapiGenerator.MirthConnect311.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/xml", 
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/xml",
                "application/json"
            };

            var localVarContentType = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("channelId", OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToString(channelId)); // path parameter
            localVarRequestOptions.Data = messageFilter;

            // authentication (cookieAuth) required
            // cookie parameter support
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("JSESSIONID")))
            {
                localVarRequestOptions.Cookies.Add(new Cookie("JSESSIONID", this.Configuration.GetApiKeyWithPrefix("JSESSIONID")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<Object>("/channels/{channelId}/messages/_remove", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RemoveMessages", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Remove messages by specific filter criteria. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="minMessageId">The minimum message ID to query. (optional)</param>
        /// <param name="maxMessageId">The maximum message ID to query. (optional)</param>
        /// <param name="minOriginalId">The minimum original message ID to query. Messages that have been reprocessed will retain their original message ID. (optional)</param>
        /// <param name="maxOriginalId">The maximum original message ID to query. Messages that have been reprocessed will retain their original message ID. (optional)</param>
        /// <param name="minImportId">The minimum import message ID to query. Messages that have been imported will retain their original message ID under this value. (optional)</param>
        /// <param name="maxImportId">The maximum import message ID to query. Messages that have been imported will retain their original message ID under this value. (optional)</param>
        /// <param name="startDate">The earliest original received date to query by. Example: 1985-10-26T09:00:00.000-0700 (optional)</param>
        /// <param name="endDate">The latest original received date to query by. Example: 2015-10-21T07:28:00.000-0700 (optional)</param>
        /// <param name="textSearch">Searches all message content for this string. This process could take a long time depending on the amount of message content currently stored. Any message content that was encrypted by this channel will not be searchable. (optional)</param>
        /// <param name="textSearchRegex">If true, text search input will be considered a regular expression pattern to be matched. Only supported by PostgreSQL, MySQL and Oracle databases. (optional)</param>
        /// <param name="status">Determines which message statuses to query by. (optional)</param>
        /// <param name="includedMetaDataId">If present, only connector metadata IDs in this list will be queried. (optional)</param>
        /// <param name="excludedMetaDataId">If present, connector metadata IDs in this list will not be queried. (optional)</param>
        /// <param name="serverId">The server ID associated with messages. (optional)</param>
        /// <param name="rawContentSearch">Searches the raw content of messages. (optional)</param>
        /// <param name="processedRawContentSearch">Searches the processed raw content of messages. (optional)</param>
        /// <param name="transformedContentSearch">Searches the transformed content of messages. (optional)</param>
        /// <param name="encodedContentSearch">Searches the encoded content of messages. (optional)</param>
        /// <param name="sentContentSearch">Searches the sent content of messages. (optional)</param>
        /// <param name="responseContentSearch">Searches the response content of messages. (optional)</param>
        /// <param name="responseTransformedContentSearch">Searches the response transformed content of messages. (optional)</param>
        /// <param name="processedResponseContentSearch">Searches the processed response content of messages. (optional)</param>
        /// <param name="connectorMapContentSearch">Searches the connector map content of messages. (optional)</param>
        /// <param name="channelMapContentSearch">Searches the channel map content of messages. (optional)</param>
        /// <param name="sourceMapContentSearch">Searches the source map content of messages. (optional)</param>
        /// <param name="responseMapContentSearch">Searches the response map content of messages. (optional)</param>
        /// <param name="processingErrorContentSearch">Searches the processing error content of messages. (optional)</param>
        /// <param name="postprocessorErrorContentSearch">Searches the postprocessor error content of messages. (optional)</param>
        /// <param name="responseErrorContentSearch">Searches the response error content of messages. (optional)</param>
        /// <param name="metaDataSearch">Searches a custom metadata column. Value should be in the form: COLUMN_NAME &amp;lt;operator&amp;gt; value, where operator is one of the following: &#x3D;, !&#x3D;, &lt;, &lt;&#x3D;, &gt;, &gt;&#x3D;, CONTAINS, DOES NOT CONTAIN, STARTS WITH, DOES NOT START WITH, ENDS WITH, DOES NOT END WITH (optional)</param>
        /// <param name="metaDataCaseInsensitiveSearch">Searches a custom metadata column, ignoring case. Value should be in the form: COLUMN_NAME &amp;lt;operator&amp;gt; value. (optional)</param>
        /// <param name="textSearchMetaDataColumn">When using a text search, these custom metadata columns will also be searched. (optional)</param>
        /// <param name="minSendAttempts">The minimum number of send attempts for connector messages. (optional)</param>
        /// <param name="maxSendAttempts">The maximum number of send attempts for connector messages. (optional)</param>
        /// <param name="attachment">If true, only messages with attachments are included in the results. (optional)</param>
        /// <param name="error">If true, only messages with errors are included in the results. (optional)</param>
        /// <returns></returns>
        public void RemoveMessages1(string channelId, long? minMessageId = default(long?), long? maxMessageId = default(long?), long? minOriginalId = default(long?), long? maxOriginalId = default(long?), long? minImportId = default(long?), long? maxImportId = default(long?), DateTime? startDate = default(DateTime?), DateTime? endDate = default(DateTime?), string textSearch = default(string), bool? textSearchRegex = default(bool?), List<string> status = default(List<string>), List<int> includedMetaDataId = default(List<int>), List<int> excludedMetaDataId = default(List<int>), string serverId = default(string), List<string> rawContentSearch = default(List<string>), List<string> processedRawContentSearch = default(List<string>), List<string> transformedContentSearch = default(List<string>), List<string> encodedContentSearch = default(List<string>), List<string> sentContentSearch = default(List<string>), List<string> responseContentSearch = default(List<string>), List<string> responseTransformedContentSearch = default(List<string>), List<string> processedResponseContentSearch = default(List<string>), List<string> connectorMapContentSearch = default(List<string>), List<string> channelMapContentSearch = default(List<string>), List<string> sourceMapContentSearch = default(List<string>), List<string> responseMapContentSearch = default(List<string>), List<string> processingErrorContentSearch = default(List<string>), List<string> postprocessorErrorContentSearch = default(List<string>), List<string> responseErrorContentSearch = default(List<string>), List<MetaDataSearch> metaDataSearch = default(List<MetaDataSearch>), List<MetaDataSearch> metaDataCaseInsensitiveSearch = default(List<MetaDataSearch>), List<string> textSearchMetaDataColumn = default(List<string>), int? minSendAttempts = default(int?), int? maxSendAttempts = default(int?), bool? attachment = default(bool?), bool? error = default(bool?))
        {
            RemoveMessages1WithHttpInfo(channelId, minMessageId, maxMessageId, minOriginalId, maxOriginalId, minImportId, maxImportId, startDate, endDate, textSearch, textSearchRegex, status, includedMetaDataId, excludedMetaDataId, serverId, rawContentSearch, processedRawContentSearch, transformedContentSearch, encodedContentSearch, sentContentSearch, responseContentSearch, responseTransformedContentSearch, processedResponseContentSearch, connectorMapContentSearch, channelMapContentSearch, sourceMapContentSearch, responseMapContentSearch, processingErrorContentSearch, postprocessorErrorContentSearch, responseErrorContentSearch, metaDataSearch, metaDataCaseInsensitiveSearch, textSearchMetaDataColumn, minSendAttempts, maxSendAttempts, attachment, error);
        }

        /// <summary>
        /// Remove messages by specific filter criteria. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="minMessageId">The minimum message ID to query. (optional)</param>
        /// <param name="maxMessageId">The maximum message ID to query. (optional)</param>
        /// <param name="minOriginalId">The minimum original message ID to query. Messages that have been reprocessed will retain their original message ID. (optional)</param>
        /// <param name="maxOriginalId">The maximum original message ID to query. Messages that have been reprocessed will retain their original message ID. (optional)</param>
        /// <param name="minImportId">The minimum import message ID to query. Messages that have been imported will retain their original message ID under this value. (optional)</param>
        /// <param name="maxImportId">The maximum import message ID to query. Messages that have been imported will retain their original message ID under this value. (optional)</param>
        /// <param name="startDate">The earliest original received date to query by. Example: 1985-10-26T09:00:00.000-0700 (optional)</param>
        /// <param name="endDate">The latest original received date to query by. Example: 2015-10-21T07:28:00.000-0700 (optional)</param>
        /// <param name="textSearch">Searches all message content for this string. This process could take a long time depending on the amount of message content currently stored. Any message content that was encrypted by this channel will not be searchable. (optional)</param>
        /// <param name="textSearchRegex">If true, text search input will be considered a regular expression pattern to be matched. Only supported by PostgreSQL, MySQL and Oracle databases. (optional)</param>
        /// <param name="status">Determines which message statuses to query by. (optional)</param>
        /// <param name="includedMetaDataId">If present, only connector metadata IDs in this list will be queried. (optional)</param>
        /// <param name="excludedMetaDataId">If present, connector metadata IDs in this list will not be queried. (optional)</param>
        /// <param name="serverId">The server ID associated with messages. (optional)</param>
        /// <param name="rawContentSearch">Searches the raw content of messages. (optional)</param>
        /// <param name="processedRawContentSearch">Searches the processed raw content of messages. (optional)</param>
        /// <param name="transformedContentSearch">Searches the transformed content of messages. (optional)</param>
        /// <param name="encodedContentSearch">Searches the encoded content of messages. (optional)</param>
        /// <param name="sentContentSearch">Searches the sent content of messages. (optional)</param>
        /// <param name="responseContentSearch">Searches the response content of messages. (optional)</param>
        /// <param name="responseTransformedContentSearch">Searches the response transformed content of messages. (optional)</param>
        /// <param name="processedResponseContentSearch">Searches the processed response content of messages. (optional)</param>
        /// <param name="connectorMapContentSearch">Searches the connector map content of messages. (optional)</param>
        /// <param name="channelMapContentSearch">Searches the channel map content of messages. (optional)</param>
        /// <param name="sourceMapContentSearch">Searches the source map content of messages. (optional)</param>
        /// <param name="responseMapContentSearch">Searches the response map content of messages. (optional)</param>
        /// <param name="processingErrorContentSearch">Searches the processing error content of messages. (optional)</param>
        /// <param name="postprocessorErrorContentSearch">Searches the postprocessor error content of messages. (optional)</param>
        /// <param name="responseErrorContentSearch">Searches the response error content of messages. (optional)</param>
        /// <param name="metaDataSearch">Searches a custom metadata column. Value should be in the form: COLUMN_NAME &amp;lt;operator&amp;gt; value, where operator is one of the following: &#x3D;, !&#x3D;, &lt;, &lt;&#x3D;, &gt;, &gt;&#x3D;, CONTAINS, DOES NOT CONTAIN, STARTS WITH, DOES NOT START WITH, ENDS WITH, DOES NOT END WITH (optional)</param>
        /// <param name="metaDataCaseInsensitiveSearch">Searches a custom metadata column, ignoring case. Value should be in the form: COLUMN_NAME &amp;lt;operator&amp;gt; value. (optional)</param>
        /// <param name="textSearchMetaDataColumn">When using a text search, these custom metadata columns will also be searched. (optional)</param>
        /// <param name="minSendAttempts">The minimum number of send attempts for connector messages. (optional)</param>
        /// <param name="maxSendAttempts">The maximum number of send attempts for connector messages. (optional)</param>
        /// <param name="attachment">If true, only messages with attachments are included in the results. (optional)</param>
        /// <param name="error">If true, only messages with errors are included in the results. (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public OpenapiGenerator.MirthConnect311.Client.ApiResponse<Object> RemoveMessages1WithHttpInfo(string channelId, long? minMessageId = default(long?), long? maxMessageId = default(long?), long? minOriginalId = default(long?), long? maxOriginalId = default(long?), long? minImportId = default(long?), long? maxImportId = default(long?), DateTime? startDate = default(DateTime?), DateTime? endDate = default(DateTime?), string textSearch = default(string), bool? textSearchRegex = default(bool?), List<string> status = default(List<string>), List<int> includedMetaDataId = default(List<int>), List<int> excludedMetaDataId = default(List<int>), string serverId = default(string), List<string> rawContentSearch = default(List<string>), List<string> processedRawContentSearch = default(List<string>), List<string> transformedContentSearch = default(List<string>), List<string> encodedContentSearch = default(List<string>), List<string> sentContentSearch = default(List<string>), List<string> responseContentSearch = default(List<string>), List<string> responseTransformedContentSearch = default(List<string>), List<string> processedResponseContentSearch = default(List<string>), List<string> connectorMapContentSearch = default(List<string>), List<string> channelMapContentSearch = default(List<string>), List<string> sourceMapContentSearch = default(List<string>), List<string> responseMapContentSearch = default(List<string>), List<string> processingErrorContentSearch = default(List<string>), List<string> postprocessorErrorContentSearch = default(List<string>), List<string> responseErrorContentSearch = default(List<string>), List<MetaDataSearch> metaDataSearch = default(List<MetaDataSearch>), List<MetaDataSearch> metaDataCaseInsensitiveSearch = default(List<MetaDataSearch>), List<string> textSearchMetaDataColumn = default(List<string>), int? minSendAttempts = default(int?), int? maxSendAttempts = default(int?), bool? attachment = default(bool?), bool? error = default(bool?))
        {
            // verify the required parameter 'channelId' is set
            if (channelId == null)
            {
                throw new OpenapiGenerator.MirthConnect311.Client.ApiException(400, "Missing required parameter 'channelId' when calling MessagesApi->RemoveMessages1");
            }

            OpenapiGenerator.MirthConnect311.Client.RequestOptions localVarRequestOptions = new OpenapiGenerator.MirthConnect311.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/xml",
                "application/json"
            };

            var localVarContentType = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("channelId", OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToString(channelId)); // path parameter
            if (minMessageId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "minMessageId", minMessageId));
            }
            if (maxMessageId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "maxMessageId", maxMessageId));
            }
            if (minOriginalId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "minOriginalId", minOriginalId));
            }
            if (maxOriginalId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "maxOriginalId", maxOriginalId));
            }
            if (minImportId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "minImportId", minImportId));
            }
            if (maxImportId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "maxImportId", maxImportId));
            }
            if (startDate != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "startDate", startDate));
            }
            if (endDate != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "endDate", endDate));
            }
            if (textSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "textSearch", textSearch));
            }
            if (textSearchRegex != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "textSearchRegex", textSearchRegex));
            }
            if (status != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "status", status));
            }
            if (includedMetaDataId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "includedMetaDataId", includedMetaDataId));
            }
            if (excludedMetaDataId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "excludedMetaDataId", excludedMetaDataId));
            }
            if (serverId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "serverId", serverId));
            }
            if (rawContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "rawContentSearch", rawContentSearch));
            }
            if (processedRawContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "processedRawContentSearch", processedRawContentSearch));
            }
            if (transformedContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "transformedContentSearch", transformedContentSearch));
            }
            if (encodedContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "encodedContentSearch", encodedContentSearch));
            }
            if (sentContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "sentContentSearch", sentContentSearch));
            }
            if (responseContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "responseContentSearch", responseContentSearch));
            }
            if (responseTransformedContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "responseTransformedContentSearch", responseTransformedContentSearch));
            }
            if (processedResponseContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "processedResponseContentSearch", processedResponseContentSearch));
            }
            if (connectorMapContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "connectorMapContentSearch", connectorMapContentSearch));
            }
            if (channelMapContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "channelMapContentSearch", channelMapContentSearch));
            }
            if (sourceMapContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "sourceMapContentSearch", sourceMapContentSearch));
            }
            if (responseMapContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "responseMapContentSearch", responseMapContentSearch));
            }
            if (processingErrorContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "processingErrorContentSearch", processingErrorContentSearch));
            }
            if (postprocessorErrorContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "postprocessorErrorContentSearch", postprocessorErrorContentSearch));
            }
            if (responseErrorContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "responseErrorContentSearch", responseErrorContentSearch));
            }
            if (metaDataSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "metaDataSearch", metaDataSearch));
            }
            if (metaDataCaseInsensitiveSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "metaDataCaseInsensitiveSearch", metaDataCaseInsensitiveSearch));
            }
            if (textSearchMetaDataColumn != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "textSearchMetaDataColumn", textSearchMetaDataColumn));
            }
            if (minSendAttempts != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "minSendAttempts", minSendAttempts));
            }
            if (maxSendAttempts != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "maxSendAttempts", maxSendAttempts));
            }
            if (attachment != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "attachment", attachment));
            }
            if (error != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "error", error));
            }

            // authentication (cookieAuth) required
            // cookie parameter support
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("JSESSIONID")))
            {
                localVarRequestOptions.Cookies.Add(new Cookie("JSESSIONID", this.Configuration.GetApiKeyWithPrefix("JSESSIONID")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Delete<Object>("/channels/{channelId}/messages", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RemoveMessages1", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Remove messages by specific filter criteria. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="minMessageId">The minimum message ID to query. (optional)</param>
        /// <param name="maxMessageId">The maximum message ID to query. (optional)</param>
        /// <param name="minOriginalId">The minimum original message ID to query. Messages that have been reprocessed will retain their original message ID. (optional)</param>
        /// <param name="maxOriginalId">The maximum original message ID to query. Messages that have been reprocessed will retain their original message ID. (optional)</param>
        /// <param name="minImportId">The minimum import message ID to query. Messages that have been imported will retain their original message ID under this value. (optional)</param>
        /// <param name="maxImportId">The maximum import message ID to query. Messages that have been imported will retain their original message ID under this value. (optional)</param>
        /// <param name="startDate">The earliest original received date to query by. Example: 1985-10-26T09:00:00.000-0700 (optional)</param>
        /// <param name="endDate">The latest original received date to query by. Example: 2015-10-21T07:28:00.000-0700 (optional)</param>
        /// <param name="textSearch">Searches all message content for this string. This process could take a long time depending on the amount of message content currently stored. Any message content that was encrypted by this channel will not be searchable. (optional)</param>
        /// <param name="textSearchRegex">If true, text search input will be considered a regular expression pattern to be matched. Only supported by PostgreSQL, MySQL and Oracle databases. (optional)</param>
        /// <param name="status">Determines which message statuses to query by. (optional)</param>
        /// <param name="includedMetaDataId">If present, only connector metadata IDs in this list will be queried. (optional)</param>
        /// <param name="excludedMetaDataId">If present, connector metadata IDs in this list will not be queried. (optional)</param>
        /// <param name="serverId">The server ID associated with messages. (optional)</param>
        /// <param name="rawContentSearch">Searches the raw content of messages. (optional)</param>
        /// <param name="processedRawContentSearch">Searches the processed raw content of messages. (optional)</param>
        /// <param name="transformedContentSearch">Searches the transformed content of messages. (optional)</param>
        /// <param name="encodedContentSearch">Searches the encoded content of messages. (optional)</param>
        /// <param name="sentContentSearch">Searches the sent content of messages. (optional)</param>
        /// <param name="responseContentSearch">Searches the response content of messages. (optional)</param>
        /// <param name="responseTransformedContentSearch">Searches the response transformed content of messages. (optional)</param>
        /// <param name="processedResponseContentSearch">Searches the processed response content of messages. (optional)</param>
        /// <param name="connectorMapContentSearch">Searches the connector map content of messages. (optional)</param>
        /// <param name="channelMapContentSearch">Searches the channel map content of messages. (optional)</param>
        /// <param name="sourceMapContentSearch">Searches the source map content of messages. (optional)</param>
        /// <param name="responseMapContentSearch">Searches the response map content of messages. (optional)</param>
        /// <param name="processingErrorContentSearch">Searches the processing error content of messages. (optional)</param>
        /// <param name="postprocessorErrorContentSearch">Searches the postprocessor error content of messages. (optional)</param>
        /// <param name="responseErrorContentSearch">Searches the response error content of messages. (optional)</param>
        /// <param name="metaDataSearch">Searches a custom metadata column. Value should be in the form: COLUMN_NAME &amp;lt;operator&amp;gt; value, where operator is one of the following: &#x3D;, !&#x3D;, &lt;, &lt;&#x3D;, &gt;, &gt;&#x3D;, CONTAINS, DOES NOT CONTAIN, STARTS WITH, DOES NOT START WITH, ENDS WITH, DOES NOT END WITH (optional)</param>
        /// <param name="metaDataCaseInsensitiveSearch">Searches a custom metadata column, ignoring case. Value should be in the form: COLUMN_NAME &amp;lt;operator&amp;gt; value. (optional)</param>
        /// <param name="textSearchMetaDataColumn">When using a text search, these custom metadata columns will also be searched. (optional)</param>
        /// <param name="minSendAttempts">The minimum number of send attempts for connector messages. (optional)</param>
        /// <param name="maxSendAttempts">The maximum number of send attempts for connector messages. (optional)</param>
        /// <param name="attachment">If true, only messages with attachments are included in the results. (optional)</param>
        /// <param name="error">If true, only messages with errors are included in the results. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RemoveMessages1Async(string channelId, long? minMessageId = default(long?), long? maxMessageId = default(long?), long? minOriginalId = default(long?), long? maxOriginalId = default(long?), long? minImportId = default(long?), long? maxImportId = default(long?), DateTime? startDate = default(DateTime?), DateTime? endDate = default(DateTime?), string textSearch = default(string), bool? textSearchRegex = default(bool?), List<string> status = default(List<string>), List<int> includedMetaDataId = default(List<int>), List<int> excludedMetaDataId = default(List<int>), string serverId = default(string), List<string> rawContentSearch = default(List<string>), List<string> processedRawContentSearch = default(List<string>), List<string> transformedContentSearch = default(List<string>), List<string> encodedContentSearch = default(List<string>), List<string> sentContentSearch = default(List<string>), List<string> responseContentSearch = default(List<string>), List<string> responseTransformedContentSearch = default(List<string>), List<string> processedResponseContentSearch = default(List<string>), List<string> connectorMapContentSearch = default(List<string>), List<string> channelMapContentSearch = default(List<string>), List<string> sourceMapContentSearch = default(List<string>), List<string> responseMapContentSearch = default(List<string>), List<string> processingErrorContentSearch = default(List<string>), List<string> postprocessorErrorContentSearch = default(List<string>), List<string> responseErrorContentSearch = default(List<string>), List<MetaDataSearch> metaDataSearch = default(List<MetaDataSearch>), List<MetaDataSearch> metaDataCaseInsensitiveSearch = default(List<MetaDataSearch>), List<string> textSearchMetaDataColumn = default(List<string>), int? minSendAttempts = default(int?), int? maxSendAttempts = default(int?), bool? attachment = default(bool?), bool? error = default(bool?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await RemoveMessages1WithHttpInfoAsync(channelId, minMessageId, maxMessageId, minOriginalId, maxOriginalId, minImportId, maxImportId, startDate, endDate, textSearch, textSearchRegex, status, includedMetaDataId, excludedMetaDataId, serverId, rawContentSearch, processedRawContentSearch, transformedContentSearch, encodedContentSearch, sentContentSearch, responseContentSearch, responseTransformedContentSearch, processedResponseContentSearch, connectorMapContentSearch, channelMapContentSearch, sourceMapContentSearch, responseMapContentSearch, processingErrorContentSearch, postprocessorErrorContentSearch, responseErrorContentSearch, metaDataSearch, metaDataCaseInsensitiveSearch, textSearchMetaDataColumn, minSendAttempts, maxSendAttempts, attachment, error, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Remove messages by specific filter criteria. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="minMessageId">The minimum message ID to query. (optional)</param>
        /// <param name="maxMessageId">The maximum message ID to query. (optional)</param>
        /// <param name="minOriginalId">The minimum original message ID to query. Messages that have been reprocessed will retain their original message ID. (optional)</param>
        /// <param name="maxOriginalId">The maximum original message ID to query. Messages that have been reprocessed will retain their original message ID. (optional)</param>
        /// <param name="minImportId">The minimum import message ID to query. Messages that have been imported will retain their original message ID under this value. (optional)</param>
        /// <param name="maxImportId">The maximum import message ID to query. Messages that have been imported will retain their original message ID under this value. (optional)</param>
        /// <param name="startDate">The earliest original received date to query by. Example: 1985-10-26T09:00:00.000-0700 (optional)</param>
        /// <param name="endDate">The latest original received date to query by. Example: 2015-10-21T07:28:00.000-0700 (optional)</param>
        /// <param name="textSearch">Searches all message content for this string. This process could take a long time depending on the amount of message content currently stored. Any message content that was encrypted by this channel will not be searchable. (optional)</param>
        /// <param name="textSearchRegex">If true, text search input will be considered a regular expression pattern to be matched. Only supported by PostgreSQL, MySQL and Oracle databases. (optional)</param>
        /// <param name="status">Determines which message statuses to query by. (optional)</param>
        /// <param name="includedMetaDataId">If present, only connector metadata IDs in this list will be queried. (optional)</param>
        /// <param name="excludedMetaDataId">If present, connector metadata IDs in this list will not be queried. (optional)</param>
        /// <param name="serverId">The server ID associated with messages. (optional)</param>
        /// <param name="rawContentSearch">Searches the raw content of messages. (optional)</param>
        /// <param name="processedRawContentSearch">Searches the processed raw content of messages. (optional)</param>
        /// <param name="transformedContentSearch">Searches the transformed content of messages. (optional)</param>
        /// <param name="encodedContentSearch">Searches the encoded content of messages. (optional)</param>
        /// <param name="sentContentSearch">Searches the sent content of messages. (optional)</param>
        /// <param name="responseContentSearch">Searches the response content of messages. (optional)</param>
        /// <param name="responseTransformedContentSearch">Searches the response transformed content of messages. (optional)</param>
        /// <param name="processedResponseContentSearch">Searches the processed response content of messages. (optional)</param>
        /// <param name="connectorMapContentSearch">Searches the connector map content of messages. (optional)</param>
        /// <param name="channelMapContentSearch">Searches the channel map content of messages. (optional)</param>
        /// <param name="sourceMapContentSearch">Searches the source map content of messages. (optional)</param>
        /// <param name="responseMapContentSearch">Searches the response map content of messages. (optional)</param>
        /// <param name="processingErrorContentSearch">Searches the processing error content of messages. (optional)</param>
        /// <param name="postprocessorErrorContentSearch">Searches the postprocessor error content of messages. (optional)</param>
        /// <param name="responseErrorContentSearch">Searches the response error content of messages. (optional)</param>
        /// <param name="metaDataSearch">Searches a custom metadata column. Value should be in the form: COLUMN_NAME &amp;lt;operator&amp;gt; value, where operator is one of the following: &#x3D;, !&#x3D;, &lt;, &lt;&#x3D;, &gt;, &gt;&#x3D;, CONTAINS, DOES NOT CONTAIN, STARTS WITH, DOES NOT START WITH, ENDS WITH, DOES NOT END WITH (optional)</param>
        /// <param name="metaDataCaseInsensitiveSearch">Searches a custom metadata column, ignoring case. Value should be in the form: COLUMN_NAME &amp;lt;operator&amp;gt; value. (optional)</param>
        /// <param name="textSearchMetaDataColumn">When using a text search, these custom metadata columns will also be searched. (optional)</param>
        /// <param name="minSendAttempts">The minimum number of send attempts for connector messages. (optional)</param>
        /// <param name="maxSendAttempts">The maximum number of send attempts for connector messages. (optional)</param>
        /// <param name="attachment">If true, only messages with attachments are included in the results. (optional)</param>
        /// <param name="error">If true, only messages with errors are included in the results. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<OpenapiGenerator.MirthConnect311.Client.ApiResponse<Object>> RemoveMessages1WithHttpInfoAsync(string channelId, long? minMessageId = default(long?), long? maxMessageId = default(long?), long? minOriginalId = default(long?), long? maxOriginalId = default(long?), long? minImportId = default(long?), long? maxImportId = default(long?), DateTime? startDate = default(DateTime?), DateTime? endDate = default(DateTime?), string textSearch = default(string), bool? textSearchRegex = default(bool?), List<string> status = default(List<string>), List<int> includedMetaDataId = default(List<int>), List<int> excludedMetaDataId = default(List<int>), string serverId = default(string), List<string> rawContentSearch = default(List<string>), List<string> processedRawContentSearch = default(List<string>), List<string> transformedContentSearch = default(List<string>), List<string> encodedContentSearch = default(List<string>), List<string> sentContentSearch = default(List<string>), List<string> responseContentSearch = default(List<string>), List<string> responseTransformedContentSearch = default(List<string>), List<string> processedResponseContentSearch = default(List<string>), List<string> connectorMapContentSearch = default(List<string>), List<string> channelMapContentSearch = default(List<string>), List<string> sourceMapContentSearch = default(List<string>), List<string> responseMapContentSearch = default(List<string>), List<string> processingErrorContentSearch = default(List<string>), List<string> postprocessorErrorContentSearch = default(List<string>), List<string> responseErrorContentSearch = default(List<string>), List<MetaDataSearch> metaDataSearch = default(List<MetaDataSearch>), List<MetaDataSearch> metaDataCaseInsensitiveSearch = default(List<MetaDataSearch>), List<string> textSearchMetaDataColumn = default(List<string>), int? minSendAttempts = default(int?), int? maxSendAttempts = default(int?), bool? attachment = default(bool?), bool? error = default(bool?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'channelId' is set
            if (channelId == null)
            {
                throw new OpenapiGenerator.MirthConnect311.Client.ApiException(400, "Missing required parameter 'channelId' when calling MessagesApi->RemoveMessages1");
            }


            OpenapiGenerator.MirthConnect311.Client.RequestOptions localVarRequestOptions = new OpenapiGenerator.MirthConnect311.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/xml",
                "application/json"
            };

            var localVarContentType = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("channelId", OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToString(channelId)); // path parameter
            if (minMessageId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "minMessageId", minMessageId));
            }
            if (maxMessageId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "maxMessageId", maxMessageId));
            }
            if (minOriginalId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "minOriginalId", minOriginalId));
            }
            if (maxOriginalId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "maxOriginalId", maxOriginalId));
            }
            if (minImportId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "minImportId", minImportId));
            }
            if (maxImportId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "maxImportId", maxImportId));
            }
            if (startDate != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "startDate", startDate));
            }
            if (endDate != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "endDate", endDate));
            }
            if (textSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "textSearch", textSearch));
            }
            if (textSearchRegex != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "textSearchRegex", textSearchRegex));
            }
            if (status != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "status", status));
            }
            if (includedMetaDataId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "includedMetaDataId", includedMetaDataId));
            }
            if (excludedMetaDataId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "excludedMetaDataId", excludedMetaDataId));
            }
            if (serverId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "serverId", serverId));
            }
            if (rawContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "rawContentSearch", rawContentSearch));
            }
            if (processedRawContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "processedRawContentSearch", processedRawContentSearch));
            }
            if (transformedContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "transformedContentSearch", transformedContentSearch));
            }
            if (encodedContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "encodedContentSearch", encodedContentSearch));
            }
            if (sentContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "sentContentSearch", sentContentSearch));
            }
            if (responseContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "responseContentSearch", responseContentSearch));
            }
            if (responseTransformedContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "responseTransformedContentSearch", responseTransformedContentSearch));
            }
            if (processedResponseContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "processedResponseContentSearch", processedResponseContentSearch));
            }
            if (connectorMapContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "connectorMapContentSearch", connectorMapContentSearch));
            }
            if (channelMapContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "channelMapContentSearch", channelMapContentSearch));
            }
            if (sourceMapContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "sourceMapContentSearch", sourceMapContentSearch));
            }
            if (responseMapContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "responseMapContentSearch", responseMapContentSearch));
            }
            if (processingErrorContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "processingErrorContentSearch", processingErrorContentSearch));
            }
            if (postprocessorErrorContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "postprocessorErrorContentSearch", postprocessorErrorContentSearch));
            }
            if (responseErrorContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "responseErrorContentSearch", responseErrorContentSearch));
            }
            if (metaDataSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "metaDataSearch", metaDataSearch));
            }
            if (metaDataCaseInsensitiveSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "metaDataCaseInsensitiveSearch", metaDataCaseInsensitiveSearch));
            }
            if (textSearchMetaDataColumn != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "textSearchMetaDataColumn", textSearchMetaDataColumn));
            }
            if (minSendAttempts != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "minSendAttempts", minSendAttempts));
            }
            if (maxSendAttempts != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "maxSendAttempts", maxSendAttempts));
            }
            if (attachment != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "attachment", attachment));
            }
            if (error != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "error", error));
            }

            // authentication (cookieAuth) required
            // cookie parameter support
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("JSESSIONID")))
            {
                localVarRequestOptions.Cookies.Add(new Cookie("JSESSIONID", this.Configuration.GetApiKeyWithPrefix("JSESSIONID")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.DeleteAsync<Object>("/channels/{channelId}/messages", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RemoveMessages1", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Reprocesses and overwrites a single message. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="messageId">The ID of the message.</param>
        /// <param name="replace">If true, the message will overwrite the current one (optional, default to false)</param>
        /// <param name="filterDestinations">If true, the metaDataId parameter will be used to determine which destinations to reprocess the message through. (optional, default to false)</param>
        /// <param name="metaDataId">Indicates which destinations to send the message to. (optional)</param>
        /// <returns></returns>
        public void ReprocessMessage(string channelId, long messageId, bool? replace = default(bool?), bool? filterDestinations = default(bool?), List<int> metaDataId = default(List<int>))
        {
            ReprocessMessageWithHttpInfo(channelId, messageId, replace, filterDestinations, metaDataId);
        }

        /// <summary>
        /// Reprocesses and overwrites a single message. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="messageId">The ID of the message.</param>
        /// <param name="replace">If true, the message will overwrite the current one (optional, default to false)</param>
        /// <param name="filterDestinations">If true, the metaDataId parameter will be used to determine which destinations to reprocess the message through. (optional, default to false)</param>
        /// <param name="metaDataId">Indicates which destinations to send the message to. (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public OpenapiGenerator.MirthConnect311.Client.ApiResponse<Object> ReprocessMessageWithHttpInfo(string channelId, long messageId, bool? replace = default(bool?), bool? filterDestinations = default(bool?), List<int> metaDataId = default(List<int>))
        {
            // verify the required parameter 'channelId' is set
            if (channelId == null)
            {
                throw new OpenapiGenerator.MirthConnect311.Client.ApiException(400, "Missing required parameter 'channelId' when calling MessagesApi->ReprocessMessage");
            }

            OpenapiGenerator.MirthConnect311.Client.RequestOptions localVarRequestOptions = new OpenapiGenerator.MirthConnect311.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/xml",
                "application/json"
            };

            var localVarContentType = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("channelId", OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToString(channelId)); // path parameter
            localVarRequestOptions.PathParameters.Add("messageId", OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToString(messageId)); // path parameter
            if (replace != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "replace", replace));
            }
            if (filterDestinations != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "filterDestinations", filterDestinations));
            }
            if (metaDataId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "metaDataId", metaDataId));
            }

            // authentication (cookieAuth) required
            // cookie parameter support
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("JSESSIONID")))
            {
                localVarRequestOptions.Cookies.Add(new Cookie("JSESSIONID", this.Configuration.GetApiKeyWithPrefix("JSESSIONID")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<Object>("/channels/{channelId}/messages/{messageId}/_reprocess", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReprocessMessage", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Reprocesses and overwrites a single message. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="messageId">The ID of the message.</param>
        /// <param name="replace">If true, the message will overwrite the current one (optional, default to false)</param>
        /// <param name="filterDestinations">If true, the metaDataId parameter will be used to determine which destinations to reprocess the message through. (optional, default to false)</param>
        /// <param name="metaDataId">Indicates which destinations to send the message to. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task ReprocessMessageAsync(string channelId, long messageId, bool? replace = default(bool?), bool? filterDestinations = default(bool?), List<int> metaDataId = default(List<int>), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await ReprocessMessageWithHttpInfoAsync(channelId, messageId, replace, filterDestinations, metaDataId, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Reprocesses and overwrites a single message. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="messageId">The ID of the message.</param>
        /// <param name="replace">If true, the message will overwrite the current one (optional, default to false)</param>
        /// <param name="filterDestinations">If true, the metaDataId parameter will be used to determine which destinations to reprocess the message through. (optional, default to false)</param>
        /// <param name="metaDataId">Indicates which destinations to send the message to. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<OpenapiGenerator.MirthConnect311.Client.ApiResponse<Object>> ReprocessMessageWithHttpInfoAsync(string channelId, long messageId, bool? replace = default(bool?), bool? filterDestinations = default(bool?), List<int> metaDataId = default(List<int>), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'channelId' is set
            if (channelId == null)
            {
                throw new OpenapiGenerator.MirthConnect311.Client.ApiException(400, "Missing required parameter 'channelId' when calling MessagesApi->ReprocessMessage");
            }


            OpenapiGenerator.MirthConnect311.Client.RequestOptions localVarRequestOptions = new OpenapiGenerator.MirthConnect311.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/xml",
                "application/json"
            };

            var localVarContentType = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("channelId", OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToString(channelId)); // path parameter
            localVarRequestOptions.PathParameters.Add("messageId", OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToString(messageId)); // path parameter
            if (replace != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "replace", replace));
            }
            if (filterDestinations != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "filterDestinations", filterDestinations));
            }
            if (metaDataId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "metaDataId", metaDataId));
            }

            // authentication (cookieAuth) required
            // cookie parameter support
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("JSESSIONID")))
            {
                localVarRequestOptions.Cookies.Add(new Cookie("JSESSIONID", this.Configuration.GetApiKeyWithPrefix("JSESSIONID")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<Object>("/channels/{channelId}/messages/{messageId}/_reprocess", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReprocessMessage", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Reprocesses messages through a channel filtering with a MessageFilter. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="messageFilter">The MessageFilter object to use to query messages by.</param>
        /// <param name="replace">If true, the message will overwrite the current one (optional, default to false)</param>
        /// <param name="filterDestinations">If true, the metaDataId parameter will be used to determine which destinations to reprocess the message through. (optional, default to false)</param>
        /// <param name="metaDataId">Indicates which destinations to send the message to. (optional)</param>
        /// <returns></returns>
        public void ReprocessMessages(string channelId, MessageFilter messageFilter, bool? replace = default(bool?), bool? filterDestinations = default(bool?), List<int> metaDataId = default(List<int>))
        {
            ReprocessMessagesWithHttpInfo(channelId, messageFilter, replace, filterDestinations, metaDataId);
        }

        /// <summary>
        /// Reprocesses messages through a channel filtering with a MessageFilter. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="messageFilter">The MessageFilter object to use to query messages by.</param>
        /// <param name="replace">If true, the message will overwrite the current one (optional, default to false)</param>
        /// <param name="filterDestinations">If true, the metaDataId parameter will be used to determine which destinations to reprocess the message through. (optional, default to false)</param>
        /// <param name="metaDataId">Indicates which destinations to send the message to. (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public OpenapiGenerator.MirthConnect311.Client.ApiResponse<Object> ReprocessMessagesWithHttpInfo(string channelId, MessageFilter messageFilter, bool? replace = default(bool?), bool? filterDestinations = default(bool?), List<int> metaDataId = default(List<int>))
        {
            // verify the required parameter 'channelId' is set
            if (channelId == null)
            {
                throw new OpenapiGenerator.MirthConnect311.Client.ApiException(400, "Missing required parameter 'channelId' when calling MessagesApi->ReprocessMessages");
            }

            // verify the required parameter 'messageFilter' is set
            if (messageFilter == null)
            {
                throw new OpenapiGenerator.MirthConnect311.Client.ApiException(400, "Missing required parameter 'messageFilter' when calling MessagesApi->ReprocessMessages");
            }

            OpenapiGenerator.MirthConnect311.Client.RequestOptions localVarRequestOptions = new OpenapiGenerator.MirthConnect311.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/xml",
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/xml",
                "application/json"
            };

            var localVarContentType = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("channelId", OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToString(channelId)); // path parameter
            if (replace != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "replace", replace));
            }
            if (filterDestinations != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "filterDestinations", filterDestinations));
            }
            if (metaDataId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "metaDataId", metaDataId));
            }
            localVarRequestOptions.Data = messageFilter;

            // authentication (cookieAuth) required
            // cookie parameter support
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("JSESSIONID")))
            {
                localVarRequestOptions.Cookies.Add(new Cookie("JSESSIONID", this.Configuration.GetApiKeyWithPrefix("JSESSIONID")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<Object>("/channels/{channelId}/messages/_reprocessWithFilter", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReprocessMessages", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Reprocesses messages through a channel filtering with a MessageFilter. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="messageFilter">The MessageFilter object to use to query messages by.</param>
        /// <param name="replace">If true, the message will overwrite the current one (optional, default to false)</param>
        /// <param name="filterDestinations">If true, the metaDataId parameter will be used to determine which destinations to reprocess the message through. (optional, default to false)</param>
        /// <param name="metaDataId">Indicates which destinations to send the message to. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task ReprocessMessagesAsync(string channelId, MessageFilter messageFilter, bool? replace = default(bool?), bool? filterDestinations = default(bool?), List<int> metaDataId = default(List<int>), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await ReprocessMessagesWithHttpInfoAsync(channelId, messageFilter, replace, filterDestinations, metaDataId, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Reprocesses messages through a channel filtering with a MessageFilter. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="messageFilter">The MessageFilter object to use to query messages by.</param>
        /// <param name="replace">If true, the message will overwrite the current one (optional, default to false)</param>
        /// <param name="filterDestinations">If true, the metaDataId parameter will be used to determine which destinations to reprocess the message through. (optional, default to false)</param>
        /// <param name="metaDataId">Indicates which destinations to send the message to. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<OpenapiGenerator.MirthConnect311.Client.ApiResponse<Object>> ReprocessMessagesWithHttpInfoAsync(string channelId, MessageFilter messageFilter, bool? replace = default(bool?), bool? filterDestinations = default(bool?), List<int> metaDataId = default(List<int>), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'channelId' is set
            if (channelId == null)
            {
                throw new OpenapiGenerator.MirthConnect311.Client.ApiException(400, "Missing required parameter 'channelId' when calling MessagesApi->ReprocessMessages");
            }

            // verify the required parameter 'messageFilter' is set
            if (messageFilter == null)
            {
                throw new OpenapiGenerator.MirthConnect311.Client.ApiException(400, "Missing required parameter 'messageFilter' when calling MessagesApi->ReprocessMessages");
            }


            OpenapiGenerator.MirthConnect311.Client.RequestOptions localVarRequestOptions = new OpenapiGenerator.MirthConnect311.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/xml", 
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/xml",
                "application/json"
            };

            var localVarContentType = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("channelId", OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToString(channelId)); // path parameter
            if (replace != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "replace", replace));
            }
            if (filterDestinations != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "filterDestinations", filterDestinations));
            }
            if (metaDataId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "metaDataId", metaDataId));
            }
            localVarRequestOptions.Data = messageFilter;

            // authentication (cookieAuth) required
            // cookie parameter support
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("JSESSIONID")))
            {
                localVarRequestOptions.Cookies.Add(new Cookie("JSESSIONID", this.Configuration.GetApiKeyWithPrefix("JSESSIONID")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<Object>("/channels/{channelId}/messages/_reprocessWithFilter", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReprocessMessages", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Reprocesses messages through a channel by specific filter criteria. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="minMessageId">The minimum message ID to query. (optional)</param>
        /// <param name="maxMessageId">The maximum message ID to query. (optional)</param>
        /// <param name="minOriginalId">The minimum original message ID to query. Messages that have been reprocessed will retain their original message ID. (optional)</param>
        /// <param name="maxOriginalId">The maximum original message ID to query. Messages that have been reprocessed will retain their original message ID. (optional)</param>
        /// <param name="minImportId">The minimum import message ID to query. Messages that have been imported will retain their original message ID under this value. (optional)</param>
        /// <param name="maxImportId">The maximum import message ID to query. Messages that have been imported will retain their original message ID under this value. (optional)</param>
        /// <param name="startDate">The earliest original received date to query by. Example: 1985-10-26T09:00:00.000-0700 (optional)</param>
        /// <param name="endDate">The latest original received date to query by. Example: 2015-10-21T07:28:00.000-0700 (optional)</param>
        /// <param name="textSearch">Searches all message content for this string. This process could take a long time depending on the amount of message content currently stored. Any message content that was encrypted by this channel will not be searchable. (optional)</param>
        /// <param name="textSearchRegex">If true, text search input will be considered a regular expression pattern to be matched. Only supported by PostgreSQL, MySQL and Oracle databases. (optional)</param>
        /// <param name="status">Determines which message statuses to query by. (optional)</param>
        /// <param name="includedMetaDataId">If present, only connector metadata IDs in this list will be queried. (optional)</param>
        /// <param name="excludedMetaDataId">If present, connector metadata IDs in this list will not be queried. (optional)</param>
        /// <param name="serverId">The server ID associated with messages. (optional)</param>
        /// <param name="rawContentSearch">Searches the raw content of messages. (optional)</param>
        /// <param name="processedRawContentSearch">Searches the processed raw content of messages. (optional)</param>
        /// <param name="transformedContentSearch">Searches the transformed content of messages. (optional)</param>
        /// <param name="encodedContentSearch">Searches the encoded content of messages. (optional)</param>
        /// <param name="sentContentSearch">Searches the sent content of messages. (optional)</param>
        /// <param name="responseContentSearch">Searches the response content of messages. (optional)</param>
        /// <param name="responseTransformedContentSearch">Searches the response transformed content of messages. (optional)</param>
        /// <param name="processedResponseContentSearch">Searches the processed response content of messages. (optional)</param>
        /// <param name="connectorMapContentSearch">Searches the connector map content of messages. (optional)</param>
        /// <param name="channelMapContentSearch">Searches the channel map content of messages. (optional)</param>
        /// <param name="sourceMapContentSearch">Searches the source map content of messages. (optional)</param>
        /// <param name="responseMapContentSearch">Searches the response map content of messages. (optional)</param>
        /// <param name="processingErrorContentSearch">Searches the processing error content of messages. (optional)</param>
        /// <param name="postprocessorErrorContentSearch">Searches the postprocessor error content of messages. (optional)</param>
        /// <param name="responseErrorContentSearch">Searches the response error content of messages. (optional)</param>
        /// <param name="metaDataSearch">Searches a custom metadata column. Value should be in the form: COLUMN_NAME &amp;lt;operator&amp;gt; value, where operator is one of the following: &#x3D;, !&#x3D;, &lt;, &lt;&#x3D;, &gt;, &gt;&#x3D;, CONTAINS, DOES NOT CONTAIN, STARTS WITH, DOES NOT START WITH, ENDS WITH, DOES NOT END WITH (optional)</param>
        /// <param name="metaDataCaseInsensitiveSearch">Searches a custom metadata column, ignoring case. Value should be in the form: COLUMN_NAME &amp;lt;operator&amp;gt; value. (optional)</param>
        /// <param name="textSearchMetaDataColumn">When using a text search, these custom metadata columns will also be searched. (optional)</param>
        /// <param name="minSendAttempts">The minimum number of send attempts for connector messages. (optional)</param>
        /// <param name="maxSendAttempts">The maximum number of send attempts for connector messages. (optional)</param>
        /// <param name="attachment">If true, only messages with attachments are included in the results. (optional)</param>
        /// <param name="error">If true, only messages with errors are included in the results. (optional)</param>
        /// <param name="replace">If true, the message will overwrite the current one (optional, default to false)</param>
        /// <param name="filterDestinations">If true, the metaDataId parameter will be used to determine which destinations to reprocess the message through. (optional, default to false)</param>
        /// <param name="metaDataId">Indicates which destinations to send the message to. (optional)</param>
        /// <returns></returns>
        public void ReprocessMessages1(string channelId, long? minMessageId = default(long?), long? maxMessageId = default(long?), long? minOriginalId = default(long?), long? maxOriginalId = default(long?), long? minImportId = default(long?), long? maxImportId = default(long?), DateTime? startDate = default(DateTime?), DateTime? endDate = default(DateTime?), string textSearch = default(string), bool? textSearchRegex = default(bool?), List<string> status = default(List<string>), List<int> includedMetaDataId = default(List<int>), List<int> excludedMetaDataId = default(List<int>), string serverId = default(string), List<string> rawContentSearch = default(List<string>), List<string> processedRawContentSearch = default(List<string>), List<string> transformedContentSearch = default(List<string>), List<string> encodedContentSearch = default(List<string>), List<string> sentContentSearch = default(List<string>), List<string> responseContentSearch = default(List<string>), List<string> responseTransformedContentSearch = default(List<string>), List<string> processedResponseContentSearch = default(List<string>), List<string> connectorMapContentSearch = default(List<string>), List<string> channelMapContentSearch = default(List<string>), List<string> sourceMapContentSearch = default(List<string>), List<string> responseMapContentSearch = default(List<string>), List<string> processingErrorContentSearch = default(List<string>), List<string> postprocessorErrorContentSearch = default(List<string>), List<string> responseErrorContentSearch = default(List<string>), List<MetaDataSearch> metaDataSearch = default(List<MetaDataSearch>), List<MetaDataSearch> metaDataCaseInsensitiveSearch = default(List<MetaDataSearch>), List<string> textSearchMetaDataColumn = default(List<string>), int? minSendAttempts = default(int?), int? maxSendAttempts = default(int?), bool? attachment = default(bool?), bool? error = default(bool?), bool? replace = default(bool?), bool? filterDestinations = default(bool?), List<int> metaDataId = default(List<int>))
        {
            ReprocessMessages1WithHttpInfo(channelId, minMessageId, maxMessageId, minOriginalId, maxOriginalId, minImportId, maxImportId, startDate, endDate, textSearch, textSearchRegex, status, includedMetaDataId, excludedMetaDataId, serverId, rawContentSearch, processedRawContentSearch, transformedContentSearch, encodedContentSearch, sentContentSearch, responseContentSearch, responseTransformedContentSearch, processedResponseContentSearch, connectorMapContentSearch, channelMapContentSearch, sourceMapContentSearch, responseMapContentSearch, processingErrorContentSearch, postprocessorErrorContentSearch, responseErrorContentSearch, metaDataSearch, metaDataCaseInsensitiveSearch, textSearchMetaDataColumn, minSendAttempts, maxSendAttempts, attachment, error, replace, filterDestinations, metaDataId);
        }

        /// <summary>
        /// Reprocesses messages through a channel by specific filter criteria. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="minMessageId">The minimum message ID to query. (optional)</param>
        /// <param name="maxMessageId">The maximum message ID to query. (optional)</param>
        /// <param name="minOriginalId">The minimum original message ID to query. Messages that have been reprocessed will retain their original message ID. (optional)</param>
        /// <param name="maxOriginalId">The maximum original message ID to query. Messages that have been reprocessed will retain their original message ID. (optional)</param>
        /// <param name="minImportId">The minimum import message ID to query. Messages that have been imported will retain their original message ID under this value. (optional)</param>
        /// <param name="maxImportId">The maximum import message ID to query. Messages that have been imported will retain their original message ID under this value. (optional)</param>
        /// <param name="startDate">The earliest original received date to query by. Example: 1985-10-26T09:00:00.000-0700 (optional)</param>
        /// <param name="endDate">The latest original received date to query by. Example: 2015-10-21T07:28:00.000-0700 (optional)</param>
        /// <param name="textSearch">Searches all message content for this string. This process could take a long time depending on the amount of message content currently stored. Any message content that was encrypted by this channel will not be searchable. (optional)</param>
        /// <param name="textSearchRegex">If true, text search input will be considered a regular expression pattern to be matched. Only supported by PostgreSQL, MySQL and Oracle databases. (optional)</param>
        /// <param name="status">Determines which message statuses to query by. (optional)</param>
        /// <param name="includedMetaDataId">If present, only connector metadata IDs in this list will be queried. (optional)</param>
        /// <param name="excludedMetaDataId">If present, connector metadata IDs in this list will not be queried. (optional)</param>
        /// <param name="serverId">The server ID associated with messages. (optional)</param>
        /// <param name="rawContentSearch">Searches the raw content of messages. (optional)</param>
        /// <param name="processedRawContentSearch">Searches the processed raw content of messages. (optional)</param>
        /// <param name="transformedContentSearch">Searches the transformed content of messages. (optional)</param>
        /// <param name="encodedContentSearch">Searches the encoded content of messages. (optional)</param>
        /// <param name="sentContentSearch">Searches the sent content of messages. (optional)</param>
        /// <param name="responseContentSearch">Searches the response content of messages. (optional)</param>
        /// <param name="responseTransformedContentSearch">Searches the response transformed content of messages. (optional)</param>
        /// <param name="processedResponseContentSearch">Searches the processed response content of messages. (optional)</param>
        /// <param name="connectorMapContentSearch">Searches the connector map content of messages. (optional)</param>
        /// <param name="channelMapContentSearch">Searches the channel map content of messages. (optional)</param>
        /// <param name="sourceMapContentSearch">Searches the source map content of messages. (optional)</param>
        /// <param name="responseMapContentSearch">Searches the response map content of messages. (optional)</param>
        /// <param name="processingErrorContentSearch">Searches the processing error content of messages. (optional)</param>
        /// <param name="postprocessorErrorContentSearch">Searches the postprocessor error content of messages. (optional)</param>
        /// <param name="responseErrorContentSearch">Searches the response error content of messages. (optional)</param>
        /// <param name="metaDataSearch">Searches a custom metadata column. Value should be in the form: COLUMN_NAME &amp;lt;operator&amp;gt; value, where operator is one of the following: &#x3D;, !&#x3D;, &lt;, &lt;&#x3D;, &gt;, &gt;&#x3D;, CONTAINS, DOES NOT CONTAIN, STARTS WITH, DOES NOT START WITH, ENDS WITH, DOES NOT END WITH (optional)</param>
        /// <param name="metaDataCaseInsensitiveSearch">Searches a custom metadata column, ignoring case. Value should be in the form: COLUMN_NAME &amp;lt;operator&amp;gt; value. (optional)</param>
        /// <param name="textSearchMetaDataColumn">When using a text search, these custom metadata columns will also be searched. (optional)</param>
        /// <param name="minSendAttempts">The minimum number of send attempts for connector messages. (optional)</param>
        /// <param name="maxSendAttempts">The maximum number of send attempts for connector messages. (optional)</param>
        /// <param name="attachment">If true, only messages with attachments are included in the results. (optional)</param>
        /// <param name="error">If true, only messages with errors are included in the results. (optional)</param>
        /// <param name="replace">If true, the message will overwrite the current one (optional, default to false)</param>
        /// <param name="filterDestinations">If true, the metaDataId parameter will be used to determine which destinations to reprocess the message through. (optional, default to false)</param>
        /// <param name="metaDataId">Indicates which destinations to send the message to. (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public OpenapiGenerator.MirthConnect311.Client.ApiResponse<Object> ReprocessMessages1WithHttpInfo(string channelId, long? minMessageId = default(long?), long? maxMessageId = default(long?), long? minOriginalId = default(long?), long? maxOriginalId = default(long?), long? minImportId = default(long?), long? maxImportId = default(long?), DateTime? startDate = default(DateTime?), DateTime? endDate = default(DateTime?), string textSearch = default(string), bool? textSearchRegex = default(bool?), List<string> status = default(List<string>), List<int> includedMetaDataId = default(List<int>), List<int> excludedMetaDataId = default(List<int>), string serverId = default(string), List<string> rawContentSearch = default(List<string>), List<string> processedRawContentSearch = default(List<string>), List<string> transformedContentSearch = default(List<string>), List<string> encodedContentSearch = default(List<string>), List<string> sentContentSearch = default(List<string>), List<string> responseContentSearch = default(List<string>), List<string> responseTransformedContentSearch = default(List<string>), List<string> processedResponseContentSearch = default(List<string>), List<string> connectorMapContentSearch = default(List<string>), List<string> channelMapContentSearch = default(List<string>), List<string> sourceMapContentSearch = default(List<string>), List<string> responseMapContentSearch = default(List<string>), List<string> processingErrorContentSearch = default(List<string>), List<string> postprocessorErrorContentSearch = default(List<string>), List<string> responseErrorContentSearch = default(List<string>), List<MetaDataSearch> metaDataSearch = default(List<MetaDataSearch>), List<MetaDataSearch> metaDataCaseInsensitiveSearch = default(List<MetaDataSearch>), List<string> textSearchMetaDataColumn = default(List<string>), int? minSendAttempts = default(int?), int? maxSendAttempts = default(int?), bool? attachment = default(bool?), bool? error = default(bool?), bool? replace = default(bool?), bool? filterDestinations = default(bool?), List<int> metaDataId = default(List<int>))
        {
            // verify the required parameter 'channelId' is set
            if (channelId == null)
            {
                throw new OpenapiGenerator.MirthConnect311.Client.ApiException(400, "Missing required parameter 'channelId' when calling MessagesApi->ReprocessMessages1");
            }

            OpenapiGenerator.MirthConnect311.Client.RequestOptions localVarRequestOptions = new OpenapiGenerator.MirthConnect311.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/xml",
                "application/json"
            };

            var localVarContentType = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("channelId", OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToString(channelId)); // path parameter
            if (minMessageId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "minMessageId", minMessageId));
            }
            if (maxMessageId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "maxMessageId", maxMessageId));
            }
            if (minOriginalId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "minOriginalId", minOriginalId));
            }
            if (maxOriginalId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "maxOriginalId", maxOriginalId));
            }
            if (minImportId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "minImportId", minImportId));
            }
            if (maxImportId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "maxImportId", maxImportId));
            }
            if (startDate != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "startDate", startDate));
            }
            if (endDate != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "endDate", endDate));
            }
            if (textSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "textSearch", textSearch));
            }
            if (textSearchRegex != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "textSearchRegex", textSearchRegex));
            }
            if (status != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "status", status));
            }
            if (includedMetaDataId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "includedMetaDataId", includedMetaDataId));
            }
            if (excludedMetaDataId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "excludedMetaDataId", excludedMetaDataId));
            }
            if (serverId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "serverId", serverId));
            }
            if (rawContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "rawContentSearch", rawContentSearch));
            }
            if (processedRawContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "processedRawContentSearch", processedRawContentSearch));
            }
            if (transformedContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "transformedContentSearch", transformedContentSearch));
            }
            if (encodedContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "encodedContentSearch", encodedContentSearch));
            }
            if (sentContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "sentContentSearch", sentContentSearch));
            }
            if (responseContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "responseContentSearch", responseContentSearch));
            }
            if (responseTransformedContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "responseTransformedContentSearch", responseTransformedContentSearch));
            }
            if (processedResponseContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "processedResponseContentSearch", processedResponseContentSearch));
            }
            if (connectorMapContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "connectorMapContentSearch", connectorMapContentSearch));
            }
            if (channelMapContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "channelMapContentSearch", channelMapContentSearch));
            }
            if (sourceMapContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "sourceMapContentSearch", sourceMapContentSearch));
            }
            if (responseMapContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "responseMapContentSearch", responseMapContentSearch));
            }
            if (processingErrorContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "processingErrorContentSearch", processingErrorContentSearch));
            }
            if (postprocessorErrorContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "postprocessorErrorContentSearch", postprocessorErrorContentSearch));
            }
            if (responseErrorContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "responseErrorContentSearch", responseErrorContentSearch));
            }
            if (metaDataSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "metaDataSearch", metaDataSearch));
            }
            if (metaDataCaseInsensitiveSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "metaDataCaseInsensitiveSearch", metaDataCaseInsensitiveSearch));
            }
            if (textSearchMetaDataColumn != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "textSearchMetaDataColumn", textSearchMetaDataColumn));
            }
            if (minSendAttempts != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "minSendAttempts", minSendAttempts));
            }
            if (maxSendAttempts != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "maxSendAttempts", maxSendAttempts));
            }
            if (attachment != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "attachment", attachment));
            }
            if (error != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "error", error));
            }
            if (replace != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "replace", replace));
            }
            if (filterDestinations != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "filterDestinations", filterDestinations));
            }
            if (metaDataId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "metaDataId", metaDataId));
            }

            // authentication (cookieAuth) required
            // cookie parameter support
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("JSESSIONID")))
            {
                localVarRequestOptions.Cookies.Add(new Cookie("JSESSIONID", this.Configuration.GetApiKeyWithPrefix("JSESSIONID")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<Object>("/channels/{channelId}/messages/_reprocess", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReprocessMessages1", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Reprocesses messages through a channel by specific filter criteria. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="minMessageId">The minimum message ID to query. (optional)</param>
        /// <param name="maxMessageId">The maximum message ID to query. (optional)</param>
        /// <param name="minOriginalId">The minimum original message ID to query. Messages that have been reprocessed will retain their original message ID. (optional)</param>
        /// <param name="maxOriginalId">The maximum original message ID to query. Messages that have been reprocessed will retain their original message ID. (optional)</param>
        /// <param name="minImportId">The minimum import message ID to query. Messages that have been imported will retain their original message ID under this value. (optional)</param>
        /// <param name="maxImportId">The maximum import message ID to query. Messages that have been imported will retain their original message ID under this value. (optional)</param>
        /// <param name="startDate">The earliest original received date to query by. Example: 1985-10-26T09:00:00.000-0700 (optional)</param>
        /// <param name="endDate">The latest original received date to query by. Example: 2015-10-21T07:28:00.000-0700 (optional)</param>
        /// <param name="textSearch">Searches all message content for this string. This process could take a long time depending on the amount of message content currently stored. Any message content that was encrypted by this channel will not be searchable. (optional)</param>
        /// <param name="textSearchRegex">If true, text search input will be considered a regular expression pattern to be matched. Only supported by PostgreSQL, MySQL and Oracle databases. (optional)</param>
        /// <param name="status">Determines which message statuses to query by. (optional)</param>
        /// <param name="includedMetaDataId">If present, only connector metadata IDs in this list will be queried. (optional)</param>
        /// <param name="excludedMetaDataId">If present, connector metadata IDs in this list will not be queried. (optional)</param>
        /// <param name="serverId">The server ID associated with messages. (optional)</param>
        /// <param name="rawContentSearch">Searches the raw content of messages. (optional)</param>
        /// <param name="processedRawContentSearch">Searches the processed raw content of messages. (optional)</param>
        /// <param name="transformedContentSearch">Searches the transformed content of messages. (optional)</param>
        /// <param name="encodedContentSearch">Searches the encoded content of messages. (optional)</param>
        /// <param name="sentContentSearch">Searches the sent content of messages. (optional)</param>
        /// <param name="responseContentSearch">Searches the response content of messages. (optional)</param>
        /// <param name="responseTransformedContentSearch">Searches the response transformed content of messages. (optional)</param>
        /// <param name="processedResponseContentSearch">Searches the processed response content of messages. (optional)</param>
        /// <param name="connectorMapContentSearch">Searches the connector map content of messages. (optional)</param>
        /// <param name="channelMapContentSearch">Searches the channel map content of messages. (optional)</param>
        /// <param name="sourceMapContentSearch">Searches the source map content of messages. (optional)</param>
        /// <param name="responseMapContentSearch">Searches the response map content of messages. (optional)</param>
        /// <param name="processingErrorContentSearch">Searches the processing error content of messages. (optional)</param>
        /// <param name="postprocessorErrorContentSearch">Searches the postprocessor error content of messages. (optional)</param>
        /// <param name="responseErrorContentSearch">Searches the response error content of messages. (optional)</param>
        /// <param name="metaDataSearch">Searches a custom metadata column. Value should be in the form: COLUMN_NAME &amp;lt;operator&amp;gt; value, where operator is one of the following: &#x3D;, !&#x3D;, &lt;, &lt;&#x3D;, &gt;, &gt;&#x3D;, CONTAINS, DOES NOT CONTAIN, STARTS WITH, DOES NOT START WITH, ENDS WITH, DOES NOT END WITH (optional)</param>
        /// <param name="metaDataCaseInsensitiveSearch">Searches a custom metadata column, ignoring case. Value should be in the form: COLUMN_NAME &amp;lt;operator&amp;gt; value. (optional)</param>
        /// <param name="textSearchMetaDataColumn">When using a text search, these custom metadata columns will also be searched. (optional)</param>
        /// <param name="minSendAttempts">The minimum number of send attempts for connector messages. (optional)</param>
        /// <param name="maxSendAttempts">The maximum number of send attempts for connector messages. (optional)</param>
        /// <param name="attachment">If true, only messages with attachments are included in the results. (optional)</param>
        /// <param name="error">If true, only messages with errors are included in the results. (optional)</param>
        /// <param name="replace">If true, the message will overwrite the current one (optional, default to false)</param>
        /// <param name="filterDestinations">If true, the metaDataId parameter will be used to determine which destinations to reprocess the message through. (optional, default to false)</param>
        /// <param name="metaDataId">Indicates which destinations to send the message to. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task ReprocessMessages1Async(string channelId, long? minMessageId = default(long?), long? maxMessageId = default(long?), long? minOriginalId = default(long?), long? maxOriginalId = default(long?), long? minImportId = default(long?), long? maxImportId = default(long?), DateTime? startDate = default(DateTime?), DateTime? endDate = default(DateTime?), string textSearch = default(string), bool? textSearchRegex = default(bool?), List<string> status = default(List<string>), List<int> includedMetaDataId = default(List<int>), List<int> excludedMetaDataId = default(List<int>), string serverId = default(string), List<string> rawContentSearch = default(List<string>), List<string> processedRawContentSearch = default(List<string>), List<string> transformedContentSearch = default(List<string>), List<string> encodedContentSearch = default(List<string>), List<string> sentContentSearch = default(List<string>), List<string> responseContentSearch = default(List<string>), List<string> responseTransformedContentSearch = default(List<string>), List<string> processedResponseContentSearch = default(List<string>), List<string> connectorMapContentSearch = default(List<string>), List<string> channelMapContentSearch = default(List<string>), List<string> sourceMapContentSearch = default(List<string>), List<string> responseMapContentSearch = default(List<string>), List<string> processingErrorContentSearch = default(List<string>), List<string> postprocessorErrorContentSearch = default(List<string>), List<string> responseErrorContentSearch = default(List<string>), List<MetaDataSearch> metaDataSearch = default(List<MetaDataSearch>), List<MetaDataSearch> metaDataCaseInsensitiveSearch = default(List<MetaDataSearch>), List<string> textSearchMetaDataColumn = default(List<string>), int? minSendAttempts = default(int?), int? maxSendAttempts = default(int?), bool? attachment = default(bool?), bool? error = default(bool?), bool? replace = default(bool?), bool? filterDestinations = default(bool?), List<int> metaDataId = default(List<int>), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await ReprocessMessages1WithHttpInfoAsync(channelId, minMessageId, maxMessageId, minOriginalId, maxOriginalId, minImportId, maxImportId, startDate, endDate, textSearch, textSearchRegex, status, includedMetaDataId, excludedMetaDataId, serverId, rawContentSearch, processedRawContentSearch, transformedContentSearch, encodedContentSearch, sentContentSearch, responseContentSearch, responseTransformedContentSearch, processedResponseContentSearch, connectorMapContentSearch, channelMapContentSearch, sourceMapContentSearch, responseMapContentSearch, processingErrorContentSearch, postprocessorErrorContentSearch, responseErrorContentSearch, metaDataSearch, metaDataCaseInsensitiveSearch, textSearchMetaDataColumn, minSendAttempts, maxSendAttempts, attachment, error, replace, filterDestinations, metaDataId, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Reprocesses messages through a channel by specific filter criteria. 
        /// </summary>
        /// <exception cref="OpenapiGenerator.MirthConnect311.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="minMessageId">The minimum message ID to query. (optional)</param>
        /// <param name="maxMessageId">The maximum message ID to query. (optional)</param>
        /// <param name="minOriginalId">The minimum original message ID to query. Messages that have been reprocessed will retain their original message ID. (optional)</param>
        /// <param name="maxOriginalId">The maximum original message ID to query. Messages that have been reprocessed will retain their original message ID. (optional)</param>
        /// <param name="minImportId">The minimum import message ID to query. Messages that have been imported will retain their original message ID under this value. (optional)</param>
        /// <param name="maxImportId">The maximum import message ID to query. Messages that have been imported will retain their original message ID under this value. (optional)</param>
        /// <param name="startDate">The earliest original received date to query by. Example: 1985-10-26T09:00:00.000-0700 (optional)</param>
        /// <param name="endDate">The latest original received date to query by. Example: 2015-10-21T07:28:00.000-0700 (optional)</param>
        /// <param name="textSearch">Searches all message content for this string. This process could take a long time depending on the amount of message content currently stored. Any message content that was encrypted by this channel will not be searchable. (optional)</param>
        /// <param name="textSearchRegex">If true, text search input will be considered a regular expression pattern to be matched. Only supported by PostgreSQL, MySQL and Oracle databases. (optional)</param>
        /// <param name="status">Determines which message statuses to query by. (optional)</param>
        /// <param name="includedMetaDataId">If present, only connector metadata IDs in this list will be queried. (optional)</param>
        /// <param name="excludedMetaDataId">If present, connector metadata IDs in this list will not be queried. (optional)</param>
        /// <param name="serverId">The server ID associated with messages. (optional)</param>
        /// <param name="rawContentSearch">Searches the raw content of messages. (optional)</param>
        /// <param name="processedRawContentSearch">Searches the processed raw content of messages. (optional)</param>
        /// <param name="transformedContentSearch">Searches the transformed content of messages. (optional)</param>
        /// <param name="encodedContentSearch">Searches the encoded content of messages. (optional)</param>
        /// <param name="sentContentSearch">Searches the sent content of messages. (optional)</param>
        /// <param name="responseContentSearch">Searches the response content of messages. (optional)</param>
        /// <param name="responseTransformedContentSearch">Searches the response transformed content of messages. (optional)</param>
        /// <param name="processedResponseContentSearch">Searches the processed response content of messages. (optional)</param>
        /// <param name="connectorMapContentSearch">Searches the connector map content of messages. (optional)</param>
        /// <param name="channelMapContentSearch">Searches the channel map content of messages. (optional)</param>
        /// <param name="sourceMapContentSearch">Searches the source map content of messages. (optional)</param>
        /// <param name="responseMapContentSearch">Searches the response map content of messages. (optional)</param>
        /// <param name="processingErrorContentSearch">Searches the processing error content of messages. (optional)</param>
        /// <param name="postprocessorErrorContentSearch">Searches the postprocessor error content of messages. (optional)</param>
        /// <param name="responseErrorContentSearch">Searches the response error content of messages. (optional)</param>
        /// <param name="metaDataSearch">Searches a custom metadata column. Value should be in the form: COLUMN_NAME &amp;lt;operator&amp;gt; value, where operator is one of the following: &#x3D;, !&#x3D;, &lt;, &lt;&#x3D;, &gt;, &gt;&#x3D;, CONTAINS, DOES NOT CONTAIN, STARTS WITH, DOES NOT START WITH, ENDS WITH, DOES NOT END WITH (optional)</param>
        /// <param name="metaDataCaseInsensitiveSearch">Searches a custom metadata column, ignoring case. Value should be in the form: COLUMN_NAME &amp;lt;operator&amp;gt; value. (optional)</param>
        /// <param name="textSearchMetaDataColumn">When using a text search, these custom metadata columns will also be searched. (optional)</param>
        /// <param name="minSendAttempts">The minimum number of send attempts for connector messages. (optional)</param>
        /// <param name="maxSendAttempts">The maximum number of send attempts for connector messages. (optional)</param>
        /// <param name="attachment">If true, only messages with attachments are included in the results. (optional)</param>
        /// <param name="error">If true, only messages with errors are included in the results. (optional)</param>
        /// <param name="replace">If true, the message will overwrite the current one (optional, default to false)</param>
        /// <param name="filterDestinations">If true, the metaDataId parameter will be used to determine which destinations to reprocess the message through. (optional, default to false)</param>
        /// <param name="metaDataId">Indicates which destinations to send the message to. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<OpenapiGenerator.MirthConnect311.Client.ApiResponse<Object>> ReprocessMessages1WithHttpInfoAsync(string channelId, long? minMessageId = default(long?), long? maxMessageId = default(long?), long? minOriginalId = default(long?), long? maxOriginalId = default(long?), long? minImportId = default(long?), long? maxImportId = default(long?), DateTime? startDate = default(DateTime?), DateTime? endDate = default(DateTime?), string textSearch = default(string), bool? textSearchRegex = default(bool?), List<string> status = default(List<string>), List<int> includedMetaDataId = default(List<int>), List<int> excludedMetaDataId = default(List<int>), string serverId = default(string), List<string> rawContentSearch = default(List<string>), List<string> processedRawContentSearch = default(List<string>), List<string> transformedContentSearch = default(List<string>), List<string> encodedContentSearch = default(List<string>), List<string> sentContentSearch = default(List<string>), List<string> responseContentSearch = default(List<string>), List<string> responseTransformedContentSearch = default(List<string>), List<string> processedResponseContentSearch = default(List<string>), List<string> connectorMapContentSearch = default(List<string>), List<string> channelMapContentSearch = default(List<string>), List<string> sourceMapContentSearch = default(List<string>), List<string> responseMapContentSearch = default(List<string>), List<string> processingErrorContentSearch = default(List<string>), List<string> postprocessorErrorContentSearch = default(List<string>), List<string> responseErrorContentSearch = default(List<string>), List<MetaDataSearch> metaDataSearch = default(List<MetaDataSearch>), List<MetaDataSearch> metaDataCaseInsensitiveSearch = default(List<MetaDataSearch>), List<string> textSearchMetaDataColumn = default(List<string>), int? minSendAttempts = default(int?), int? maxSendAttempts = default(int?), bool? attachment = default(bool?), bool? error = default(bool?), bool? replace = default(bool?), bool? filterDestinations = default(bool?), List<int> metaDataId = default(List<int>), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'channelId' is set
            if (channelId == null)
            {
                throw new OpenapiGenerator.MirthConnect311.Client.ApiException(400, "Missing required parameter 'channelId' when calling MessagesApi->ReprocessMessages1");
            }


            OpenapiGenerator.MirthConnect311.Client.RequestOptions localVarRequestOptions = new OpenapiGenerator.MirthConnect311.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/xml",
                "application/json"
            };

            var localVarContentType = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = OpenapiGenerator.MirthConnect311.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("channelId", OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToString(channelId)); // path parameter
            if (minMessageId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "minMessageId", minMessageId));
            }
            if (maxMessageId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "maxMessageId", maxMessageId));
            }
            if (minOriginalId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "minOriginalId", minOriginalId));
            }
            if (maxOriginalId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "maxOriginalId", maxOriginalId));
            }
            if (minImportId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "minImportId", minImportId));
            }
            if (maxImportId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "maxImportId", maxImportId));
            }
            if (startDate != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "startDate", startDate));
            }
            if (endDate != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "endDate", endDate));
            }
            if (textSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "textSearch", textSearch));
            }
            if (textSearchRegex != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "textSearchRegex", textSearchRegex));
            }
            if (status != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "status", status));
            }
            if (includedMetaDataId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "includedMetaDataId", includedMetaDataId));
            }
            if (excludedMetaDataId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "excludedMetaDataId", excludedMetaDataId));
            }
            if (serverId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "serverId", serverId));
            }
            if (rawContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "rawContentSearch", rawContentSearch));
            }
            if (processedRawContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "processedRawContentSearch", processedRawContentSearch));
            }
            if (transformedContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "transformedContentSearch", transformedContentSearch));
            }
            if (encodedContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "encodedContentSearch", encodedContentSearch));
            }
            if (sentContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "sentContentSearch", sentContentSearch));
            }
            if (responseContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "responseContentSearch", responseContentSearch));
            }
            if (responseTransformedContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "responseTransformedContentSearch", responseTransformedContentSearch));
            }
            if (processedResponseContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "processedResponseContentSearch", processedResponseContentSearch));
            }
            if (connectorMapContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "connectorMapContentSearch", connectorMapContentSearch));
            }
            if (channelMapContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "channelMapContentSearch", channelMapContentSearch));
            }
            if (sourceMapContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "sourceMapContentSearch", sourceMapContentSearch));
            }
            if (responseMapContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "responseMapContentSearch", responseMapContentSearch));
            }
            if (processingErrorContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "processingErrorContentSearch", processingErrorContentSearch));
            }
            if (postprocessorErrorContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "postprocessorErrorContentSearch", postprocessorErrorContentSearch));
            }
            if (responseErrorContentSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "responseErrorContentSearch", responseErrorContentSearch));
            }
            if (metaDataSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "metaDataSearch", metaDataSearch));
            }
            if (metaDataCaseInsensitiveSearch != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "metaDataCaseInsensitiveSearch", metaDataCaseInsensitiveSearch));
            }
            if (textSearchMetaDataColumn != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "textSearchMetaDataColumn", textSearchMetaDataColumn));
            }
            if (minSendAttempts != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "minSendAttempts", minSendAttempts));
            }
            if (maxSendAttempts != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "maxSendAttempts", maxSendAttempts));
            }
            if (attachment != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "attachment", attachment));
            }
            if (error != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "error", error));
            }
            if (replace != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "replace", replace));
            }
            if (filterDestinations != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("", "filterDestinations", filterDestinations));
            }
            if (metaDataId != null)
            {
                localVarRequestOptions.QueryParameters.Add(OpenapiGenerator.MirthConnect311.Client.ClientUtils.ParameterToMultiMap("multi", "metaDataId", metaDataId));
            }

            // authentication (cookieAuth) required
            // cookie parameter support
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("JSESSIONID")))
            {
                localVarRequestOptions.Cookies.Add(new Cookie("JSESSIONID", this.Configuration.GetApiKeyWithPrefix("JSESSIONID")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<Object>("/channels/{channelId}/messages/_reprocess", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReprocessMessages1", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

    }
}
